### Decode Tiles Syntax

<div class="syntax">
decode_tiles( sz, headerBytes ) {
    tileCols = ( MaxSbCols + MaxSbTileWidth - 1) / MaxSbTileWidth
    tileRows = ( MaxSbRows + MaxSbTileHeight - 1) / MaxSbTileHeight
    NumTiles = tileCols * tileRows
    TileNum = 0
    for ( tileRow = 0; tileRow < tileRows; tileRow++ ) {
        for ( tileCol = 0; tileCol < tileCols; tileCol++ ) {
            if ( TgSize == 0 ) {
                tile_group_header( )
                trailing_bits( )
                sz -= headerBytes
            }
            lastTile = (tileRow == tileRows - 1) && (tileCol == tileCols - 1)
            if ( lastTile ) {
                tile_size = sz
            } else {
                @@tile_size                                             le(TileSizeBytes)
                sz -= tile_size + TileSizeBytes
            }
            MiRowStart = get_tile_offset( tileRow, MiRows, MaxSbTileHeight )
            MiRowEnd = get_tile_offset( tileRow + 1, MiRows, MaxSbTileHeight )
            MiColStart = get_tile_offset( tileCol, MiCols, MaxSbTileWidth )
            MiColEnd = get_tile_offset( tileCol + 1, MiCols, MaxSbTileWidth )
            if ( TileNum == tg_start ) {
                tileGroupRowStart = tileRow
                tileGroupColStart = tileCol
            }
            if (tileCol >= tileGroupColStart)
                AboveSameTileGroup = tileRow > tileGroupRowStart
            else
                AboveSameTileGroup = tileRow >= tileGroupRowStart
            CurrentQIndex = base_q_idx
            init_bool( tile_size )
            decode_tile( )
            exit_bool( )
            TgSize--
            TileNum++
        }
    }
}
</div>
