## Parsing Process


### Parsing Process for f(n)

This process is invoked when the descriptor of a syntax element in the syntax
tables is equal to f(n).

The next n bits are read from the bit stream.

This process is specified as follows:

~~~~~ c
x = 0
for ( i = 0; i < n; i++ ) {
    x = 2 * x + read_bit( )
}
~~~~~

read_bit( ) reads the next bit from the bitstream and advances the bitstream
pointer by 1. If the bitstream is provided as a series of bytes, then the
first bit is given by the most significant bit of the first byte.

The value for the syntax element is given by x.


### Parsing Process for Boolean Decoder

Aside from the uncompressed header and the partition sizes, the entire
bitstream is entropy coded. The entropy decoder is referred to as the "Boolean
decoder" and the function init_bool( sz ), exit_bool( ), and read_bool( p )
are used in this Specification to indicate the entropy decoding operation.


#### Initialization Process for Boolean Decoder

The input to this process is a variable sz specifying the number of bytes to be
read by the Boolean decoder.

This process is invoked when the function init_bool( sz ) is called from the
syntax structure.

**Note:** The bit position will always be byte aligned when init_bool is invoked
because the uncompressed header and the data partitions are always a whole
number of bytes long.
{:.alert .alert-info }

The variable UpdateCdfs (representing if this is the biggest tile seen so far) is set equal to (sz > MaxTileSize).

The variable MaxTileSize (that tracks the largest tile size seen so far) is set equal to Max( MaxTileSize, sz ).

The variable buf is read using the f(15) parsing process.

The variable BoolValue is set to ((1 \<\< 15) - 1) ^ buf.

The variable BoolRange is set to 1 \<\< 15.

The variable BoolMaxBits is set to 8 * sz - 15.

A copy is made of each of the CDF arrays mentioned in the semantics for
setup_past_independence. The name of the copy is the name of the CDF array
prefixed with "Tile".  This copying produces the following arrays:

  * TileYModeCdf

  * TileUVModeCdf
  
  * TileAngleDeltaCdf

  * TilePartitionW8Cdf

  * TilePartitionCdf

  * TileSegmentIdCdf

  * TileSegmentIdPredictedCdf

  * TileTx8x8Cdf

  * TileTx16x16Cdf

  * TileTx32x32Cdf
  
  * TileTx64x64Cdf
  
  * TileTxfmSplitCdf

  * TileInterpFilterCdf

  * TileMotionModeCdf

  * TileNewMvCdf

  * TileZeroMvCdf

  * TileRefMvCdf

  * TileCompoundModeCdf

  * TileDrlModeCdf

  * TileIsInterCdf

  * TileCompModeCdf

  * TileSkipCdf

  * TileCompRefCdf

  * TileCompBwdRefCdf

  * TileSingleRefCdf

  * TileMvJointCdf

  * TileMvSignCdf
  
  * TileMvClassCdf

  * TileMvClass0BitCdf

  * TileMvFrCdf

  * TileMvClass0FrCdf

  * TileMvClass0HpCdf
  
  * TileMvBitCdf

  * TileMvHpCdf

  * TilePaletteYModeCdf

  * TilePaletteUVModeCdf

  * TilePaletteYSizeCdf

  * TilePaletteUVSizeCdf

  * TilePaletteSize2YColorCdf

  * TilePaletteSize2UVColorCdf

  * TilePaletteSize3YColorCdf

  * TilePaletteSize3UVColorCdf

  * TilePaletteSize4YColorCdf

  * TilePaletteSize4UVColorCdf

  * TilePaletteSize5YColorCdf

  * TilePaletteSize5UVColorCdf

  * TilePaletteSize6YColorCdf

  * TilePaletteSize6UVColorCdf

  * TilePaletteSize7YColorCdf

  * TilePaletteSize7UVColorCdf

  * TilePaletteSize8YColorCdf

  * TilePaletteSize8UVColorCdf

  * TileDeltaQCdf

  * TileDeltaLFCdf
  
  * TileDeltaLFMultiCdf[ i ] for i = 0..FRAME_LF_COUNT-1

  * TileIntraTxTypeSet1Cdf

  * TileIntraTxTypeSet2Cdf

  * TileInterTxTypeSet1Cdf

  * TileInterTxTypeSet2Cdf

  * TileInterTxTypeSet3Cdf

  * TileUseObmcCdf

  * TileInterIntraCdf

  * TileCompRefTypeCdf

  * TileCflSignCdf

  * TileUniCompRefCdf

  * TileWedgeInterIntraCdf

  * TileCompoundTypeCdf

  * TileInterIntraModeCdf

  * TileCflAlphaCdf
  
  * TileUseWienerCdf
  
  * TileUseSgrprojCdf
  
  * TileRestorationTypeCdf
  
  * TileTxbSkipCdf
  
  * TileEobFlagCdf
  
  * TileEobExtraCdf
  
  * TileDcSignCdf
  
  * TileCoeffBaseEobCdf
  
  * TileCoeffBaseCdf
  
  * TileCoeffBrCdf

#### Boolean Decoding Process

The input to this process is a variable p which specifies the probability (in
the range 0 to 255) to use during bool decode.

The output of this process is the variable bool, containing a decoded bool.

This process is invoked when the function read_bool( p ) is called from the
syntax structure.

An array cdf of length 3 is constructed as follows:

~~~~ c
cdf[ 0 ] = ( ( p << 15 ) + 256 – p ) >> 8
cdf[ 1 ] = 1 << 15
cdf[ 2 ] = 0
~~~~

The return value for the function is given by read_symbol( cdf ).


#### Exit Process for Boolean Decoder

This process is invoked when the function exit_bool( ) is called from the syntax
structure.

The padding syntax element is read using the f(BoolMaxBits) parsing process.

It is a requirement of bitstream conformance that BoolMaxBits is greater than or
equal to 0 whenever this process is invoked.

It is a requirement of bitstream conformance that padding is equal to 0.

**Note:** The padding is required to make the bit position byte aligned.
It is legal for frames to end with more than one byte of padding.
{:.alert .alert-info }

If UpdateCdfs is equal to 1, a copy is made of the final CDF values for each of the
CDF arrays mentioned in the semantics for setup_past_independence. 
The name of the destination for the copy is the name of the CDF array
prefixed with "Saved".  The name of the source for the copy is the name of the CDF array
prefixed with "Tile".
For example, an array SavedYModeCdf will be created with values equal to TileYModeCdf.

#### Parsing Process for read_literal

This process is invoked when the function read_literal( n ) is invoked.

This process is specified as follows:

~~~~~ c
x = 0
for ( i = 0 ; i < n; i++ ) {
    x = 2 * x + read_bool( 128 )
}
~~~~~

The return value for the function is given by x.


#### Symbol Decoding Process

The input to this process is an array cdf of length N + 1 which specifies the
cumulative distribution for a symbol with N possible values.

The output of this process is the variable symbol, containing a decoded syntax
element. The process also modifies the input array cdf to adapt the
probabilities to the content of the stream.

This process is invoked when the function read_symbol( cdf ) is called.

**Note:** When this process is invoked, N will be greater than 1 and cdf[ N-1 ]
will be equal to 1 \<\< 15.
{:.alert .alert-info }

The variables cur, prev, and symbol are calculated as follows:

~~~~ c
cur = BoolRange
symbol = -1
do {
  symbol++
  prev = cur
  f = ( 1 << 15 ) - cdf[ symbol ]
  cur = ((BoolRange >> 8) * (f >> EC_PROB_SHIFT)) >> (7 - EC_PROB_SHIFT)
  cur += EC_MIN_PROB * (N - symbol - 1)
} while ( BoolValue < cur )
~~~~

**Note:** Implementations may prefer to store the inverse cdf to move the
subtraction out of this loop.
{:.alert .alert-info }

The variable BoolRange is set to prev - cur.

The variable BoolValue is set equal to BoolValue - cur.

The range and value are renormalized by the following ordered steps:

  1. The variable bits is set to 15 – floor( log2( BoolRange ) ).
     This represents the number of new bits to be read from the bitstream.

  2. The variable BoolRange is set to BoolRange \<\< bits.

  3. The variable newData is read using the f(bits) parsing process.

  4. The variable BoolValue is set to
     newData ^ ( ( ( BoolValue + 1 ) \<\< bits ) - 1 ).

  5. The variable BoolMaxBits is set to BoolMaxBits - bits.

**Note:** bits may be equal to 0, in which case these ordered steps have no
effect.
{:.alert .alert-info }

The cumulative distribution is updated as follows:

~~~~ c
if (N == 2) {
    rate = 4 + (cdf[2] > 7) + (cdf[2] > 15) + 1
} else {
    rate = 4 + ( cdf[N] > 31 ) + floor ( log2 ( N ) )
}
rate2 = 5
tmp0 = 1 << rate2
tmp = tmp0
diff = (((1<<15) - (N << rate2)) >> rate) << rate
for (i = 0; i < N - 1; i++) {
  tmp += (i == symbol ? diff : 0)
  cdf[i] -= ((cdf[i] - tmp) >> rate)
  tmp += tmp0
}
cdf[N] += (cdf[N] < 32)
~~~~

**Note:** The last entry of the cdf array is used to keep a count of the number
of times the symbol has been decoded (up to a maximum of 32).  This allows the
cdf to change faster for the first 32 times the symbol is decoded.
Symbols with only 2 entries adapt fast for the first 8 times, then at a medium rate, then at a slow rate
{:.alert .alert-info }

The return value from the function is given by symbol.


### Parsing process for CDF encoded syntax elements

This process is invoked when the descriptor of a syntax element in the syntax
tables is equal to S.

The input to this process is the name of a syntax element.

[Section 8.3.1][] specifies how a CDF array is chosen for the syntax element.
The variable cdf is set equal to a reference to this CDF array.

**Note:** The array must be passed by reference because read_symbol will adjust
the array contents.
{:.alert .alert-info }

The output of this process is the result of calling the function read_symbol( cdf ).


#### CDF Selection Process

The input to this process is the name of a syntax element.

The output of this process is a reference to a CDF array.

When the description in this section uses variables, these variables are
taken to have the values defined by the syntax tables at the point that the
syntax element is being decoded.

The probabilities depend on the syntax element as follows:

**intra_frame_y_mode**: The cdf for intra_frame_y_mode is given by
Default_Intra_Frame_Y_Mode_Cdf[ abovemode ][ leftmode ] where abovemode and leftmode are
the intra modes used for the blocks immediately above and to the left of this
block and are computed as:

~~~~~ c
abovemode = Intra_Mode_Context[ AvailU ? YModes[ MiRow - 1 ][ MiCol ] : DC_PRED ]
leftmode = Intra_Mode_Context[ AvailL ? YModes[ MiRow ][ MiCol - 1] : DC_PRED ]
~~~~~

where Intra_Mode_Context is defined as follows:

~~~~~ c
Intra_Mode_Context[ INTRA_MODES ] = {
  0, 1, 2, 3, 4, 4, 4, 4, 3, 0, 1, 2, 0
}
~~~~~

**Note:** We are using a 2D array to store the YModes for clarity. It is
possible to reduce memory consumption by only storing one intra mode for
each 4x4 horizontal and vertical position, i.e. to use two 1D arrays instead.
{:.alert .alert-info }

**y_mode**: The cdf for y_mode is given by TileYModeCdf[ ctx ] where the
variable ctx is computed as Size_Group[ MiSize ].

**uv_mode**: The cdf for uv_mode is given by TileUVModeCdf[ ctx ] where the
variable ctx is set equal to YMode.

**angle_delta_y**: The cdf for angle_delta_y is given by TileAngleDeltaCdf[YMode - V_PRED].

**angle_delta_uv**: The cdf for angle_delta_uv is given by TileAngleDeltaCdf[UVMode - V_PRED].

**partition**: The variable ctx is computed as follows:

~~~~~ c
bsl = Mi_Width_Log2[ bSize ]
above = AvailU && ( Mi_Width_Log2[ MiSizes[ r - 1 ][ c ] ] < bsl )
left = AvailL && ( Mi_Height_Log2[ MiSizes[ r ][ c - 1 ] ] < bsl )
ctx = bsl * 4 + left * 2 + above
~~~~~

The cdf is derived as follows:

  * If ctx is less than PARTITION_CONTEXTS_W8, the cdf is given by TilePartitionW8Cdf[ ctx ].
  
  * Otherwise (ctx is greater than or equal to PARTITION_CONTEXTS_W8), the cdf is given by
    TilePartitionCdf[ ctx - PARTITION_CONTEXTS_W8 ].

**split_or_horz**: split_or_horz uses the same derivation for the variable ctx
as for the syntax element partition.

The cdf to return is given by an array of length 3 which is constructed as
follows:

~~~~~ c
partitionCdf = TilePartitionCdf[ ctx - PARTITION_CONTEXTS_W8 ]
psum = ( partitionCdf[ PARTITION_VERT ] - partitionCdf[ PARTITION_VERT - 1 ] +
         partitionCdf[ PARTITION_SPLIT ] - partitionCdf[ PARTITION_SPLIT - 1 ] +
         partitionCdf[ PARTITION_HORZ_A ] - partitionCdf[ PARTITION_HORZ_A - 1 ] +
         partitionCdf[ PARTITION_VERT_A ] - partitionCdf[ PARTITION_VERT_A - 1 ] +
         partitionCdf[ PARTITION_VERT_B ] - partitionCdf[ PARTITION_VERT_B - 1 ] +
         partitionCdf[ PARTITION_VERT_4 ] - partitionCdf[ PARTITION_VERT_4 - 1 ] )
cdf[0] = ( 1 << 15 ) - psum
cdf[1] = 1 << 15
cdf[2] = 0
~~~~~

**Note:** The syntax element split_or_horz is not allowed to return a
PARTITION_VERT, so the probability for a vertical partition is assigned to the
probability for the split partition.
{:.alert .alert-info }

**split_or_vert**: split_or_vert uses the same derivation for the variable ctx
as for the syntax element partition.

The cdf to return is given by an array of length 3 which is constructed as follows:

~~~~~ c
partitionCdf = TilePartitionCdf[ ctx - PARTITION_CONTEXTS_W8 ]
psum = ( partitionCdf[ PARTITION_HORZ ] - partitionCdf[ PARTITION_HORZ - 1 ] +
         partitionCdf[ PARTITION_SPLIT ] - partitionCdf[ PARTITION_SPLIT - 1 ] +
         partitionCdf[ PARTITION_HORZ_A ] - partitionCdf[ PARTITION_HORZ_A - 1 ] +
         partitionCdf[ PARTITION_HORZ_B ] - partitionCdf[ PARTITION_HORZ_B - 1 ] +
         partitionCdf[ PARTITION_VERT_A ] - partitionCdf[ PARTITION_VERT_A - 1 ] +
         partitionCdf[ PARTITION_HORZ_4 ] - partitionCdf[ PARTITION_HORZ_4 - 1 ] )
cdf[0] = ( 1 << 15 ) - psum
cdf[1] = 1 << 15
cdf[2] = 0
~~~~~

**tx_size**: the cdf depends on the value of maxTxSize and ctx,
where ctx is computed by:

~~~~~ c
    above = maxTxSize
    left = maxTxSize
    if ( AvailU && !Skips[ MiRow - 1 ][ MiCol ] )
        above = TxSizes[ MiRow - 1][ MiCol ]
    if ( AvailL && !Skips[ MiRow ][ MiCol - 1 ] )
        left = TxSizes[ MiRow ][ MiCol - 1 ]
    if ( !AvailL )
        left = above
    if ( !AvailU )
        above = left
    ctx = (above+left) > maxTxSize
~~~~~

The cdf to return is given by:

  * TileTx64x64Cdf[ ctx ] if maxTxSize is equal to TX_64X64.
  
  * TileTx32x32Cdf[ ctx ] if maxTxSize is equal to TX_32X32.

  * TileTx16x16Cdf[ ctx ] if maxTxSize is equal to TX_16X16.

  * TileTx8x8Cdf[ ctx ] otherwise.
  
**txfm_split**: the cdf is given by TileTxfmSplitCdf[ ctx ], where ctx is computed by:

~~~~~ c
if ( !AvailU ) {
    aboveW = 4
} else {
    if ( Skips[ row - 1][ col ] )
        aboveW = Block_Width[ MiSizes[ row - 1 ][ col ] ]
    else
        aboveW = Tx_Width[ InterTxSizes[ row - 1 ][ col ] ]
}
if ( !AvailL ) {
    leftH = 4
} else {
    if ( Skips[ row - 1][ col ] )
        leftH = Block_Height[ MiSizes[ row  ][ col - 1 ] ]
    else
        leftH = Tx_Height[ InterTxSizes[ row  ][ col - 1] ]
}
txW = Tx_Width[txSz]
txH = Tx_Height[txSz]
above = aboveW < txW
left = leftH < txH
ctx = TXFM_PARTITION_CONTEXTS - 1
size = Max( Block_Width[ MiSize ], Block_Height[ MiSize ] )
size = Min( 32, size )
maxTxSz = find_tx_size( size, size )
if (maxTxSz >= TX_8X8) {
    ctx = (txSz != maxTxSz && maxTxSz > TX_8X8) +
               (TX_SIZES - 1 - maxTxSz) * 2
}
if (ctx != TXFM_PARTITION_CONTEXTS - 1) {
    ctx = ctx * 3 + above + left
}
~~~~~

**segment_id**: the cdf is given by TileSegmentIdCdf.

**seg_id_predicted**: the cdf is given by TileSegmentIdPredictedCdf[ ctx ],
where ctx is computed by:

~~~~~ c
ctx = LeftSegPredContext[ MiRow ] + AboveSegPredContext[ MiCol ]
~~~~~

**new_mv**: the cdf is given by TileNewMvCdf[ NewMvContext ].

**zero_mv**: the cdf is given by TileZeroMvCdf[ ZeroMvContext ].

**ref_mv**: the cdf is given by TileRefMvCdf[ RefMvContext ].

**drl_mode**: the cdf is given by TileDrlModeCdf[ DrlCtxStack[ idx ] ].

**is_inter**: the cdf is given by TileIsInterCdf[ ctx ] where ctx is
computed by:

~~~~~ c
if ( AvailU && AvailL )
    ctx = (LeftIntra && AboveIntra) ? 3 : LeftIntra || AboveIntra
else if ( AvailU || AvailL )
    ctx = 2 * (AvailU ? AboveIntra : LeftIntra)
else
    ctx = 0
~~~~~

**comp_mode**: the cdf is given by TileCompModeCdf[ ctx ] where ctx is
computed by:

~~~~~ c
if ( AvailU && AvailL ) {
    if ( AboveSingle && LeftSingle )
    ctx = (AboveRefFrame[ 0 ] == CompFixedRef)
        ^ (LeftRefFrame[ 0 ] == CompFixedRef)
    else if ( AboveSingle )
        ctx = 2 + (AboveRefFrame[ 0 ] == CompFixedRef || AboveIntra)
    else if ( LeftSingle )
        ctx = 2 + (LeftRefFrame[ 0 ] == CompFixedRef || LeftIntra)
    else
        ctx = 4
} else if ( AvailU ) {
    if ( AboveSingle )
        ctx = AboveRefFrame[ 0 ] == CompFixedRef
    else
        ctx = 3
} else if ( AvailL ) {
    if ( LeftSingle )
        ctx= LeftRefFrame[ 0 ] == CompFixedRef
    else
        ctx = 3
} else {
    ctx = 1
}
~~~~~

**skip**: the cdf is given by TileSkipCdf[ ctx ] where ctx is computed
by:

~~~~~ c
    ctx = 0
    if ( AvailU )
        ctx += Skips[ MiRow - 1 ][ MiCol ]
    if ( AvailL )
        ctx += Skips[ MiRow ][ MiCol - 1 ]
~~~~~

**comp_ref**: the cdf is given by TileCompRefCdf[ ctx ][ 0 ] where ctx is
computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
left0 = LeftRefFrame[ 0 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        ctx = 1 + 2 * (!check_golden_or_last3(above0))
    } else if ( AboveIntra ) {
        ctx = 1 + 2 * (!check_golden_or_last3(left0))
    } else {
        frfa = above0
        frfl = left0
        if ( frfa == frfl && check_golden_or_last3(frfa) ) {
            ctx = 0
        } else if ( LeftSingle && AboveSingle ) {
            if ((check_backward(frfa) && check_last_or_last2(frfl)) ||
                (check_backward(frfl) && check_last_or_last2(frfa)))
                ctx = 4
            else if ( check_golden_or_last3(frfa) || check_golden_or_last3(frfl) )
                ctx = 1
            else
                ctx = 3
        } else if ( LeftSingle || AboveSingle ) {
            frfc = LeftSingle ? frfa : frfl
            rfs = AboveSingle ? frfa : frfl
            if ( check_golden_or_last3(frfc) && !check_golden_or_last3(rfs) )
                ctx = 1
            else if ( check_golden_or_last3(rfs) && !check_golden_or_last3(frfc) )
                ctx = 2
            else
                ctx = 4
        } else if ( check_last_or_last2(frfa) && check_last_or_last2(frfl) ) {
            ctx = 4
        } else {
            ctx = 2
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra ) {
        ctx = 2
    } else {
        if ( AboveSingle )
            ctx = 3 * ( !check_golden_or_last3(above0) )
        else
            ctx = 4 * ( !check_golden_or_last3(above0) )
    }
} else if ( AvailL ) {
    if ( LeftIntra ) {
        ctx = 2
    } else {
        if ( LeftSingle )
            ctx = 3 * ( !check_golden_or_last3(left0) )
        else
            ctx = 4 * ( !check_golden_or_last3(left0) )
    }
} else {
    ctx = 2
}
~~~~~

**comp_ref_p1**: the cdf is given by TileCompRefCdf[ ctx ][ 1 ] where ctx is
computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
left0 = LeftRefFrame[ 0 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        ctx = 1 + 2 * (!check_last(above0))
    } else if ( AboveIntra ) {
        ctx = 1 + 2 * (!check_last(left0))
    } else {
        frfa = above0
        frfl = left0
        if ( frfa == frfl && check_last(frfa) ) {
            ctx = 0
        } else if ( LeftSingle && AboveSingle ) {
            if ( check_last(frfa) || check_last(frfl) )
                ctx = 1
            else if ( check_golden_or_last3(frfa) || check_golden_or_last3(frfl) )
                ctx = 2 + (frfa != frfl)
            else if ( frfa==frfl ||
                     (check_backward(frfa) && check_backward(frfl)))
                ctx = 3
            else
                ctx = 4
        } else if ( LeftSingle || AboveSingle ) {
            frfc = LeftSingle ? frfa : frfl
            rfs = AboveSingle ? frfa : frfl
            if (check_last(frfc) && !check_last(rfs))
                ctx= 1
            else if (check_last(rfs) && !check_last(frfc))
                ctx = 2
              else
                ctx = 3 + (frfc == LAST2_FRAME || check_golden_or_last3(rfs))
        } else if ( check_last(frfa) && check_last(frfl) ) {
            ctx = 2
        } else {
            ctx = 3 + (check_golden_or_last3(frfa) || check_golden_or_last3(frfl))
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra ) {
        ctx = 2
    } else {
        if ( !AboveSingle )
            ctx = 4 * (!check_last(above0))
        else if (check_last(above0))
            ctx = 0
        else
            ctx = 2 + check_golden_or_last3(above0)
    }
} else if ( AvailL ) {
    if ( LeftIntra ) {
        ctx = 2
    } else {
        if ( !LeftSingle )
            ctx = 4 * (!check_last(LeftRefFrame[ ref_frame_sign_bias[ BWDREF_FRAME ] ]))
        else if (check_last(left0))
            ctx = 0
        else
            ctx = 2 + check_golden_or_last3(left0)
    }
} else {
    ctx = 2
}
~~~~~

**comp_ref_p2**: the cdf is given by TileCompRefCdf[ ctx ][ 2 ] where ctx is
computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
left0 = LeftRefFrame[ 0 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        ctx = 1 + 2 * (!check_golden(above0))
    } else if ( AboveIntra ) {
        ctx = 1 + 2 * (!check_golden(left0))
    } else {
        frfa = above0
        frfl = left0
        if ( frfa == frfl && check_golden(frfa) ) {
            ctx = 0
        } else if ( LeftSingle && AboveSingle ) {
            if ( check_golden(frfa) || check_golden(frfl) )
                ctx = 1
            else if ( check_last_or_last2(frfa) || check_last_or_last2(frfl) )
                ctx = 2 + (frfa != frfl)
            else if ( frfa==frfl ||
                     (check_backward(frfa) && check_backward(frfl)))
                ctx = 3
            else
                ctx = 4
        } else if ( LeftSingle || AboveSingle ) {
            frfc = LeftSingle ? frfa : frfl
            rfs = AboveSingle ? frfa : frfl
            if (check_golden(frfc) && !check_golden(rfs))
                ctx= 1
            else if (check_golden(rfs) && !check_golden(frfc))
                ctx = 2
              else
                ctx = 3 + (frfc == LAST3_FRAME || check_last_or_last2(rfs))
        } else if ( check_golden(frfa) && check_golden(frfl) ) {
            ctx = 2
        } else {
            ctx = 3 + (check_last_or_last2(frfa) || check_last_or_last2(frfl))
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra ) {
        ctx = 2
    } else {
        if ( !AboveSingle )
            ctx = 4 * (!check_golden(above0))
        else if (check_golden(above0))
            ctx = 0
        else
            ctx = 2 + check_last_or_last2(above0)
    }
} else if ( AvailL ) {
    if ( LeftIntra ) {
        ctx = 2
    } else {
        if ( !LeftSingle )
            ctx = 4 * (!check_golden(LeftRefFrame[ ref_frame_sign_bias[ BWDREF_FRAME ] ]))
        else if (check_golden(left0))
            ctx = 0
        else
            ctx = 2 + check_last_or_last2(left0)
    }
} else {
    ctx = 2
}
~~~~~

**comp_bwdref**: the cdf is given by TileCompBwdRefCdf[ ctx ][ 0 ] where ctx is
computed by:

~~~~~ c
brfarf2Count = count_refs( BWDREF_FRAME ) + count_refs( ALTREF2_FRAME )
arfCount = count_refs( ALTREF_FRAME )
ctx = ref_count_ctx( brfarf2Count, arfCount )
~~~~~

where count_refs is defined as:

~~~~~ c
count_refs(frameType) {
    c = 0
    if ( AvailU ) {
        if ( AboveRefFrame[ 0 ] == frameType ) c++
        if ( AboveRefFrame[ 1 ] == frameType ) c++
    }
    if ( AvailL ) {
        if ( LeftRefFrame[ 0 ] == frameType ) c++
        if ( LeftRefFrame[ 1 ] == frameType ) c++
    }
    return c
}
~~~~~

and ref_count_ctx is defined as:

~~~~~ c
ref_count_ctx(counts0, counts1) {
  if (counts0 < counts1)
    return 0
  else if (counts0 == counts1)
    return 1
  else
    return 2
}
~~~~~

**comp_bwdref_p1**: the cdf is given by TileCompBwdRefCdf[ ctx ][ 1 ] where ctx is
computed by:

~~~~~ c
brfCount = count_refs( BWDREF_FRAME )
arf2Count = count_refs( ALTREF2_FRAME )
ctx = ref_count_ctx( brfCount, arf2Count )
~~~~~

where count_refs and ref_count_ctx are the same as given in the CDF selection process for comp_bwdref.

**single_ref_p1**: the cdf is given by TileSingleRefCdf[ ctx ][ 0 ] where
ctx is computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
left0 = LeftRefFrame[ 0 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        if ( AboveSingle )
            ctx = 4 * (!check_backward(above0))
        else
            ctx = 2
    } else if ( AboveIntra ) {
        if ( LeftSingle )
            ctx = 4 * (!check_backward(left0))
        else
            ctx = 2
    } else {
        if ( AboveSingle && LeftSingle ) {
            ctx = 2 * (!check_backward(above0)) +
                  2 * (!check_backward(left0))
        } else if ( !AboveSingle && !LeftSingle ) {
            ctx = 2
        } else {
            rfs = AboveSingle ? above0 : left0
            ctx = (!check_backward(rfs)) ? 4 : 1
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra ) {
        ctx = 2
    } else {
        if ( AboveSingle )
            ctx = 4 * (!check_backward(above0))
        else
            ctx = 2
    }
} else if ( AvailL ) {
    if ( LeftIntra ) {
        ctx = 2
    } else {
        if ( LeftSingle )
            ctx = 4 * (!check_backward(left0))
        else
            ctx = 2
    }
} else {
    ctx = 2
}
~~~~~

**single_ref_p2**: the cdf is given by TileSingleRefCdf[ ctx ][ 1 ] where
ctx is computed by:

~~~~~ c
brfarf2Count = count_refs( BWDREF_FRAME ) + count_refs( ALTREF2_FRAME )
arfCount = count_refs( ALTREF_FRAME )
ctx = ref_count_ctx( brfarf2Count, arfCount )
~~~~~

where count_refs and ref_count_ctx are the same as given in the CDF selection process for comp_bwdref.

**Note:** The context calculation for single_ref_p2 is the same as for
comp_bwdref. ctx can only equal 0, 1, or 2 for single_ref_p2.
{:.alert .alert-info }

**single_ref_p3**: the cdf is given by TileSingleRefCdf[ ctx ][ 2 ] where
ctx is computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
above1 = AboveRefFrame[ 1 ]
left0 = LeftRefFrame[ 0 ]
left1 = LeftRefFrame[ 1 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        if ( AboveSingle ) {
            if ( check_backward(above0) )
                ctx = 3
            else
                ctx = 4 * check_last_or_last2(above0)
        } else {
            ctx = 1 + 2 * (check_last_or_last2(above0) ||
                           check_last_or_last2(above1))
        }
    } else if ( AboveIntra ) {
        if ( LeftSingle ) {
            if ( check_backward(left0) )
                ctx = 3
            else
                ctx = 4 * check_last_or_last2(left0)
        } else {
                ctx = 1 + 2 * (check_last_or_last2(left0) ||
                               check_last_or_last2(left1))
        }
    } else {
        if ( AboveSingle && LeftSingle ) {
            if (check_backward(above0) && check_backward(left0)) {
                ctx = 2 + (above0 == left0)
            } else if (check_backward(above0) ||
                       check_backward(left0)) {
                edge0 = check_backward(above0) ? left0 : above0
                ctx = 4 * check_last_or_last2(edge0)
            } else {
                ctx = 2 * check_last_or_last2(above0) + 2 * check_last_or_last2(left0)
            }
        } else if ( !AboveSingle && !LeftSingle ) {
            if (above0 == left0 && above1 == left1)
                ctx = 3 * (check_last_or_last2(above0) ||
                           check_last_or_last2(above1) ||
                           check_last_or_last2(left0) ||
                           check_last_or_last2(left1))
            else
                ctx = 2
        } else {
            rfs = AboveSingle ? above0 : left0
            crf1 = AboveSingle ? left0 : above0
            crf2 = AboveSingle ? left1 : above1
            if (check_last_or_last2(rfs))
                ctx = 3 + (check_last_or_last2(crf1) || check_last_or_last2(crf2))
            else if (check_golden_or_last3(rfs))
                ctx = (check_last_or_last2(crf1) || check_last_or_last2(crf2))
            else
                ctx = 1 + 2 * (check_last_or_last2(crf1) || check_last_or_last2(crf2))
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra || (check_backward(above0) && AboveSingle) )
        ctx= 2
    else if ( AboveSingle )
        ctx= 4 * check_last_or_last2(above0)
    else
        ctx= 3 * ( check_last_or_last2(above0) ||
                   check_last_or_last2(above1) )
} else if ( AvailL ) {
    if ( LeftIntra || (check_backward(left0) && LeftSingle) )
        ctx = 2
    else if ( LeftSingle )
        ctx = 4 * check_last_or_last2(left0)
    else
        ctx = 3 * ( check_last_or_last2(left0) ||
                    check_last_or_last2(left1) )
} else
    ctx = 2
~~~~~

**single_ref_p4**: the cdf is given by TileSingleRefCdf[ ctx ][ 3 ] where
ctx is computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
above1 = AboveRefFrame[ 1 ]
left0 = LeftRefFrame[ 0 ]
left1 = LeftRefFrame[ 1 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        if ( AboveSingle ) {
            if ( !check_last_or_last2(above0) )
                ctx = 3
            else
                ctx = 4 * check_last(above0)
        } else {
            ctx = 1 + 2 * (check_last(above0) ||
                           check_last(above1))
        }
    } else if ( AboveIntra ) {
        if ( LeftSingle ) {
            if ( !check_last_or_last2(left0) )
                ctx = 3
            else
                ctx = 4 * check_last(left0)
        } else {
                ctx = 1 + 2 * (check_last(left0) ||
                               check_last(left1))
        }
    } else {
        if ( AboveSingle && LeftSingle ) {
            if (!check_last_or_last2(above0) && !check_last_or_last2(left0)) {
                ctx = 2 + (above0 == left0)
            } else if (!check_last_or_last2(above0) ||
                       !check_last_or_last2(left0)) {
                edge0 = !check_last_or_last2(above0) ? left0 : above0
                ctx = 4 * check_last(edge0)
            } else {
                ctx = 2 * check_last(above0) + 2 * check_last(left0)
            }
        } else if ( !AboveSingle && !LeftSingle ) {
            if (above0 == left0 && above1 == left1)
                ctx = 3 * (check_last(above0) ||
                           check_last(above1) ||
                           check_last(left0) ||
                           check_last(left1))
            else
                ctx = 2
        } else {
            rfs = AboveSingle ? above0 : left0
            crf1 = AboveSingle ? left0 : above0
            crf2 = AboveSingle ? left1 : above1
            if (check_last(rfs))
                ctx = 3 + (check_last(crf1) || check_last(crf2))
            else if (check_last2(rfs))
                ctx = (check_last(crf1) || check_last(crf2))
            else
                ctx = 1 + 2 * (check_last(crf1) || check_last(crf2))
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra || (!check_last_or_last2(above0) && AboveSingle) )
        ctx= 2
    else if ( AboveSingle )
        ctx= 4 * check_last(above0)
    else
        ctx= 3 * ( check_last(above0) ||
                   check_last(above1) )
} else if ( AvailL ) {
    if ( LeftIntra || (!check_last_or_last2(left0) && LeftSingle) )
        ctx = 2
    else if ( LeftSingle )
        ctx = 4 * check_last(left0)
    else
        ctx = 3 * ( check_last(left0) ||
                    check_last(left1) )
} else
    ctx = 2
~~~~~

**single_ref_p5**: the cdf is given by TileSingleRefCdf[ ctx ][ 4 ] where
ctx is computed by:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
above1 = AboveRefFrame[ 1 ]
left0 = LeftRefFrame[ 0 ]
left1 = LeftRefFrame[ 1 ]
if ( AvailU && AvailL ) {
    if ( AboveIntra && LeftIntra ) {
        ctx = 2
    } else if ( LeftIntra ) {
        if ( AboveSingle ) {
            if ( !check_golden_or_last3(above0) )
                ctx = 3
            else
                ctx = 4 * check_last3(above0)
        } else {
            ctx = 1 + 2 * (check_last3(above0) ||
                           check_last3(above1))
        }
    } else if ( AboveIntra ) {
        if ( LeftSingle ) {
            if ( !check_golden_or_last3(left0) )
                ctx = 3
            else
                ctx = 4 * check_last3(left0)
        } else {
                ctx = 1 + 2 * (check_last3(left0) ||
                               check_last3(left1))
        }
    } else {
        if ( AboveSingle && LeftSingle ) {
            if (!check_golden_or_last3(above0) && !check_golden_or_last3(left0)) {
                ctx = 2 + (above0 == left0)
            } else if (!check_golden_or_last3(above0) ||
                       !check_golden_or_last3(left0)) {
                edge0 = !check_golden_or_last3(above0) ? left0 : above0
                ctx = 4 * check_last3(edge0)
            } else {
                ctx = 2 * check_last3(above0) + 2 * check_last3(left0)
            }
        } else if ( !AboveSingle && !LeftSingle ) {
            if (above0 == left0 && above1 == left1)
                ctx = 3 * (check_last3(above0) ||
                           check_last3(above1) ||
                           check_last3(left0) ||
                           check_last3(left1))
            else
                ctx = 2
        } else {
            rfs = AboveSingle ? above0 : left0
            crf1 = AboveSingle ? left0 : above0
            crf2 = AboveSingle ? left1 : above1
            if (check_last3(rfs))
                ctx = 3 + (check_last3(crf1) || check_last3(crf2))
            else if (check_golden(rfs))
                ctx = (check_last3(crf1) || check_last3(crf2))
            else
                ctx = 1 + 2 * (check_last3(crf1) || check_last3(crf2))
        }
    }
} else if ( AvailU ) {
    if ( AboveIntra || (!check_golden_or_last3(above0) && AboveSingle) )
        ctx= 2
    else if ( AboveSingle )
        ctx= 4 * check_last3(above0)
    else
        ctx= 3 * ( check_last3(above0) ||
                   check_last3(above1) )
} else if ( AvailL ) {
    if ( LeftIntra || (!check_golden_or_last3(left0) && LeftSingle) )
        ctx = 2
    else if ( LeftSingle )
        ctx = 4 * check_last3(left0)
    else
        ctx = 3 * ( check_last3(left0) ||
                    check_last3(left1) )
} else
    ctx = 2
~~~~~

**single_ref_p6**: the cdf is given by TileSingleRefCdf[ ctx ][ 5 ] where
ctx is computed by:

~~~~~ c
brfCount = count_refs( BWDREF_FRAME )
arf2Count = count_refs( ALTREF2_FRAME )
ctx = ref_count_ctx( brfCount, arf2Count )
~~~~~

where count_refs and ref_count_ctx are the same as given in the CDF selection process for comp_bwdref.

**Note:** The context calculation for single_ref_p6 is the same as
for comp_bwdref_p1. ctx can only equal 0, 1, or 2 for single_ref_p6.
{:.alert .alert-info }

**coef_extra_bits**: the cdf depends on the variables cat and cdfIndex as follows:

| cat | cdfIndex | cdf                                 |
|:---:|:--------:|:-----------------------------------:|
| 1   | 0        | Default_Coef_Extra_Bits_Cat1_Cdf    |
| 2   | 0        | Default_Coef_Extra_Bits_Cat2_Cdf    |
| 3   | 0        | Default_Coef_Extra_Bits_Cat3_Cdf    |
| 4   | 0        | Default_Coef_Extra_Bits_Cat4_Cdf    |
| 5   | 0        | Default_Coef_Extra_Bits_Cat5_S1_Cdf |
| 5   | 1        | Default_Coef_Extra_Bits_Cat5_S2_Cdf |
| 6   | 0        | Default_Coef_Extra_Bits_Cat6_S1_Cdf |
| 6   | 1        | Default_Coef_Extra_Bits_Cat6_S2_Cdf |
| 6   | 2        | Default_Coef_Extra_Bits_Cat6_S3_Cdf |
| 6   | 3        | Default_Coef_Extra_Bits_Cat6_S4_Cdf |
| 6   | 4        | Default_Coef_Extra_Bits_Cat6_S5_Cdf |
{:.table .table-sm .table-bordered }

**compound_mode**: the cdf is given by TileCompoundModeCdf[ CompoundModeContext ].

**interp_filter**: the cdf is given by TileInterpFilterCdf[ ctx ]
where ctx is computed by:

~~~~~ c
    ctx = ( ( dir & 1 ) * 2 + ( RefFrame[ 1 ] > INTRA_FRAME ) ) * 4
    leftType = 3
    aboveType = 3

    if ( AvailL ) {
        if ( RefFrames[ MiRow ][ MiCol - 1 ][ 0 ] == RefFrame[ 0 ] ||
             RefFrames[ MiRow ][ MiCol - 1 ][ 1 ] == RefFrame[ 0 ] )
            leftType = InterpFilters[ MiRow ] [ MiCol - 1 ][ dir ]
    }

    if ( AvailU ) {
        if ( RefFrames[ MiRow - 1 ][ MiCol ][ 0 ] == RefFrame[ 0 ] ||
             RefFrames[ MiRow - 1 ][ MiCol ][ 1 ] == RefFrame[ 0 ] )
            aboveType = InterpFilters[ MiRow - 1 ] [ MiCol ][ dir ]
    }

    if ( leftType == aboveType )
        ctx += leftType
    else if ( leftType == 3 )
        ctx += aboveType
    else if ( aboveType == 3 )
        ctx += leftType
    else
        ctx += 3
~~~~~

**motion_mode**: the cdf is given by TileMotionModeCdf[ MiSize ].

**mv_joint**: the cdf is given by TileMvJointCdf[ MvCtx ].

**mv_sign**: the cdf is given by TileMvSignCdf[ MvCtx ][ comp ].

**mv_class**: the cdf is given by TileMvClassCdf[ MvCtx ][ comp ].

**mv_class0_bit**: the cdf is given by TileMvClass0BitCdf[ MvCtx ][ comp ].

**mv_class0_fr**: the cdf is given by
TileMvClass0FrCdf[ MvCtx ][ comp ][ mv_class0_bit ].

**mv_class0_hp**: the cdf is given by TileMvClass0HpCdf[ MvCtx ][ comp ].

**mv_fr**: the cdf is given by TileMvFrCdf[ MvCtx ][ comp ].

**mv_hp**: the cdf is given by TileMvHpCdf[ MvCtx ][ comp ].

**mv_bit**: the cdf is given by TileMvBitCdf[ MvCtx ][ comp ][ i ].

**all_zero**: the cdf is given by TileTxbSkipCdf[ txSzCtx ][ ctx ], where ctx is computed as follows:

~~~~~ c
maxX4 = MiCols
maxY4 = MiRows
if ( plane > 0 ) {
    maxX4 = maxX4 >> subsampling_x
    maxY4 = maxY4 >> subsampling_y
}

x4 = x >> 2
y4 = y >> 2

w = Tx_Width[txSz]
h = Tx_Height[txSz]

w4 = w >> 2
h4 = h >> 2

bw = Block_Width[ MiSize ]
bh = Block_Height[ MiSize ]
mask = use_128x128_superblock ? 255 : 127

if ( plane > 0 ) {
    bw = bw >> subsampling_x
    bh = bh >> subsampling_y
    w = w >> subsampling_x
    h = h >> subsampling_y
}
if (plane == 0) {
    top = 0
    left = 0
    for (k = 0; k < w4; k++) {
        if ( x4 + k < maxX4 )
            top = Max( top, AboveLevelContext[ plane ][ x4 + k ] )
    }
    for (k = 0; k < h4; k++) {
        if ( y4 + k < maxY4 )
            left = Max( left, LeftLevelContext[ plane ][ ( y4 + k ) & mask ] )
    }
    top = Min( top, 255 )
    left = Min( left, 255 )
    if ( bw == w && bh == h ) {
        ctx = 0
    } else if ( top == 0 && left == 0 ) {
        ctx = 1
    } else if ( top == 0 || left == 0 ) {
        ctx = 2 + ( Max( top, left ) > 3 )
    } else if ( Max( top, left ) <= 3 ) {
        ctx = 4
    } else if ( Min( top, left ) <= 3 ) {
        ctx = 5
    } else {
        ctx = 6
    }
} else { 
    above = 0
    left = 0
    for( i = 0; i < w4; i++ ) {
        if ( x4 + i < maxX4 ) {
            above |= AboveLevelContext[ plane ][ x4 + i ]
            above |= AboveDcContext[ plane ][ x4 + i ]
        }
    }
    for( i = 0; i < h4; i++ ) {
        if ( y4 + i < maxY4 ) {
            left |= LeftLevelContext[ plane ][ ( y4 + i ) & mask ]
            left |= LeftDcContext[ plane ][ ( y4 + i ) & mask ]
        }
    }
    ctx = ( above != 0 ) + ( left != 0 )
    ctx += 7
    if ( bw > w || ( bw == w && bh > h ) ) 
        ctx += 3
}
~~~~~

**is_eob**: the cdf is given by TileEobFlagCdf[ txSzCtx ][ ptype ][ ctx ], where ctx is computed as follows:

~~~~~ c
txType = compute_tx_type( plane, txSz, startX, startY )
txClass = get_tx_class(txType)
ctx = eobPt - 1
if ( txType == V_DCT ||
     txType == V_ADST ||
     txType == V_FLIPADST ||
     txType == H_DCT ||
     txType == H_ADST ||
     txType == H_FLIPADST )
    ctx += 11
~~~~~

**eob_extra**: the cdf is given by TileEobExtraCdf[ txSzCtx ][ ptype ][ eobPt ].

**coeff_base**: the cdf is given by TileCoeffBaseCdf[ txSzCtx ][ ptype ][ ctx ], where ctx is computed as follows:

~~~~~ c
ctx = get_coeff_base_ctx(txSz, plane, startX, startY, scan[c], c, 0)
~~~~~

where get_coeff_base_ctx is defined as:

~~~~~ c
get_coeff_base_ctx( txSz, plane, blockX, blockY, pos, c, isEob ) {
    bwl = Tx_Width_Log2[ txSz ] + 2
    width = 1 << bwl
    height = Tx_Height[ txSz ]
    txType = compute_tx_type( txSz, plane, blockX, blockY )
    if (isEob) {
        if (c == 0) {
            return SIG_COEF_CONTEXTS - 4
        }
        if (c <= (height << bwl) / 8) {
            return SIG_COEF_CONTEXTS - 3
        }
        if (c <= (height << bwl) / 4) {
            return SIG_COEF_CONTEXTS - 2
        }
        return SIG_COEF_CONTEXTS - 1
    }
    row = pos >> bwl
    col = pos - (row << bwl)

    txClass = 0
    if ( txType == V_DCT ||
         txType == V_ADST ||
         txType == V_FLIPADST )
        txClass = 1
    else if ( txType == H_DCT ||
              txType == H_ADST ||
              txType == H_FLIPADST )
        txClass = 2
    
    if ( txClass > 0 )
        offset = SIG_COEF_CONTEXTS_2D
    } else {
        offset = 0
    }

    mag = 0
    for ( idx = 0; idx < SIG_REF_OFFSET_NUM; idx++ ) {
        refRow = row + Sig_Ref_Offset[ txClass ][ idx ][ 0 ]
        refCol = col + Sig_Ref_Offset[ txClass ][ idx ][ 1 ]
        if (refRow >= 0 &&
            refCol >= 0 &&
            refRow < height &&
            refCol < ( 1 << bwl ) ) {
            nbPos = ( refRow << bwl ) + refCol
            mag += Min( Abs( Dequant[ nbPos ] ), 3 )
        }
    }

    ctx = Min( ( mag + 1 ) >> 1, 4 )
    if ( txClass == 0 ) {
        if (row == 0 && col == 0) {
            return offset + 0
        } else if ( width < height && row < 2 ) {
            return offset + ctx + 11
        } else if ( height < width && col < 2 ) {
            return offset + ctx + 16
        } else if ( row + col < 2 ) {
            return offset + ctx + 1
        } else if ( row + col < 4 ) {
            return offset + 5 + ctx + 1
        }
        return offset + 21 + Min( ctx, 4 )
    } else {
        if ( txClass == 1 ) {
            if ( row == 0 ) {
                return offset + ctx
            } else if ( row < 2 ) {
                return offset + 5 + ctx
            }
            return offset + 10 + ctx
        } else {
            if ( col == 0 ) {
                return offset + ctx
            } else if ( col < 2 ) {
                return offset + 5 + ctx
            }
            return offset + 10 + ctx
        }
    }
}
~~~~~

**coeff_base_eob**: the cdf is given by TileCoeffBaseEobCdf[ txSzCtx ][ ptype ][ ctx ], where ctx is computed as follows:

~~~~~ c
ctx = get_coeff_base_ctx(txSz, plane, blocky, blockx, scan[c], c, 1) - SIG_COEF_CONTEXTS + SIG_COEF_CONTEXTS_EOB
~~~~~

where get_coeff_base_ctx() is as defined in the CDF selection for coeff_base.

**dc_sign**: the cdf is given by TileDcSignCdf[ ptype ][ ctx ], where ctx is computed as follows:

~~~~~ c
maxX4 = MiCols
maxY4 = MiRows
if ( plane > 0 ) {
    maxX4 = maxX4 >> subsampling_x
    maxY4 = maxY4 >> subsampling_y
}

w4 = Tx_Width[ txSz ] >> 2
h4 = Tx_Height[ txSz ] >> 2

x4 = x >> 2
y4 = y >> 2

dcSign = 0
for ( k = 0; k < w4; k++ ) {
    if ( x4 + k < maxX4 ) {
        sign = AboveDcContext[ plane ][ x4 + k ]
        if ( sign == 1 ) {
            dcSign--
        } else if ( sign == 2 ) {
            dcSign++
        }
    }
}
mask = use_128x128_superblock ? 255 : 127
for ( k = 0; k < h4; k++ ) {
    if ( y4 + k < maxY4 ) {
        sign = LeftDcContext[ plane ][ ( y4 + k ) & mask ]
        if ( sign == 1 ) {
            dcSign--
        } else if ( sign == 2 ) {
            dcSign++
        }
    }
}
if ( dcSign < 0 ) {
    ctx = 1
} else if ( dcSign > 0 ) {
    ctx = 2
} else {
    ctx = 0
}
~~~~~

**coeff_br**: the cdf is given by TileCoeffBrCdf[ txSzCtx ][ ptype ][ ctx ], where ctx is computed as follows:

~~~~~ c
bwl = Tx_Width_Log2[ txSz ] + 2
height = Tx_Height[ txSz ]
row = pos >> bwl
col = pos - (row << bwl)

nbMag[ 0 ] = 0
nbMag[ 1 ] = 0
nbMag[ 2 ] = 0
count = 0
for ( idx = 0; idx < BR_CONTEXT_POSITION_NUM; idx++ ) {
    refRow = row + Br_Ref_Offset[ idx ][ 0 ]
    refCol = col + Br_Ref_Offset[ idx ][ 1 ]
    if (refRow >= 0 &&
        refCol >= 0 &&
        refRow < height &&
        refCol < ( 1 << bwl ) ) {
        nbPos = ( refRow << bwl ) + refCol
        count += ( Abs( Dequant[ nbPos ] ) > NUM_BASE_LEVELS )
        if ( Br_Ref_Offset[ idx ][ 0 ] == 0 && Br_Ref_Offset[ idx ][ 1 ] == 1 )
            nbMag[ 0 ] = Dequant[ nbPos ]
        if ( Br_Ref_Offset[ idx ][ 0 ] == 1 && Br_Ref_Offset[ idx ][ 1 ] == 0 )
            nbMag[ 1 ] = Dequant[ nbPos ]
        if ( Br_Ref_Offset[ idx ][ 0 ] == 1 && Br_Ref_Offset[ idx ][ 1 ] == 1 )
            nbMag[ 2 ] = Dequant[ nbPos ]
    }
}

mag = 0
for ( idx = 0; idx < 3; idx++ ) {
    mag = Max( mag, nbMag[ idx ] )
}

if ( mag <= 1 ) {
    offset = 0
} else if ( mag <= 3 ) {
    offset = 1
} else if ( mag <= 5 ) {
    offset = 2
} else {
    offset = 3
}

v = Min( 3, count >> 1 )
v += offset * BR_TMP_OFFSET

if ( row == 0 && col == 0 ) { 
    ctx = v
} else if ( row == 0 ) { 
    ctx = 2 + v
} else if ( col == 0 ) { 
    ctx = 5 + v
}
ctx = 8 + v
~~~~~

**has_palette_y**: the cdf is given by
TilePaletteYModeCdf[ MiSize - BLOCK_8X8 ][ ctx ] where ctx is computed as
follows:

~~~~~ c
ctx = 0
if ( AvailU && PaletteSizes[ 0 ][ MiRow - 1 ][ MiCol ] > 0 )
    ctx += 1
if ( AvailL && PaletteSizes[ 0 ][ MiRow ][ MiCol - 1 ] > 0 )
    ctx += 1
~~~~~

**has_palette_uv**: the cdf is given by
TilePaletteUVModeCdf[ ctx ] where ctx is computed as
follows:

~~~~~ c
ctx = ( PaletteSizeY > 0 ) ? 1 : 0
~~~~~

**palette_size_y_minus_2**: the cdf is given by TilePaletteYSizeCdf[ MiSize -
BLOCK_8X8 ].

**palette_size_uv_minus_2**: the cdf is given by TilePaletteUVSizeCdf[ MiSize -
BLOCK_8X8 ].

**palette_color_idx_y**: the cdf depends on PaletteSizeY, as follows:

| PaletteSizeY | cdf |
|:------------:|:---:|
| 2            | TilePaletteSize2YColorCdf[ ctx ] |
| 3            | TilePaletteSize3YColorCdf[ ctx ] |
| 4            | TilePaletteSize4YColorCdf[ ctx ] |
| 5            | TilePaletteSize5YColorCdf[ ctx ] |
| 6            | TilePaletteSize6YColorCdf[ ctx ] |
| 7            | TilePaletteSize7YColorCdf[ ctx ] |
| 8            | TilePaletteSize8YColorCdf[ ctx ] |
{:.table .table-sm .table-bordered }

where ctx is computed as follows:

~~~~~ c
ctx = Palette_Color_Context[ ColorContextHash ]
~~~~~

**palette_color_idx_uv**: the cdf depends on PaletteSizeUV, as follows:

| PaletteSizeUV | cdf |
|:-------------:|:---:|
| 2             | TilePaletteSize2UVColorCdf[ ctx ] |
| 3             | TilePaletteSize3UVColorCdf[ ctx ] |
| 4             | TilePaletteSize4UVColorCdf[ ctx ] |
| 5             | TilePaletteSize5UVColorCdf[ ctx ] |
| 6             | TilePaletteSize6UVColorCdf[ ctx ] |
| 7             | TilePaletteSize7UVColorCdf[ ctx ] |
| 8             | TilePaletteSize8UVColorCdf[ ctx ] |
{:.table .table-sm .table-bordered }

where ctx is computed as follows:

~~~~~ c
ctx = Palette_Color_Context[ ColorContextHash ]
~~~~~

**delta_q_abs**: the cdf is given by TileDeltaQCdf.

**delta_lf_abs**: the cdf is derived as follows:

  * If delta_lf_multi is equal to 0, the cdf is given by TileDeltaLFCdf.
  
  * Otherwise (delta_lf_multi is equal to 1), the cdf is given by TileDeltaLFMultiCdf[ i ].

**intra_tx_type**: the cdf depends on the variable set, as follows:

| set            | cdf |
|:--------------:|:---:|
| TX_SET_INTRA_1 | TileIntraTxTypeSet1Cdf[ Tx_Size_Sqr[ txSz ] ][ YMode ]
| TX_SET_INTRA_2 | TileIntraTxTypeSet2Cdf[ Tx_Size_Sqr[ txSz ] ][ YMode ]
{:.table .table-sm .table-bordered }

**inter_tx_type**: the cdf depends on the variable set, as follows:

| set            | cdf |
|:--------------:|:---:|
| TX_SET_INTER_1 | TileInterTxTypeSet1Cdf[ Tx_Size_Sqr[ txSz ] ]
| TX_SET_INTER_2 | TileInterTxTypeSet2Cdf[ Tx_Size_Sqr[ txSz ] ]
| TX_SET_INTER_3 | TileInterTxTypeSet3Cdf[ Tx_Size_Sqr[ txSz ] ]
{:.table .table-sm .table-bordered }

**comp_ref_type**: The cdf is given by TileCompRefTypeCdf[ ctx ], where ctx is computed as follows:

~~~~~ c
above0 = AboveRefFrame[ 0 ]
above1 = AboveRefFrame[ 1 ]
left0 = LeftRefFrame[ 0 ]
left1 = LeftRefFrame[ 1 ]
aboveCompInter = AvailU && !AboveIntra && !AboveSingle
leftCompInter = AvailL && !LeftIntra && !LeftSingle
aboveUniComp = aboveCompInter && is_samedir_ref_pair(above0, above1)
leftUniComp = leftCompInter && is_samedir_ref_pair(left0, left1)

if (AvailU && !AboveIntra && AvailL && !LeftIntra) {
    samedir = is_samedir_ref_pair(above0, left0)

    if (!aboveCompInter && !leftCompInter) {
        ctx = 1 + 2 * samedir
    } else if (!aboveCompInter) {
        if (!leftUniComp)
            ctx = 1
        else
            ctx = 3 + samedir
    } else if (!leftCompInter) {
        if (!aboveUniComp)
            ctx = 1
        else
            ctx = 3 + samedir
    } else {
        if (!aboveUniComp && !leftUniComp)
            ctx = 0
        else if (!aboveUniComp || !leftUniComp)
            ctx = 2
        else
            ctx = 3 + ((above0 == BWDREF_FRAME) == (left0 == BWDREF_FRAME))
    }
} else if (AvailU && AvailL) {
    if (aboveCompInter)
        ctx = 1 + 2 * aboveUniComp
    else if (leftCompInter)
        ctx = 1 + 2 * leftUniComp
    else
        ctx = 2
} else if (aboveCompInter) {
    ctx = 4 * aboveUniComp
} else if (leftCompInter) {
    ctx = 4 * leftUniComp
} else {
    ctx = 2
}
~~~~~

where is_samedir_ref_pair is defined as:

~~~~~ c
is_samedir_ref_pair(ref0, ref1) {
  if (ref0 <= INTRA_FRAME || ref1 <= INTRA_FRAME)
    return 0

  return (ref0 >= BWDREF_FRAME) == (ref1 >= BWDREF_FRAME)
}
~~~~~

**uni_comp_ref**: The cdf is given by TileUniCompRefCdf[ ctx ][ 0 ], where ctx is computed as follows:

~~~~~ c
fwdCount = count_refs( LAST_FRAME )
fwdCount += count_refs( LAST2_FRAME )
fwdCount += count_refs( LAST3_FRAME )
fwdCount += count_refs( GOLDEN_FRAME )
bwdCount = count_refs( BWDREF_FRAME )
bwdCount += count_refs( ALTREF2_FRAME )
bwdCount += count_refs( ALTREF_FRAME )
ctx = ref_count_ctx( fwdCount, bwdCount )
~~~~~

where count_refs and ref_count_ctx are the same as given in the CDF selection process for comp_bwdref.

**uni_comp_ref_p1**: The cdf is given by TileUniCompRefCdf[ ctx ][ 1 ], where ctx is computed as follows:

~~~~~ c
last2Count = count_refs( LAST2_FRAME )
last3GoldCount = count_refs( LAST3_FRAME ) + count_refs( GOLDEN_FRAME )
ctx = ref_count_ctx( last2Count, last3GoldCount )
~~~~~

where count_refs and ref_count_ctx are the same as given in the CDF selection process for comp_bwdref.

**uni_comp_ref_p2**: The cdf is given by TileUniCompRefCdf[ ctx ][ 2 ], where ctx is computed as follows:

~~~~~ c
last3Count = count_refs( LAST3_FRAME )
goldCount = count_refs( GOLDEN_FRAME )
ctx = ref_count_ctx( last3Count, goldCount )
~~~~~

where count_refs and ref_count_ctx are the same as given in the CDF selection process for comp_bwdref.

**compound_type**: The cdf is given by TileCompoundTypeCdf[ MiSize ].

**interintra**: The cdf is given by TileInterIntraCdf[ ctx ], where ctx is computed as follows:

~~~~~ c
ctx = Size_Group[ MiSize ]
~~~~~

**interintra_mode**: The cdf is given by TileInterIntraModeCdf[ ctx ], where ctx is computed as follows:

~~~~~ c
ctx = Size_Group[ MiSize ]
~~~~~

**wedge_interintra**: The cdf is given by TileWedgeInterIntraCdf[ MiSize ].

**use_obmc**: The cdf is given by TileUseObmcCdf[ MiSize ].

**cfl_alpha_signs**: The cdf is given by TileCflSignCdf.

**cfl_alpha_u**: The cdf is given by TileCflAlphaCdf[ ctx ] where ctx is computed as follows:

~~~~~ c
ctx = (signU - 1) * 3 + signV
~~~~~

**Note:** The variable ctx produced by this calculation will be equal to cfl_alpha_signs - 2.
{:.alert .alert-info }

**cfl_alpha_v**: The cdf is given by TileCflAlphaCdf[ ctx ] where ctx is computed as follows:

~~~~~ c
ctx = (signV - 1) * 3 + signU
~~~~~

**use_wiener**: The cdf is given by TileUseWienerCdf.

**use_sgrproj**: The cdf is given by TileUseSgrprojCdf.

**restoration_type**: The cdf is given by TileRestorationTypeCdf.
  
