## Decoding Process


### General

Decoders shall produce output frames that are identical in all respects and have the same output order as
those produced by the decoding process specified herein.

The input to this process is a sequence of coded frames.

The output from this process is a sequence of decoded frames.

For each coded frame in turn the decoding process operates as follows:

  1. The syntax elements for the coded frame are extracted as specified in
     sections 6 and 7. The syntax tables include function calls indicating
     when the block decode processes are triggered.

  2. If loop_filter_level is not equal to 0, the loop filter process as
     specified in [section 8.9][] is invoked once the coded frame has been decoded.

  3. If all of the following conditions are true, PrevSegmentIds[ row ][ col ]
     is set equal to SegmentIds[ row ][ col ] for row = 0..MiRows-1, for
     col = 0..MiCols-1:

     * show_existing_frame is equal to 0,

     * segmentation_enabled is equal to 1,

     * segmentation_update_map is equal to 1.

  4. The output process as specified in [section 8.10][] is invoked.

  5. The reference frame update process as specified in [section 8.11][] is
     invoked.


### Frame Order Constraints

This section describes additional constraints on a bitstream that result from
the choice of frame types.

If a sequence starts with a key frame, then the additional constraints are
automatically satisfied.

Otherwise, the sequence can start with a number of non key frames (i.e. inter
frames and intra only frames) and extra care has to be taken to ensure that
the decoding process is well defined. It is a requirement of bitstream
conformance that the following applies:

  * When load_probs( ctx ) is invoked, this must load an initialized set of
    probabilities, i.e. there must have been an earlier invocation of
    save_probs( ctx ).

  * When ref_frame_idx[ i ] is decoded, it must identify an initialized
    reference frame, i.e. there must have been an earlier decoded frame which
    had (refresh_frame_flags \>\> ref_frame_idx[ i ])&1 equal to 1.

**Note:** This constraint means that the first coded frame cannot be an inter
frame.


### Clear Counts Process

This process is triggered when the function clear_counts is invoked during the
syntax decode of the frame described in [section 6.1][].

The following arrays store the number of times each value of a particular
syntax element has been decoded in a particular context.

~~~~~ c
counts_inter_mode[INTER_MODE_CONTEXTS][INTER_MODES]
counts_is_inter[IS_INTER_CONTEXTS][2]
counts_comp_mode[COMP_MODE_CONTEXTS][2]
counts_single_ref[REF_CONTEXTS][2][2]
counts_comp_ref[REF_CONTEXTS][2]
counts_skip[SKIP_CONTEXTS][2]
counts_mv_sign[2][2]
counts_mv_class[2][MV_CLASSES]
counts_mv_class0_bit[2][CLASS0_SIZE]
counts_mv_class0_hp[2][2]
counts_mv_bits[2][MV_OFFSET_BITS][2]
counts_mv_hp[2][2]
counts_seg_id_predicted[ 3 ][ 2 ]
~~~~~

The numbers in square brackets define the size of each dimension of the array.

When the clear counts process is invoked, all of these counts are set equal to
0.

This process also creates arrays to accumulate the CDF values at the end of each tile.
An array of the same size is made of each of the CDF arrays mentioned in the semantics for setup_past_independence.
The name of the new array is the name of the CDF array prefixed with "Sum".  This process produces the following arrays:

  * SumIntraFrameYModeCdf
  
  * SumYModeCdf
  
  * SumUVModeCdf
  
  * SumPartitionCdf

  * SumSegmentIdCdf

  * SumTx8x8Cdf

  * SumTx16x16Cdf

  * SumTx32x32Cdf

  * SumInterpFilterCdf
  
  * SumNewMvCdf
  
  * SumZeroMvCdf
  
  * SumRefMvCdf
  
  * SumCompoundModeCdf
  
  * SumDrlModeCdf

  * SumMvJointCdf

  * SumMvClassCdf

  * SumMvFrCdf

  * SumMvClass0FrCdf

  * SumTailTokenCdf

  * SumAcHeadTokenCdf

  * SumDcHeadTokenCdf

  * SumPaletteYSizeCdf

  * SumPaletteUVSizeCdf

  * SumPaletteSize2YColorCdf

  * SumPaletteSize2UVColorCdf

  * SumPaletteSize3YColorCdf

  * SumPaletteSize3UVColorCdf

  * SumPaletteSize4YColorCdf

  * SumPaletteSize4UVColorCdf

  * SumPaletteSize5YColorCdf

  * SumPaletteSize5UVColorCdf

  * SumPaletteSize6YColorCdf

  * SumPaletteSize6UVColorCdf

  * SumPaletteSize7YColorCdf

  * SumPaletteSize7UVColorCdf

  * SumPaletteSize8YColorCdf

  * SumPaletteSize8UVColorCdf

  * SumDeltaQCdf

  * SumDeltaLFCdf
  
  * SumIntraTxTypeSet1Cdf
  
  * SumIntraTxTypeSet2Cdf
  
  * SumInterTxTypeSet1Cdf
  
  * SumInterTxTypeSet2Cdf
  
  * SumInterTxTypeSet3Cdf

When the clear counts process is invoked, every element of each of these arrays is set equal to 0.

### Probability Adaptation Process

This section defines processes used to perform backward updates of
probabilities based on the observed frequencies of different syntax elements.

These processes are triggered at points defined by function calls in the
refresh probs syntax table in [section 6.1.2][].

The processes make use of the functions merge_prob and merge_probs that are
specified next.


#### Merge Prob Process

The inputs to this process are:

  * a variable preProb specifying the original probability for a boolean,

  * variables ct0 and ct1 specifying the number of times the boolean was
    decoded as 0 and 1,

  * a variable countSat indicating how many times the boolean needs to be
    decoded for the maximum adaption to apply,

  * a variable maxUpdateFactor specifying the maximum amount the probability
    can be adjusted.

The output is a variable outProb containing the updated probability.
The variable den representing the total times this boolean has been decoded is set equal to ct0 + ct1.

The variable prob estimating the probability that the boolean is decoded as a 0 is set equal to (den == 0) ?
128 : Clip3( 1, 255, (ct0 * 256 + (den \>\> 1)) / den ).
The variable count is set equal to Min( ct0 + ct1, countSat ).
The variable factor is set equal to maxUpdateFactor * count / countSat.
The return variable outProb is set equal to Round2( preProb * (256 - factor) + prob * factor, 8 ).

#### Merge Probs Process

The inputs to this process are:

  * an array tree specifying the decode tree for a syntax element,

  * a variable i specifying the current location in the decode tree,

  * an array probs specifying the original probabilities for decoding the
    syntax element,

  * an array counts containing the number of times each value for the syntax
    element was decoded,

  * a variable countSat indicating how many times the boolean needs to be
    decoded for the maximum adaption to apply,

  * a variable maxUpdateFactor specifying the maximum amount the probability
    can be adjusted.

The outputs of this process are adjustments made to the input array named probs, and a return value
containing the total number of times this boolean was decoded.
The process is specified as follows:

~~~~~ c
merge_probs( tree, i, probs, counts, countSat, maxUpdateFactor ) {
    s = tree[ i ]
    leftCount = (s <= 0) ? counts[ -s ] :
        merge_probs( tree, s, probs, counts, countSat, maxUpdateFactor )
    r = tree[ i + 1 ]
    rightCount = (r <= 0) ? counts[ -r ] :
        merge_probs( tree, r, probs, counts, countSat, maxUpdateFactor )
    probs[ i >> 1 ] =
        merge_prob( probs[ i >> 1 ], leftCount, rightCount, countSat, maxUpdateFactor )
    return leftCount + rightCount
}
~~~~~

#### Probability Adaption Process

This process is triggered when the function adapt_probs is called from
the refresh probs syntax table.

The probabilities are updated as follows:

~~~~~ c
for ( i = 0; i < IS_INTER_CONTEXTS; i++ )
    IsInterProbs[ i ] = adapt_prob( IsInterProbs[ i ], counts_is_inter[ i ] )
for ( i = 0; i < COMP_MODE_CONTEXTS; i++ )
    CompModeProbs[ i ] = adapt_prob( CompModeProbs[ i ], counts_comp_mode[ i ] )
for ( i = 0; i < REF_CONTEXTS; i++ )
    CompRefProbs[ i ] = adapt_prob( CompRefProbs[ i ], counts_comp_ref[ i ] )
for ( i = 0; i < REF_CONTEXTS; i++ )
    for ( j = 0; j < 2; j++ )
        SingleRefProbs[ i ][ j ] = adapt_prob( SingleRefProbs[ i ][ j ], counts_single_ref[ i ][ j ] )
for ( i = 0; i < INTER_MODE_CONTEXTS; i++ )
    adapt_probs( inter_mode_tree, InterModeProbs[ i ], counts_inter_mode[ i ] )
for ( i = 0; i < SKIP_CONTEXTS; i++ )
    SkipProbs[ i ] = adapt_prob( SkipProbs[ i ], counts_skip[ i ] )
for ( i = 0; i < 2; i++ ) {
    MVSignProbs[ i ] = adapt_prob( MVSignProbs[ i ], counts_mv_sign[ i ] )
    MVClass0BitProbs[ i ] = adapt_prob( MVClass0BitProbs[ i ], counts_mv_class0_bit[ i ] )
    for ( j = 0; j < MV_OFFSET_BITS; j++ )
        MVBitProbs[ i ][ j ] = adapt_prob( MVBitProbs[ i ][ j ], counts_mv_bits[ i ][ j ] )
    if ( allow_high_precision_mv ) {
        MVClass0HpProbs[ i ] = adapt_prob( MVClass0HpProbs[ i ], counts_mv_class0_hp[ i ] )
        MVHpProbs[ i ] = adapt_prob( MVHpProbs[ i ], counts_mv_hp[ i ] )
    }
    if ( segmentation_temporal_update ) {
        for ( i = 0; i < 3; i++ )
            merge_probs( SegmentationPredProbs[ i ], counts_seg_id_predicted[ i ] )
    }
}
~~~~~

where adapt_probs is specified as:

~~~~~ c
adapt_probs( tree, probs, counts ) {
    merge_probs( tree, 0, probs, counts, COUNT_SAT, MAX_UPDATE_FACTOR )
}
~~~~~

and adapt_prob is specified as:

~~~~~ c
adapt_prob( prob, counts ) {
    return merge_prob( prob, counts[ 0 ], counts[ 1 ], COUNT_SAT, MAX_UPDATE_FACTOR )
}
~~~~~

#### CDF Averaging Process

This process is triggered when the function average_cdf is called from
the refresh probs syntax table.

The frame CDF arrays are set equal to the average of the tile CDF arrays as follows (in this code, the operations apply to each element of the arrays in turn):

~~~~~ c
IntraFrameYModeCdf = SumIntraFrameYModeCdf / NumTiles
YModeCdf = SumYModeCdf / NumTiles
UVModeCdf = SumUVModeCdf / NumTiles
PartitionCdf = SumPartitionCdf / NumTiles
SegmentIdCdf = SumSegmentIdCdf / NumTiles
Tx8x8Cdf = SumTx8x8Cdf / NumTiles
Tx16x16Cdf = SumTx16x16Cdf / NumTiles
Tx32x32Cdf = SumTx32x32Cdf / NumTiles
InterpFilterCdf = SumInterpFilterCdf / NumTiles
NewMvCdf = SumNewMvCdf / NumTiles
ZeroMvCdf = SumZeroMvCdf / NumTiles
RefMvCdf = SumRefMvCdf / NumTiles
CompoundModeCdf = SumCompoundModeCdf / NumTiles
DrlModeCdf = SumDrlModeCdf / NumTiles
MvJointCdf = SumMvJointCdf / NumTiles
MvClassCdf = SumMvClassCdf / NumTiles
MvFrCdf = SumMvFrCdf / NumTiles
MvClass0FrCdf = SumMvClass0FrCdf / NumTiles
TailTokenCdf = SumTailTokenCdf / NumTiles
AcHeadTokenCdf = SumAcHeadTokenCdf / NumTiles
DcHeadTokenCdf = SumDcHeadTokenCdf / NumTiles
PaletteYSizeCdf = SumPaletteYSizeCdf / NumTiles
PaletteUVSizeCdf = SumPaletteUVSizeCdf / NumTiles
PaletteSize2YColorCdf = SumPaletteSize2YColorCdf / NumTiles
PaletteSize2UVColorCdf = SumPaletteSize2UVColorCdf / NumTiles
PaletteSize3YColorCdf = SumPaletteSize3YColorCdf / NumTiles
PaletteSize3UVColorCdf = SumPaletteSize3UVColorCdf / NumTiles
PaletteSize4YColorCdf = SumPaletteSize4YColorCdf / NumTiles
PaletteSize4UVColorCdf = SumPaletteSize4UVColorCdf / NumTiles
PaletteSize5YColorCdf = SumPaletteSize5YColorCdf / NumTiles
PaletteSize5UVColorCdf = SumPaletteSize5UVColorCdf / NumTiles
PaletteSize6YColorCdf = SumPaletteSize6YColorCdf / NumTiles
PaletteSize6UVColorCdf = SumPaletteSize6UVColorCdf / NumTiles
PaletteSize7YColorCdf = SumPaletteSize7YColorCdf / NumTiles
PaletteSize7UVColorCdf = SumPaletteSize7UVColorCdf / NumTiles
PaletteSize8YColorCdf = SumPaletteSize8YColorCdf / NumTiles
PaletteSize8UVColorCdf = SumPaletteSize8UVColorCdf / NumTiles
DeltaQCdf = SumDeltaQCdf / NumTiles
DeltaLFCdf = SumDeltaLFCdf / NumTiles
IntraTxTypeSet1Cdf = SumIntraTxTypeSet1Cdf / NumTiles
IntraTxTypeSet2Cdf = SumIntraTxTypeSet2Cdf / NumTiles
InterTxTypeSet1Cdf = SumInterTxTypeSet1Cdf / NumTiles
InterTxTypeSet2Cdf = SumInterTxTypeSet2Cdf / NumTiles
InterTxTypeSet3Cdf = SumInterTxTypeSet3Cdf / NumTiles
~~~~~


### Motion Vector Prediction Processes

The following sections define the processes used for predicting the motion vectors.

These processes are triggered at points defined by function calls to find_mv_list, compound_context, and find_mv_stack
in the inter block mode info syntax described in [section 6.4.18][].

#### Find MV List Process

The input to this process is a variable refList specifying which set of motion vectors to predict.

This process is triggered by a function call to find_mv_list and constructs an array RefListMv[ refList ] containing 2 motion vector candidates.

The array RefListMv[ refList ] is first initialized to have both entries equal to ZeroMv[ refList ].

The variable NumMvFound (repesenting the number of candidates found during this process) is set equal to 0.

The variable bw8 (representing the width of the block in units of 8 pixels) is set equal to num_8x8_blocks_wide_lookup[ MiSize ].

The variable bh8 (representing the height of the block in units of 8 pixels) is set equal to num_8x8_blocks_high_lookup[ MiSize ].

An array offMvs8 (representing offsets in units of 8 pixels to search locations) is defined as:

~~~~~ c
offMvs8[ 9 ][ 2 ] = {
  {bh8 - 1, -1},
  {-1, bw8 - 1},
  {-1, (bw8 - 1) >> 1},
  { (bh8 - 1) >> 1, -1},
  {-1, -1},
  {-1, bw8},
  {bh8, -1},
  {-1, -3},
  {bh8 - 1, -3}
}
~~~~~

The motion vector candidates are constructed by the following ordered steps :

1. For i = 0..8 the spatial motion vector candidate process in [section 8.5.1.1][] is invoked with mv8 equal to offMvs8[ i ], same equal to 1, and refList as inputs.

2. If UsePrevFrameMvs is equal to 1, the temporal motion vector candidate process is invoked with same equal to 1 and refList as inputs.

3. For i = 0..8 the spatial motion vector candidate process in [section 8.5.1.1][] is invoked with mv8 equal to offMvs8[ i ], same equal to 0, and refList as inputs.

4. If UsePrevFrameMvs is equal to 1, the temporal motion vector candidate process is invoked with same equal to 0 and refList as inputs.

##### Spatial Motion Vector Candidate Process

The inputs to this process are:

  * a 2 element array mv8 specifying the offset in 8 pixel units to the candidate location,
  
  * a variable same specifying whether to only look for candidates with matching reference frame,
  
  * a variable refList specifying which set of motion vectors to predict.
  
This process examines the motion vector at a position in the current frame and adds it to the candidate list if certain conditions are met.
  
The candidate location in 4x4 pixel units is derived as:

  * the variable mvRow is set equal to MiRow + 2 * mv8[0]
  
  * the variable mvCol is set equal to MiCol + 2 * mv8[1]
  
This process terminates immediately if any of the following are true:

  * the function is_inside( mvRow, mvCol ) is equal to 0 (this tests if the candidate is in a different tile from which we are not allowed to retrieve motion vectors)
  
  * (MiRow % MI_BLOCK_SIZE) +  2 * mv8[0] is greater than or equal to MI_BLOCK_SIZE (this tests if the candidate comes from the superblock row below)
  
  * (MiCol % MI_BLOCK_SIZE) +  2 * mv8[1] is greater than or equal to MI_BLOCK_SIZE (this tests if the candidate comes from the superblock column to the right)
  
  * RefFrames[ mvRow ][ mvCol ][ 0 ] has not yet been written for this frame (this tests if the candidate location has not been decoded yet)
  
For list=0..1 the following ordered steps apply:

1. The variable candRef is set equal to RefFrames[ mvRow ][ mvCol ][ list ]
2. The 2 element array candMv is set to a copy of Mvs[ mvRow ][ mvCol ][ list ]
3. Invoke the candidate add process in [section 8.5.1.3][] with candRef, candMv, same, refList as inputs.

##### Temporal Motion Vector Candidate Process

The inputs to this process are:
  
  * a variable same specifying whether to only look for candidates with matching reference frame,
  
  * a variable refList specifying which set of motion vectors to predict.
  
This process examines the motion vector at a position in a previous frame and adds it to the candidate list if certain conditions are met.

The variable miBw (representing the width of the block in 4x4 pixels) is set equal to num_4x4_blocks_wide_lookup[MiSize].

The variable miBh (representing the height of the block in 4x4 pixels) is set equal to num_4x4_blocks_high_lookup[MiSize]. 

The candidate location (representing the bottom right of the current block cropped to the frame size) is constructed as follows:

  * prevCol is set equal to 1 \| Min( MiColEnd - 1, (MiCol + miBw - 1) )
  * prevRow is set equal to 1 \| Min( MiRowEnd - 1, (MiRow + miBh - 1) )

**Note:** The bitwise OR with 1 allows implementations to reduce memory use by saving fewer locations in PrevMvs.

For list=0..1 the following ordered steps apply:

1. The variable candRef is set equal to PrevRefFrames[ prevRow ][ prevCol ][ list ]
2. The 2 element array candMv is set to a copy of PrevMvs[ prevRow ][ prevCol ][ list ]
3. Invoke the candidate add process in [section 8.5.1.3][] with candRef, candMv, same, refList as inputs.

##### Candidate Add Process

The inputs to this process are:

  * a 2 element array candMv specifying the candidate motion vector,
  
  * a variable candRef specifying the candidate reference frame,
  
  * a variable same specifying whether to only look for candidates with matching reference frame,
  
  * a variable refList specifying which set of motion vectors to predict.
  
This process terminates immediately if same is equal to 1 and candRef is not equal to RefFrame[refList].

This process terminates immediately if NumMvFound is equal to 2 (this means we have already found enough motion vector candidates).

If ref_frame_sign_bias[ candRef ] is not equal to ref_frame_sign_bias[ RefFrame[refList] ], then the candidate motion vector is inverted as follows:

  * candMv[ 0 ] *= -1
  * candMv[ 1 ] *= -1
  
The variable bw (representing the width of the block rounded up to be a multiple of 8) is set equal to 8 * num_8x8_blocks_wide_lookup[ MiSize ].

The variable bh (representing the height of the block rounded up to be a multiple of 8) is set equal to 8 * num_8x8_blocks_high_lookup[ MiSize ]. 

The motion vector is clamped to a legal range as follows:

  * candMv[ 0 ] is set equal to clamp_mv_row( candMv[ 0 ], MV_BORDER + bh * 8)
  * candMv[ 1 ] is set equal to clamp_mv_col( candMv[ 1 ], MV_BORDER + bw * 8)
   
If NumMvFound is equal to 0 or candMv is not equal to RefListMv[ refList ][ 0 ], then the following ordered steps apply:

  1. RefListMv[ refList ][ NumMvFound ] is set equal to candMv
  2. NumMvFound is set equal to NumMvFound + 1
  
#### Compound Context Process

This process is triggered by a function call to compound_context and constructs a variable CompoundModeContext that is used for decoding the inter_mode syntax element.

The variable bw4 (representing the width of the block in units of 4 pixels) is set equal to num_4x4_blocks_wide_lookup[ MiSize ].

The variable bh4 (representing the height of the block in units of 4 pixels) is set equal to num_4x4_blocks_high_lookup[ MiSize ].

An array offMvs4 (representing offsets in units of 4 pixels to search locations) is defined as:

~~~~~ c
offMvs4[ 2 ][ 2 ] = {
  {bh4 - 1, -1},
  {-1, bw4 - 1}
}
~~~~~

The CompoundModeContext is constructed by testing the mode of the neighbouring blocks at the top-right and bottom-left corners as follows:

~~~~~ c
counter = 0
for (i = 0; i < 2; i++) {
    mvRow = MiRow + offMvs4[i][0]
    mvCol = MiCol + offMvs4[i][1]
    if (is_inside(mvcol, mvrow)) {
      counter += mode_2_counter[YModes[ mvRow ][ mvCol ]
    }
  }
  CompoundModeContext = counter_to_context[counter]
~~~~~

The mode_2_counter table is defined as:

~~~~~ c
mode_2_counter[ MB_MODE_COUNT ] = {
9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 3, 1,
0, 0, 1, 1, 1, 1, 3, 1
}
~~~~~

The counter_to_context table is defined as:

~~~~~ c
counter_to_context[ 19 ] = {
    BOTH_PREDICTED,
    NEW_PLUS_NON_INTRA,
    BOTH_NEW,
    ZERO_PLUS_PREDICTED,
    NEW_PLUS_NON_INTRA,
    INVALID_CASE,
    BOTH_ZERO,
    INVALID_CASE,
    INVALID_CASE,
    INTRA_PLUS_NON_INTRA,
    INTRA_PLUS_NON_INTRA,
    INVALID_CASE,
    INTRA_PLUS_NON_INTRA,
    INVALID_CASE,
    INVALID_CASE,
    INVALID_CASE,
    INVALID_CASE,
    INVALID_CASE,
    BOTH_INTRA
}
~~~~~
  
#### Find MV Stack Process

This process is triggered by a function call to find_mv_stack.

The input to this process is a variable refList specifying which set of motion vectors to predict, or -1 to signal compound prediction.

This process constructs an array RefStackMv containing motion vector candidates.
This is similar to the RefListMv list of motion vectors, except that the stack only contains candidates that exactly match
in their use of reference frames, while RefListMv can also include partial matches.  For single prediction, the candidates in
the stack are used to overwrite entries in RefListMv.

The process also prepares the value of the contexts used
when decoding inter prediction syntax elements.

The variable bw specifying the width of the block in 4x4 pixels is set equal to num_4x4_blocks_wide_lookup[ MiSize ].

The variable bh specifying the height of the block in 4x4 pixels is set equal to num_4x4_blocks_high_lookup[ MiSize ].

The following ordered steps apply:

1. The variable NumMvFound (representing the number of motion vector candidates in RefStackMv) is set equal to 0.

1. The variable NumNewMvFound (representing the number of candidates in RefStackMv that used NEWMV encoding) is set equal to 0.

2. The scan row process in [section 8.5.3.1][] is invoked with deltaRow equal to -1 and refList as inputs. 

3. The scan col process in [section 8.5.3.2][] is invoked with deltaCol equal to -1 and refList as inputs. 

4. The scan point process in [section 8.5.3.3][] is invoked with deltaRow equal to -1, deltaCol equal to bw, and refList as inputs. 

5. The variable numNearest (representing the number of motion vectors found in the immediate neighbourhood) is set equal to NumMvFound

5. The variable numNew (representing the number of NEWMV candidates found in the immediate neighbourhood) is set equal to NumNewMvFound

6. If numNearest is greater than 0, WeightStack[ idx ] is incremented by REF_CAT_LEVEL for idx = 0..(numNearest-1).

1. The variable ZeroMvContext is set equal to 0.

7. The variable FoundPrevMatch (which will be set if we find any temporal candidates with matching reference frames) is set to 0.

5. If refList is greater than or equal to 0 and UsePrevFrameMvs is equal to 1,
the temporal scan process in [section 8.5.3.4][] is invoked with refList as input (the temporal scan process affects ZeroMvContext and FoundPrevMatch).

8. If FoundPrevMatch is equal to 0, ZeroMvContext is set equal to 1.

6. The scan point process in [section 8.5.3.3][] is invoked with deltaRow equal to -1, deltaCol equal to -1, and refList as inputs. 

7. The scan row process in [section 8.5.3.1][] is invoked with deltaRow equal to -3 and refList as inputs. 

8. The scan col process in [section 8.5.3.2][] is invoked with deltaCol equal to -3 and refList as inputs. 

9. The scan row process in [section 8.5.3.1][] is invoked with deltaRow equal to -5 and refList as inputs. 

10. The scan col process in [section 8.5.3.2][] is invoked with deltaCol equal to -5 and refList as inputs. 

11. The scan col process in [section 8.5.3.2][] is invoked with deltaCol equal to -7 and refList as inputs.

12. The sorting process in [section 8.5.3.9][] is invoked with start equal to 0 and end equal to numNearest.

13. The sorting process in [section 8.5.3.9][] is invoked with start equal to numNearest and end equal to NumMvFound.

13. The context and clamping process in [section 8.5.3.10][] is invoked with refList, numNearest, and numNew as input.

##### Scan Row Process

The inputs to this process are:
  
  * a variable deltaRow specifying (in units of 4x4 pixels) how far above to look for motion vectors,
  
  * a variable refList specifying which set of motion vectors to predict, or -1 to signal compound prediction.

The variable bw4 specifying the width of the block in 4x4 pixels is set equal to num_4x4_blocks_wide_lookup[ MiSize ].

The variable deltaCol is set equal to 0.

The variable useStep16 is set equal to (bw4 >= 16).  

**Note:** useStep16 is equal to 1 when the block is 64 pixels wide.  This means only 4 locations will be searched in this case.  However, a 32 pixel wide block may still search 8 locations.

If Abs(deltaRow) is greater than 1, the offset is adjusted as follows:

~~~~~ c
deltaRow += MiRow & 1
deltaCol = 1 - (MiCol & 1)
~~~~~

**Note:** These adjustments reduce the number of motion vectors that need to be kept in memory

A series of motion vector locations is scanned as follows:

~~~~~ c
i = 0
while ( i < bw4 && NumMvFound < 16) {
    mvRow = miRow + deltaRow
    mvCol = miCol + deltaCol + i
    if (!is_inside(mvRow,mvCol))
        break
    len = Min(bw4, num_4x4_blocks_wide_lookup[ MiSizes[ mvRow ][ mvCol ] ])
    if (Abs(deltaRow) > 1)
        len = Max(2, len)
    if (useStep16)
        len = Max(4, len)
    add_ref_mv_candidate( mvRow, mvCol, refList, len, 0)
    i += len
}
~~~~~

where the call to add_ref_mv_candidate invokes the process in [section 8.5.3.5][].

##### Scan Col Process

The inputs to this process are:
  
  * a variable deltaCol specifying (in units of 4x4 pixels) how far left to look for motion vectors,
  
  * a variable refList specifying which set of motion vectors to predict, or -1 to signal compound prediction.

The variable bh4 specifying the height of the block in 4x4 pixels is set equal to num_4x4_blocks_high_lookup[ MiSize ].

The variable deltaRow is set equal to 0.

The variable useStep16 is set equal to (bh4 >= 16).

If Abs(deltaCol) is greater than 1, the offset is adjusted as follows:

~~~~~ c
deltaRow = 1 - (MiRow & 1)
deltaCol += MiCol & 1
~~~~~

A series of motion vector locations is scanned as follows:

~~~~~ c
i = 0
while ( i < bh4 && NumMvFound < 16) {
    mvRow = miRow + deltaRow + i
    mvCol = miCol + deltaCol
    if (!is_inside(mvRow,mvCol))
        break
    len = Min(bh4, num_4x4_blocks_high_lookup[ MiSizes[ mvRow ][ mvCol ] ])
    if (Abs(deltaCol) > 1)
        len = Max(2, len)
    if (useStep16)
        len = Max(4, len)
    add_ref_mv_candidate( mvRow, mvCol, refList, len, 0)
    i += len
}
~~~~~

where the call to add_ref_mv_candidate invokes the process in [section 8.5.3.5][].

##### Scan Point Process

The inputs to this process are:
  
  * a variable deltaRow specifying (in units of 4x4 pixels) how far above to look for a motion vector,
  
  * a variable deltaCol specifying (in units of 4x4 pixels) how far left to look for a motion vector,
 
  * a variable refList specifying which set of motion vectors to predict, or -1 to signal compound prediction.
  
The variable mvRow is set equal to MiRow + deltaRow.

The variable mvCol is set equal to MiCol + deltaCol.

The variable len is set equal to 8.

The variable usePrev is set equal to 0.

If is_inside( mvRow, mvCol ) is equal to 1
and RefFrames[ mvRow ][ mvCol ][ 0 ] has been written for this frame (this checks that the candidate location has been decoded),
the add reference motion vector process in [section 8.5.3.5][] is invoked with mvRow, mvCol, refList, len, and usePrev as inputs.

##### Temporal Scan Process

The input to this process is a variable refList specifying which set of motion vectors to predict.

This process scans the motion vectors in a previous frame looking for candidates which use the same reference frame.

The variable bw4 specifying the width of the block in 4x4 pixels is set equal to num_4x4_blocks_wide_lookup[ MiSize ].

The variable bh4 specifying the height of the block in 4x4 pixels is set equal to num_4x4_blocks_high_lookup[ MiSize ].
  
The variable step is set as follows:

  * If bw4 is equal to 1 or bh is equal to 1, step is set equal to 2.
  
  * Otherwise, step is set equal to 4.
  
The process scans the locations within the block as follows:

~~~~~ c
for ( deltaRow = 0; deltaRow < bh4 ; deltaRow += step ) {
    for ( deltaCol = 0; deltaCol < bw4 ; deltaCol += step ) {
        mvRow = (MiRow + deltaRow) | 1
        mvCol = (MiCol + deltaCol) | 1
        if ( is_inside( mvRow, mvCol ) ) {
            add_ref_mv_candidate( mvRow, mvCol, refList, bw4, 1)
        }
    }
}
~~~~~

where the call to add_ref_mv_candidate invokes the process in [section 8.5.3.5][].

##### Add Reference Motion Vector Process

The inputs to this process are:
  
  * variables mvRow and mvCol specifying (in units of 4x4 pixels) the candidate location,
 
  * a variable refList specifying which set of motion vectors to predict, or -1 to signal compound prediction,
  
  * a variable len specifying the weight attached to this motion vector,
  
  * a variable usePrev specifying whether we should use spatial (usePrev equal to 0) or temporal (usePrev equal to 1) candidates.
  
This process examines the candidate to find matching reference frames.

If usePrev is equal to 1, the following applies for candList = 0..1:

1. if PrevRefFrames[ mvRow ][ mvCol ][ candList ] is equal to RefFrame[ refList ], the search stack process in [section 8.5.3.6][] is invoked with mvRow, mvCol, len, candList, usePrev as inputs

2. if PrevRefFrames[ mvRow ][ mvCol ][ candList ] is equal to RefFrame[ refList ], the variable FoundPrevMatch is set equal to 1

Otherwise, if refList is greater than or equal to 0, the following applies for candList = 0..1:

1. if RefFrames[ mvRow ][ mvCol ][ candList ] is equal to RefFrame[ refList ], the search stack process in [section 8.5.3.6][] is invoked with mvRow, mvCol, len, candList, usePrev as inputs

Otherwise (usePrev is equal to 0 and refList is equal to -1), the following applies:

1. if RefFrames[ mvRow ][ mvCol ][ 0 ] is equal to RefFrame[ 0 ] and RefFrames[ mvRow ][ mvCol ][ 1 ] is equal to RefFrame[ 1 ],
the compound search stack process in [section 8.5.3.7][] is invoked with mvRow, mvCol, refList, len as inputs

##### Search Stack Process

The inputs to this process are:
  
  * variables mvRow and mvCol specifying (in units of 4x4 pixels) the candidate location,
  
  * a variable candList specifying which list in the candidate matches our reference frame,
  
  * a variable len specifying the weight attached to this motion vector,
  
  * a variable usePrev specifying whether we should use spatial (usePrev equal to 0) or temporal (usePrev equal to 1) candidates,
  
This process adds motion vectors to the stack if they are not already present.

The candidate motion vector candMv is set as follows:

  * If usePrev is equal to 0, candMv is set equal to Mvs[ mvRow ][ mvCol ][ candList ].
  
  * Otherwise (usePrev is equal to 1), candMv is set equal to PrevMvs[ mvRow ][ mvCol ][ candList ].

The lower precision process specified in [section 8.5.3.8][] is invoked with candMv.

If usePrev is equal to 1 (we are inside the temporal scan process) and either Abs( candMv[ 0 ] ) > 0 or Abs( candMv[ 1 ] ) > 0, then ZeroMvContext is set equal to 1.

The variable weight is set equal to len * 2.

The process depends on whether the candidate motion vector is already in the stack as follows:

  * If candMv is already equal to RefStackMv[ idx ][ 0 ] for some idx less than NumMvFound, then WeightStack[ idx ] is increased by weight
  
  * Otherwise, if NumMvFound is less than 16, the following ordered steps apply:
   
     a. RefStackMv[ NumMvFound ][ 0 ] is set equal to candMv
     
     b. If usePrev is equal to 0, PredStackMv[ NumMvFound ][ 0 ] is set equal to PredMvs[ mvRow ][ mvCol ][ 0 ]
     
     c. If usePrev is equal to 1, PredStackMv[ NumMvFound ][ 0 ] is set equal to PrevPredMvs[ mvRow ][ mvCol ][ 0 ]
     
     d. WeightStack[ NumMvFound ] is set equal to weight
     
     e. NumMvFound is set equal to NumMvFound + 1.
     
  * Otherwise, (NumMvFound is greater than or equal to 16), the process has no effect.
  
NumNewMvFound is incremented by 1 if all of the following are true:

  * NumMvFound is increased during this process
  
  * usePrev is equal to 0
  
  * YModes[ mvRow ][ mvCol ] is equal to NEWMV

##### Compound Search Stack Process

The inputs to this process are:
  
  * variables mvRow and mvCol specifying (in units of 4x4 pixels) the candidate location,
  
  * a variable candList specifying which list in the candidate matches our reference frame,
  
  * a variable len specifying the weight attached to this motion vector,
  
This process adds motion vectors to the stack if they are not already present.

The array candMvs (containing two motion vectors) is set equal to Mvs[ mvRow ][ mvCol ].

For i = 0..1, the lower precision process specified in [section 8.5.3.8][] is invoked with candMvs[ i ].

The variable weight is set equal to len * 2.

The process depends on whether the candidate motion vector is already in the stack as follows:

  * If candMvs[ 0 ] is equal to RefStackMv[ idx ][ 0 ] and candMvs[ 1 ] is equal to RefStackMv[ idx ][ 1 ] for some idx less than NumMvFound, then WeightStack[ idx ] is increased by weight
  
  * Otherwise, if NumMvFound is less than 16, the following ordered steps apply:
   
     a. RefStackMv[ NumMvFound ][ i ] is set equal to candMvs[ i ] for i = 0..1
     
     b. PredStackMv[ NumMvFound ][ i ] is set equal to PredMvs[ mvRow ][ mvCol ][ i ] for i = 0..1
     
     b. WeightStack[ NumMvFound ] is set equal to weight
     
     c. NumMvFound is set equal to NumMvFound + 1.
     
  * Otherwise, (NumMvFound is greater than or equal to 16), the process has no effect.
  
NumNewMvFound is incremented by 1 if all of the following are true:

  * NumMvFound is increased during this process
  
  * YModes[ mvRow ][ mvCol ] is equal to NEW_NEWMV
  
##### Lower Precision Process

The input to this process is a reference candMv to a motion vector array.

This process modifies the contents of the input motion vector to remove the least significant bit when high precision is not allowed.

If allow_high_precision_mv is equal to 1, this process terminates immediately.

For i = 0..1, the following applies:

~~~~~ c
if (candMv[ i ] & 1) {
    if (candMv[ i ] > 0)
        candMv[ i ]--
    else
        candMv[ i ]++
}
~~~~~

##### Sorting Process

The inputs to this process are:

  * a variable start representing the first position to be sorted,
  
  * a variable end representing the length of the array.
  
This process performs a stable sort of part of the stack of motion vectors according to the corresponding weight.

Entries in RefStackMv from start (inclusive) to end (exclusive) are sorted.

The sorting process is specified as:

~~~~~ c
while ( end > start ) {
    newEnd = start
    for ( idx = start + 1; idx < end; idx++ ) {
        if ( WeightStack[ idx - 1 ] < WeightStack[ idx ] ) {
            swap(idx - 1, idx)
            newEnd = idx
        }
    }
}
~~~~~

When the function swap is invoked, the entries at locations idx and idx - 1 should be swapped in each of the following arrays:

  * WeightStack
  * RefStackMv
  * PredStackMv
  
##### Context and Clamping Process

The inputs to this process are:

  * a variable refList specifying which set of motion vectors to predict, or -1 to signal compound prediction,
  
  * a variable numNearest specifying the number of candidates found in the immediate neighbourhood,
  
  * a variable numNew specifying the number of NEWMV candidates found in the immediate neighbourhood.

This process computes contexts to be used when decoding syntax elements, and overwrites the entries in RefListMv with clamped candidates from RefStackMv.

The variable bw specifying the width of the block in pixels is set equal to 4 * num_4x4_blocks_wide_lookup[ MiSize ].

The variable bh specifying the height of the block in pixels is set equal to 4 * num_4x4_blocks_high_lookup[ MiSize ].

The variable numLists specifying the number of reference frames used for this block is set equal to ( (refList < 0) ? 2 : 1 ).

The arrays DrlCtxStack and MvCtxStack contain one or two contexts (depending on whether we are doing single or compound prediction) for each entry in the stack.

The array MvCtxStack is set as follows:

~~~~~ c
for ( list = 0; list < numLists; list++ ) {
    for ( idx = 0; idx < NumMvFound ; idx++ ) {
        refMv = RefStackMv[ idx ][ list ]
        predMv = PredStackMv[ idx ][ list ]
        v = 0
        if ( WeightStack[ idx ] >= REF_CAT_LEVEL )
            v = 2
            for ( j = 0; j < 2; j++ ) {
                if ( Abs( refMv[ j ] - predMv[ j ] ) > 4 )
                    v = 1
            }
        }
        MvCtxStack[ idx ][ list] = v
    }
}
~~~~~

The array DrlCtxStack is set as follows:

~~~~~ c
for ( list = 0; list < numLists; list++ ) {
    for ( idx = 0; idx < NumMvFound ; idx++ ) {
        z = 0
        if ( idx + 1 < NumMvFound ) {
            w0 = WeightStack[ idx ]
            w1 = WeightStack[ idx + 1 ]
            if (w0 >= REF_CAT_LEVEL) {
                if (w1 < REF_CAT_LEVEL) {
                    z = 2
                }
            } else {
                if (w1 < REF_CAT_LEVEL) {
                    z = 3
                }
            }
        }      
        DrlCtxStack[ idx ][ list ] = z
    }
}
~~~~~

**Note:** It is impossible for DrlCtxStack to contain the value 1.

The motion vectors are clamped and the variable AllZero is set as follows:

~~~~~ c
AllZero = 1
for ( list = 0; list < numLists; list++ ) {
    for ( idx = 0; idx < NumMvFound ; idx++ ) {
        refMv = RefStackMv[ idx ][ list ]
        refMv[ 0 ] = clamp_mv_row( refMv[ 0 ], MV_BORDER + bh * 8)
        refMv[ 1 ] = clamp_mv_col( refMv[ 1 ], MV_BORDER + bw * 8)
        if ( refList < 0 ) {
            RefStackMv[ idx ][ list ] = refMv
        } else if (idx < 2) {
            RefListMv[ refList ][ idx ] = refMv
        }
        if (idx < 3 && RefStackMv[ idx ][ list ] != ZeroMv[ list ])
            AllZero = 0
    }
}
if ( NumMvFound < 2 ) {
    for ( list = 0; list < numLists; list++ ) {
        for ( idx = 0; idx < 2; i++ ) {
            if ( RefListMv[ list ][ idx ] != ZeroMv[ list ] ) {
                AllZero = 0
            }
        }
    }
}
~~~~~

**Note:** The AllZero checks are done against unclamped motion vectors in the RefStackMv for single prediction, but against clamped motion vectors for compound prediction.

The variables RefMvContext and NewMvContext are set as follows:

~~~~~ c
if ( numNearest == 0 ) {
    NewMvContext = Min( NumMvFound, 1 )  // 0,1
    RefMvContext = Min( NumMvFound, 2 )  // 0,1,2
} else if ( numNearest == 1 ) {
    NewMvContext = 3 - Min( numNew, 1 ) // 2,3
    RefMvContext = Min( 3 * NumMvFound, 4)  // 0,3,4
} else {
    NewMvContext = 6 - Min( numNew, 2 ) // 4,5,6
    RefMvContext = 5
}
~~~~~

**Note:** It is impossible for RefMvContext to be equal to 6 or 7 or 8+6 or 8+7.

### Prediction Processes

The following sections define the processes used for predicting the sample
values.

These processes are triggered at points defined by function calls to
predict_intra, predict_inter, and predict_palette in the residual syntax table described in
[section 6.4.24][].

#### Intra Prediction Process

The intra prediction process is invoked for intra coded blocks to predict a
part of the block corresponding to a transform block. When the transform size
is smaller than the block size, this process can be invoked multiple times
within a single block for the same plane, and the invocations are in raster
order within the block.

The inputs to this process are:

  * the already reconstructed samples in the current frame CurrFrame,

  * a variable plane specifying which plane is being predicted,

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the current transform block,

  * a variable haveLeft that is equal to 1 if there are valid samples to the
    left of this transform block,

  * a variable haveAbove that is equal to 1 if there are valid samples above
    this transform block,

  * a variable notOnRight that is equal to 1 if the transform block is not on
    the right edge of the block,

  * a variable txSz, specifying the size of the transform block,

  * a variable blockIdx, specifying how much of the block has already been
    predicted in units of 4x4 samples.

The outputs of this process are intra predicted samples in the current frame
CurrFrame.

The variable mode is specified by:

  * If plane is greater than 0, mode is set equal to UVMode.

  * Otherwise, (plane is equal to 0), mode is set equal to YMode.

The variable log2Size specifying the base 2 logarithm of the width of the
transform block is set equal to txSz + 2.

The variable size is set equal to 1 \<\< log2Size.

The variable maxX is set equal to (MiCols * MI_SIZE) - 1.

The variable maxY is set equal to (MiRows * MI_SIZE) - 1.

If plane is greater than 0, then:

  * maxX is set equal to ((MiCols * MI_SIZE) \>\> subsampling_x) - 1.

  * maxY is set equal to ( (MiRows * MI_SIZE) \>\> subsampling_y) - 1.

The array aboveRow[ i ] for i = 0..size-1 is specified by:

  * If haveAbove is equal to 0, aboveRow[ i ] is set equal to
    ( 1 \<\< ( BitDepth - 1 ) ) - 1.

  * Otherwise, aboveRow[ i ] is set equal to
    CurrFrame[ plane ][ y-1 ][ Min(maxX, x+i) ].

The array aboveRow[ i ] for i = size..2*size-1 is specified by:

  * If haveAbove is equal to 1 and notOnRight is equal to 1 and txSz is equal
    to 0, aboveRow[ i ] is set equal to
    CurrFrame[ plane ][ y-1 ][ Min(maxX, x+i) ].

  * Otherwise, aboveRow[ i ] is set equal to aboveRow[ size-1 ].

The array aboveRow[ i ] for i = -1 is specified by:

  * If haveAbove is equal to 1 and haveLeft is equal to 1, aboveRow[ -1 ] is
    set equal to CurrFrame[ plane ][ y-1 ][ Min(maxX, x-1) ].

  * Otherwise if haveAbove is equal to 1, aboveRow[ -1] is set equal to
    ( 1 \<\< ( BitDepth - 1 ) ) + 1.

  * Otherwise, aboveRow[ -1 ] is set equal to ( 1 \<\< ( BitDepth - 1 ) ) - 1.

The array leftCol[ i ] for i = 0..size-1 is specified by:

  * If haveLeft is equal to 1, leftCol[ i ] is set equal to
    CurrFrame[ plane ][ Min(maxY, y+i) ][ x-1 ].

  * Otherwise, leftCol[ i ] is set equal to (1 \<\< ( BitDepth - 1 ) ) + 1.

A 2D array named pred containing the intra predicted samples is constructed as follows:

  * If is_directional_mode( mode ) is true, the following ordered steps apply:
  
    1. The variable angleDelta is derived as follows:
      
        * If plane is equal to 0, angleDelta is set equal to AngleDeltaY.

        * Otherwise (plane is not equal to 0), angleDelta is set equal to AngleDeltaUV.
       
    2. The variable pAngle is set equal to ( mode_to_angle_map[ mode ] + angleDelta * ANGLE_STEP ).
    
    3. The variable dx is derived as follows:
    
        * If pAngle is greater than 0 and less than 90, dx is set equal to dr_intra_derivative[ pAngle ].
        
        * Otherwise, if pAngle is greater than 90 and less than 180, dx is set equal to dr_intra_derivative[ 180 - pAngle ].
        
        * Otherwise, dx is undefined.
    
    4. The variable dy is derived as follows:
    
        * If pAngle is greater than 90 and less than 180, dy is set equal to dr_intra_derivative[ pAngle - 90 ].
        
        * Otherwise, if pAngle is greater than 180 and less than 270, dy is set equal to dr_intra_derivative[ 270 - pAngle ].
        
        * Otherwise, dy is undefined.
      
    5. If pAngle is greater than 0 and less than 90, the following steps apply for i = 0..size-1, for j = 0..size-1:
    
        * The variable idx is set equal to ( j \<\< 8 ) + ( i + 1 ) * dx.

        * The variable base is set equal to idx \>\> 8.

        * The variable shift is set equal to idx & 0xFF.

        * The variable max_base_x is set equal to 2 * size - 1.

        * If base is less than max_base_x, pred[ i ][ j ] is set equal to Clip1( Round2( aboveRow[ base ] * ( 256 - shift ) + aboveRow[ base + 1 ] * shift, 8 ) ).

        * Otherwise (base is greater than or equal to max_base_x), pred[ i ][ j ] is set equal to aboveRow[ max_base_x ].
      
    6. Otherwise, if pAngle is greater than 90 and pAngle is less than 180, the following steps apply for i = 0..size-1, for j = 0..size-1:
    
        * The variable idx is set equal to ( j \<\< 8 ) - ( i + 1 ) * dx.
        
        * The variable base is set equal to idx \>\> 8.
        
        * If base is greater than or equal to -1, the following steps apply:

          * The variable shift is set equal to idx & 0xFF.

          * pred[ i ][ j ] is set equal to Clip1( Round2( aboveRow[ base ] * ( 256 - shift ) + aboveRow[ base + 1 ] * shift, 8 ) ).

        * Otherwise (base is less than -1), the following steps apply:
        
          * The variable idx is set equal to ( i \<\< 8 ) - ( j + 1 ) * dy.
          
          * The variable base is set equal to idx \>\> 8.
          
          * The variable shift is set equal to idx & 0xFF.
          
          * pred[ i ][ j ] is set equal to Clip1( Round2( leftCol[ base ] * ( 256 - shift ) + leftCol[ base + 1 ] * shift, 8 ) ).
        
    7. Otherwise, if pAngle is greater than 180 and pAngle is less than 270, the following steps apply for i = 0..size-1, for j = 0..size-1:
    
        * The variable idx is set equal to ( i \<\< 8 ) - ( j + 1 ) * dy.
        
        * The variable base is set equal to idx \>\> 8.
        
        * The variable shift is set equal to idx & 0xFF.
        
        * The variable max_base_y is set equal to 2 * size - 1.
        
        * If base is less than max_base_y, pred[ i ][ j ] is set equal to Clip1( Round2( leftCol[ base ] * ( 256 - shift ) + leftCol[ base + 1 ] * shift, 8 ) ).
        
        * Otherwise (base is greater than or equal to max_base_y), pred[ i ][ j ] is set equal to leftCol[ max_base_y ].
      
    8. Otherwise, if pAngle is equal to 90, pred[ i ][ j ] is set equal to aboveRow[ j ] with j = 0..size-1 and i = 0..size-1 (each row of the block is filled with
       a copy of aboveRow).
       
    9. Otherwise, if pAngle is equal to 180, pred[ i ][ j ] is set equal to leftCol[ i ] with j = 0..size-1 and i = 0..size-1 (each column of the block is filled with
       a copy of leftCol).
      
  * Otherwise if mode is equal to V_PRED, pred[ i ][ j ] is set equal to aboveRow[ j ]
    with j = 0..size-1 and i = 0..size-1 (each row of the block is filled with
    a copy of aboveRow).

  * Otherwise if mode is equal to H_PRED, pred[ i ][ j ] is set equal to
    leftCol[ i ] with j = 0..size-1 and i = 0..size-1 (each column of the
    block is filled with a copy of leftCol).

  * Otherwise if mode is equal to D207_PRED, the following applies:

    1. pred[ i ][ j ] = Round2( leftCol[ i + j/2 ] +
       leftCol[ I + 1 + j/2 ], 1 ) for even values of i in the
       range 0..size-2

    2. pred[ i ][ j ] = Round2( leftCol[ i + j/2 ] + 2 *
       leftCol[ i + 1 + j/2 ] + leftCol[ I + 2 + j/2 ], 2 ) for odd values
       of i in the range 0..size-1

  * Otherwise if mode is equal to D45_PRED, the following applies:

    1. pred[ i ][ j ] = Round2( aboveRow[ i + j ] + 2 *
       aboveRow[ i + j + 1 ] + aboveRow[ i + j + 1 ], 2 )
       if (i + j + 1 >= 2 * size)

    2. pred[ i ][ j ] = Round2( aboveRow[ i + j ] + 2 *
       aboveRow[ i + j + 1 ] + aboveRow[ i + j + 2 ], 2 )
       if (i + j + 1 < 2 * size)

  * Otherwise if mode is equal to D63_PRED, the following applies:

    1. pred[ i ][ j ] = Round2( aboveRow [ i/2 + j ] +
       aboveRow [ I/2 + j + 1 ], 1 ) for even values of j in the
       range 0..size-2

    2. pred[ i ][ j ] = Round2( aboveRow [ i/2 + j ] + 2 *
       aboveRow [ i/2 + j + 1 ] + aboveRow [ I/2 + j + 2, 2 )
       for odd values of j in the range 0..size-1.

  * Otherwise if mode is equal to D117_PRED, the following applies:

    1. pred[ 0 ][ j ] = Round2( aboveRow[ j - 1 ] + aboveRow[ j ], 1 )
       for j = 0..size-1

    2. pred[ 1 ][ 0 ] = Round2( leftCol[ 0 ] + 2 * aboveRow[ -1 ] +
       aboveRow[ 0 ], 2 )

    3. pred[ 1 ][ j ] = Round2( aboveRow[ j - 2 ] + 2 * aboveRow[ j - 1 ] +
       aboveRow[ j ], 2 ) for j = 1..size-1

    4. pred[ 2 ][ 0 ] = Round2( aboveRow[ -1 ] + 2 * leftCol[ 0 ] +
       leftCol[ 1 ], 2 )

    5. pred[ i ][ 0 ] = Round2( leftCol[ i - 3 ] + 2 * leftCol[ i - 2 ] +
       leftCol[ i - 1 ], 2 ) for i = 3..size-1

    6. pred[ i ][ j ] = pred[ i - 2 ][ j - 1 ] for i = 2..size-1,
       for j = 1..size-1

  * Otherwise if mode is equal to D135_PRED, the following applies:

    1. pred[ 0 ][ 0 ] = Round2( leftCol[ 0 ] + 2 * aboveRow[ -1 ] +
       aboveRow[ 0 ], 2 )

    2. pred[ 0 ][ j ] = Round2( aboveRow[ j - 2 ] + 2 * aboveRow[ j - 1 ] +
       aboveRow[ j ], 2 ) for j = 1..size-1

    3. pred[ 1 ][ 0 ] = Round2( aboveRow [ -1 ] + 2 * leftCol[ 0 ] +
       leftCol[ 1 ], 2 ) for i = 1..size-1

    4. pred[ i ][ 0 ] = Round2( leftCol[ i - 2 ] + 2 * leftCol[ i - 1 ] +
       leftCol[ i ], 2 ) for i = 2..size-1

    5. pred[ i ][ j ] = pred[ i - 1 ][ j - 1 ] for i = 1..size-1,
       for j = 1..size-1

  * Otherwise if mode is equal to D153_PRED, the following applies:

    1. pred[ 0 ][ 0 ] = Round2( leftCol[ 0 ] + aboveRow[ -1 ], 1 )

    2. pred[ i ][ 0 ] = Round2( leftCol[ i - 1] + leftCol[ i ], 1 )
       for i = 1..size-1

    3. pred[ 0 ][ 1 ] = Round2( leftCol[ 0 ] + 2 * aboveRow[ -1 ] +
       aboveRow[ 0 ], 2 )

    4. pred[ 1 ][ 1 ] = Round2( aboveRow[ -1 ] + 2 * leftCol [ 0 ] +
       leftCol [ 1 ], 2 )

    5. pred[ i ][ 1 ] = Round2( leftCol[ i - 2 ] + 2 * leftCol[ i - 1 ] +
       leftCol[ i ], 2 ) for i = 2..size-1

    6. pred[ 0 ][ j ] = Round2( aboveRow[ j - 3 ] + 2 * aboveRow[ j - 2 ] +
       aboveRow[ j - 1 ], 2 ) for j = 2..size-1

    7. pred[ i ][ j ] = pred[ i - 1 ][ j - 2 ] for i = 1..size-1,
       for j = 2..size-1

  * Otherwise if mode is equal to TM_PRED, the following ordered steps apply
    for i = 0..size-1, for j = 0..size-1:

    1. The variable base is set equal to aboveRow[ j ] + leftCol[ i ] - 
       aboveRow[ -1 ].

    2. The variable pLeft is set equal to Abs( base - leftCol[ i ]).

    3. The variable pTop is set equal to Abs( base - aboveRow[ j ]).

    4. The variable pTopLeft is set equal to Abs( base - aboveRow[ -1 ] ).

    5. If pLeft <= pTop and pLeft <= pTopLeft, pred[ i ][ j ] is set equal to
       leftCol[ i ].

    6. Otherwise, if pTop <= pTopLeft, pred[ i ][ j ] is set equal to aboveRow[ j ].

    7. Otherwise, pred[ i ][ j ] is set equal to aboveRow[ -1 ].

  * Otherwise if mode is equal to SMOOTH_PRED, the following ordered steps
    apply for i = 0..size-1, for j = 0..size-1:

    1. The variable smWeights is set dependent on the value of txSz according to the
       following table:

       |     txSz |          smWeights |
       |:--------:|:------------------:|
       |   TX_4X4 | sm_weights_tx4x4   |
       |   TX_8X8 | sm_weights_tx8x8   |
       | TX_16X16 | sm_weights_tx16x16 |
       | TX_32X32 | sm_weights_tx32x32 |

    2. The variable smoothPred is set as follows:
   
       ~~~~~ c
       smoothPred =   smWeights[ txSz ][ i ] * aboveRow[ j ] +
                   ( 256 - smWeights[ txSz ][ i ] ) * leftCol[ size - 1 ] +
                     smWeights[ txSz ][ j ] * leftCol[ i ] +
                   ( 256 - smWeights[ txSz ][ j ] ) * aboveRow[ size - 1 ]
       ~~~~~

    3. pred[ i ][ j ] is set equal to Clip1( Round2( smoothPred, 9 ) ).

  * Otherwise if mode is equal to DC_PRED and haveLeft is equal to 1 and
    haveAbove is equal to 1, pred[ i ][ j ] is set equal to avg with
    i = 0..size-1 and j = 0..size-1. The variable avg (the average of the
    samples in union of aboveRow and leftCol) is specified as follows:

    ~~~~~ c
    sum = 0
    for ( k = 0; k < size; k++ ) {
        sum += leftCol[ k ]
        sum += aboveRow[ k ]
    }
    avg = (sum + size) >> (log2Size + 1)
    ~~~~~

  * Otherwise if mode is equal to DC_PRED and haveLeft is equal to 1 and
    haveAbove is equal to 0, pred[ i ][ j ] is set equal to leftAvg with
    i = 0..size-1 and j = 0..size-1. The variable leftAvg is specified as
    follows:

    ~~~~~ c
    sum = 0
    for ( k = 0; k < size; k++ ) {
        sum += leftCol[ k ]
    }
    leftAvg = (sum + (1 << (log2Size - 1) ) ) >> log2Size
    ~~~~~

  * Otherwise if mode is equal to DC_PRED and haveLeft is equal to 0 and
    haveAbove is equal to 1, pred[ i ][ j ] is set equal to aboveAvg with
    i = 0..size-1 and j = 0..size-1. The variable aboveAvg is specified
    as follows:

    ~~~~~ c
    sum = 0
    for ( k = 0; k < size; k++ ) {
        sum += aboveRow[ k ]
    }
    aboveAvg = (sum + (1 << (log2Size - 1) ) ) >> log2Size
    ~~~~~

  * Otherwise (mode is DC_PRED), pred[ i ][ j ] is set equal
    to 1 \<\< ( BitDepth - 1 ) with i = 0..size-1 and j = 0..size-1.

The current frame is updated as follows:

  * CurrFrame[ plane ][ y + i ][ x + j ] is set equal to pred[ i ][ j ]
    for i = 0..size-1 and j = 0..size-1.


#### Inter Prediction Process

The inter prediction process is invoked for inter coded blocks.  The inputs
to this process are:

  * a variable plane specifying which plane is being predicted,

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the region to be predicted,

  * variables w and h specifying the width and height of the region to be
    predicted.
    
The outputs of this process are inter
predicted samples in the current frame CurrFrame.

This process is triggered by a function call to predict_inter.

The variable isCompound
is set equal to RefFrame[ 1 ] > NONE. 

The prediction arrays are formed by
the following ordered steps:

  1. The variable refList is set equal to 0.

  2. The motion vector selection process in [section 8.6.2.1][] is invoked
     with plane, refList as inputs and the output being the
     motion vector mv.

  3. The motion vector clamping process in [section 8.6.2.2][] is invoked with
     plane, mv as inputs and the output being the clamped motion vector
     clampedMv

  4. The motion vector scaling process in [section 8.6.2.3][] is invoked with
     plane, refList, x, y, clampedMv as inputs and the output being the
     initial location startX, startY, and the step sizes stepX, stepY.

  5. The block inter prediction process in [section 8.6.2.4][] is invoked with
     plane, refList, startX, startY, stepX, stepY, w, h as inputs and the
     output is assigned to the 2D array preds[ refList ].

  6. If isCompound is equal to 1, then the variable refList is set equal
     to 1 and steps 2, 3, 4 and 5 are repeated to form the prediction for
     the second reference. 
     
The inter predicted samples are then derived as
follows:

  * If isCompound is equal to 0, CurrFrame[ plane ][ y + i ][ x + j ]
   is set equal to Clip1( Round2( preds[ 0 ][ i ][ j ], 9) ) for i = 0..h-1 and j = 0..w-1.

  * Otherwise, CurrFrame[ plane ][ y + i ][ x + j ] is set equal to
   Clip1( Round2( preds[ 0 ][ i ][ j ] + preds[ 1 ][ i ][ j ], 10 ) )
   for i = 0..h-1 and j = 0..w-1.


##### Motion Vector Selection Process

The inputs to this process are:

  * a variable plane specifying which plane is being predicted,

  * a variable refList specifying which set of motion vectors to use.
    
The output of this process
is a 2 element array called mv containing the motion vector for this
block. 

The motion
vector array mv is set equal to Mv[ refList ].

##### Motion Vector Clamping Process

The inputs to this process are:

  * a variable plane specifying which plane is being predicted,

  * a variable mv specifying the motion vector to be clamped.

The output of this process is a 2 element array called clampedMv containing
the clamped motion vector for this block. The purpose of this process is to
change the motion vector into the appropriate precision for the current plane
and to clamp motion vectors that go too far off the edge of the frame. The
variables sx and sy are set equal to the subsampling for the current plane
as follows:

  * If plane is equal to 0, sx is set equal to 0 and sy is set equal to 0.

  * Otherwise, sx is set equal to subsampling_x and sy is set equal to
    subsampling_y.

The output array clampedMv is specified by the following steps:

~~~~~ c
bh = num_4x4_blocks_high_lookup[ MiSize ]
mbToTopEdge = -((MiRow * MI_SIZE) * 16) >> sy
mbToBottomEdge = (((MiRows - bh - MiRow) * MI_SIZE) * 16) >> sy
bw = num_4x4_blocks_wide_lookup[ MiSize ]
mbToLeftEdge = -((MiCol * MI_SIZE) * 16) >> sx
mbToRightEdge = (((MiCols - bw - MiCol) * MI_SIZE) * 16) >> sx
spelLeft = (INTERP_EXTEND + ((bw * MI_SIZE) >> sx) ) << SUBPEL_BITS
spelRight = spelLeft - SUBPEL_SHIFTS
spelTop = (INTERP_EXTEND + ((bh * MI_SIZE) >> sy) ) << SUBPEL_BITS
spelBottom = spelTop - SUBPEL_SHIFTS
clampedMv[ 0 ] = Clip3( mbToTopEdge - spelTop, mbToBottomEdge + spelBottom,
    (2 * mv[ 0 ]) >> sy )
clampedMv[ 1 ] = Clip3( mbToLeftEdge - spelLeft, mbToRightEdge + spelRight,
    (2 * mv[ 1 ]) >> sx )
~~~~~

**Note:** The clamping is applied before the motion vector is scaled.


##### Motion Vector Scaling Process

The inputs to this process are:

  * a variable plane specifying which plane is being predicted,

  * a variable refList specifying that we should scale to match reference
    frame RefFrame[ refList ],

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the region to be predicted,

  * a variable clampedMv specifying the clamped motion vector.

The outputs of this process are the variables startX and startY giving the
reference block location in units of 1/16 th of a sample, and variables xStep
and yStep giving the step size in units of 1/16 th of a sample.

This process is responsible for computing the sampling locations in the
reference frame based on the motion vector. The sampling locations are also
adjusted to compensate for any difference in the size of the reference frame
compared to the current frame.

A variable refIdx specifying which reference frame is being used is set equal
to ref_frame_idx[ RefFrame[ refList ] - LAST_FRAME ].

It is a requirement of bitstream conformance that all the following conditions
are satisfied:

  * 2 * FrameWidth >= RefFrameWidth[ refIdx ]

  * 2 * FrameHeight >= RefFrameHeight[ refIdx ]

  * FrameWidth <= 16 * RefFrameWidth[ refIdx ]

  * FrameHeight <= 16 * RefFrameHeight[ refIdx ]

A variable xScale is set equal to (RefFrameWidth[ refIdx ] \<\<
REF_SCALE_SHIFT) / FrameWidth.

A variable yScale is set equal to (RefFrameHeight[ refIdx ] \<\<
REF_SCALE_SHIFT) / FrameHeight.

(xScale and yScale specify the size of the reference frame relative to the
current frame in units where 16 is equivalent to the reference frame having
the same size.)

The variable baseX is set equal to (x * xScale) \>\> REF_SCALE_SHIFT.

The variable baseY is set equal to (y * yScale) \>\> REF_SCALE_SHIFT.

(baseX and baseY specify the location of the block in the reference frame if a
zero motion vector is used).

The variable lumaX is set equal to (plane > 0) ? x \<\< subsampling_x : x.

The variable lumaY is set equal to (plane > 0) ? y \<\< subsampling_y : y.
(lumaX and lumaY specify the location of the block to be predicted in the
current frame in units of luma samples.)

The variable fracX is set equal to ( (16 * lumaX * xScale) \>\>
REF_SCALE_SHIFT) & SUBPEL_MASK.

The variable fracY is set equal to ( (16 * lumaY * yScale) \>\>
REF_SCALE_SHIFT) & SUBPEL_MASK.

The variable dX is set equal to ( (clampedMv[ 1 ] * xScale) \>\>
REF_SCALE_SHIFT) + fracX.

The variable dY is set equal to ( (clampedMv[ 0 ] * yScale) \>\>
REF_SCALE_SHIFT) + fracY.

(dX and dY specify a scaled motion vector.)

The output variable stepX is set equal to (16 * xScale) \>\> REF_SCALE_SHIFT.

The output variable stepY is set equal to (16 * yScale) \>\> REF_SCALE_SHIFT.

The output variable startX is set equal to (baseX \<\< SUBPEL_BITS) + dX.

The output variable startY is set equal to (baseY \<\< SUBPEL_BITS) + dY.

**Note:** Even for chroma blocks the fractional part of the start position is
based on the luma block location in lumaX and lumaY.



##### Block Inter Prediction Process

The inputs to this process are:

  * a variable plane,

  * a variable refList specifying that we should predict from
    RefFrame[ refList ],

  * variables x and y giving the block location in units of 1/16 th of a
    sample,

  * variables xStep and yStep giving the step size in units of 1/16 th of a
    sample. (These will be at most equal to 80 due to the restrictions on
    scaling between reference frames.)

  * variables w and h giving the width and height of the block in units of
    samples

The output from this process is the 2D array named pred containing inter
predicted samples.

A variable refIdx specifying which reference frame is being used is set equal
to ref_frame_idx[ RefFrame[ refList ] - LAST_FRAME ].

A variable ref specifying the reference frame contents is set equal to
FrameStore[ refIdx ].

The variables subX and subY are set equal to the subsampling for the current
plane as follows:

  * If plane is equal to 0, subX is set equal to 0 and subY is set equal to 0.

  * Otherwise, subX is set equal to subsampling_x and subY is set equal to
   subsampling_y.

The variable lastX is set equal to ( (RefFrameWidth[ refIdx ] + subX) \>\>
subX) - 1.

The variable lastY is set equal to ( (RefFrameHeight[ refIdx ] + subY) \>\>
subY) - 1.

(lastX and lastY specify the coordinates of the bottom right sample of the reference plane.)

The variable intermediateHeight specifying the height required for the
intermediate array is set equal to (((h - 1) * yStep + 15) \>\> 4) + 8.

The sub-sample interpolation is effected via two one-dimensional convolutions.
First a horizontal filter is used to build up a temporary array, and then this
array is vertically filtered to obtain the final prediction. The fractional
parts of the motion vectors determine the filtering process. If the fractional
part is zero, then the filtering is equivalent to a straight sample copy.

The filtering is applied as follows:

  * The array intermediate is specified as follows:

    ~~~~~ c
    for ( r = 0; r < intermediateHeight; r++ ) {
        for ( c = 0; c < w; c++ ) {
            s = 0
            p = x + xStep * c
            for ( t = 0; t < 8; t++ )
                s += subpel_filters[ interp_filter[ 1 ] ][ p & 15 ][ t ] *
                  ref[ plane ] [ Clip3( 0, lastY, (y >> 4) + r - 3 ) ]
                               [ Clip3( 0, lastX, (p >> 4) + t - 3 ) ]
            intermediate[ r ][ c ] = Round2(s, 5)
        }
    }
    ~~~~~

  * The array pred is specified as follows:

    ~~~~~ c
    for ( r = 0; r < h; r++ ) {
        for ( c = 0; c < w; c++ ) {
            s = 0
            p = (y & 15) + yStep * r
            for ( t = 0; t < 8; t++ )
                s += subpel_filters[ interp_filter[ 0 ] ][ p & 15 ][ t ] *
                  intermediate[ (p >> 4) + t ][ c ]
            pred[ r ][ c ] = s
        }
    }
    ~~~~~

    where the constant array subpel_filters is specified as:

    ~~~~~ c
    subpel_filters[ 4 ][ 16 ][ 8 ] = {
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { 0, 2, -6, 126, 8, -2, 0, 0 },
        { 0, 2, -10, 122, 18, -4, 0, 0 },
        { 0, 2, -12, 116, 28, -8, 2, 0 },
        { 0, 2, -14, 110, 38, -10, 2, 0 },
        { 0, 2, -14, 102, 48, -12, 2, 0 },
        { 0, 2, -16, 94, 58, -12, 2, 0 },
        { 0, 2, -14, 84, 66, -12, 2, 0 },
        { 0, 2, -14, 76, 76, -14, 2, 0 },
        { 0, 2, -12, 66, 84, -14, 2, 0 },
        { 0, 2, -12, 58, 94, -16, 2, 0 },
        { 0, 2, -12, 48, 102, -14, 2, 0 },
        { 0, 2, -10, 38, 110, -14, 2, 0 },
        { 0, 2, -8, 28, 116, -12, 2, 0 },
        { 0, 0, -4, 18, 122, -10, 2, 0 },
        { 0, 0, -2, 8, 126, -6, 2, 0 }
      },
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { 0, 2, 28, 62, 34, 2, 0, 0 },
        { 0, 0, 26, 62, 36, 4, 0, 0 },
        { 0, 0, 22, 62, 40, 4, 0, 0 },
        { 0, 0, 20, 60, 42, 6, 0, 0 },
        { 0, 0, 18, 58, 44, 8, 0, 0 },
        { 0, 0, 16, 56, 46, 10, 0, 0 },
        { 0, -2, 16, 54, 48, 12, 0, 0 },
        { 0, -2, 14, 52, 52, 14, -2, 0 },
        { 0, 0, 12, 48, 54, 16, -2, 0 },
        { 0, 0, 10, 46, 56, 16, 0, 0 },
        { 0, 0, 8, 44, 58, 18, 0, 0 },
        { 0, 0, 6, 42, 60, 20, 0, 0 },
        { 0, 0, 4, 40, 62, 22, 0, 0 },
        { 0, 0, 4, 36, 62, 26, 0, 0 },
        { 0, 0, 2, 34, 62, 28, 2, 0 }
      },
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { -2, 2, -6, 126, 8, -2, 2, 0 },
        { -2, 6, -12, 124, 16, -6, 4, -2 },
        { -2, 8, -18, 120, 26, -10, 6, -2 },
        { -4, 10, -22, 116, 38, -14, 6, -2 },
        { -4, 10, -22, 108, 48, -18, 8, -2 },
        { -4, 10, -24, 100, 60, -20, 8, -2 },
        { -4, 10, -24, 90, 70, -22, 10, -2 },
        { -4, 12, -24, 80, 80, -24, 12, -4 },
        { -2, 10, -22, 70, 90, -24, 10, -4 },
        { -2, 8, -20, 60, 100, -24, 10, -4 },
        { -2, 8, -18, 48, 108, -22, 10, -4 },
        { -2, 6, -14, 38, 116, -22, 10, -4 },
        { -2, 6, -10, 26, 120, -18, 8, -2 },
        { -2, 4, -6, 16, 124, -12, 6, -2 },
        { 0, 2, -2, 8, 126, -6, 2, -2 }
      },
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { 0, 0, 0, 120, 8, 0, 0, 0 },
        { 0, 0, 0, 112, 16, 0, 0, 0 },
        { 0, 0, 0, 104, 24, 0, 0, 0 },
        { 0, 0, 0, 96, 32, 0, 0, 0 },
        { 0, 0, 0, 88, 40, 0, 0, 0 },
        { 0, 0, 0, 80, 48, 0, 0, 0 },
        { 0, 0, 0, 72, 56, 0, 0, 0 },
        { 0, 0, 0, 64, 64, 0, 0, 0 },
        { 0, 0, 0, 56, 72, 0, 0, 0 },
        { 0, 0, 0, 48, 80, 0, 0, 0 },
        { 0, 0, 0, 40, 88, 0, 0, 0 },
        { 0, 0, 0, 32, 96, 0, 0, 0 },
        { 0, 0, 0, 24, 104, 0, 0, 0 },
        { 0, 0, 0, 16, 112, 0, 0, 0 },
        { 0, 0, 0, 8, 120, 0, 0, 0 }
      }
    }
    ~~~~~

**Note:** All the values in subpel_filters are even.

#### Palette Prediction Process

The palette prediction process is invoked for palette coded intra blocks to predict
a part of the block using the limited palette.

The inputs to this process are:

- a variable plane specifying which plane is being predicted,
- variables startX and startY specifying the location of the top left
  sample in the CurrFrame[ plane ] array of the current transform block,
- variables x and y specifying the location in 4x4 units relative to the
  top left sample of the current transform block,
- a variable txSz, specifying the size of the current transform block.

The outputs of this process are palette predicted samples in the current
frame CurrFrame.

The variable log2Size specifying the base 2 logarithm of the width of the
transform block is set equal to txSz + 2.

The variable size is set equal to 1 \<\< log2Size.

The variable palette is specified as follows:

- If plane is 0, palette is set to palette_colors_y.
- Otherwise, if plane is 1, palette is set to palette_colors_u.
- Otherwise (plane is 2), palette is set to palette_colors_v.

The variable map is specified as follows:

- If plane is 0, map is set to ColorMapY.
- Otherwise (plane is not 0), map is set to ColorMapUV.

The current frame is updated as follows:

- CurrFrame[ plane ][ startY + i ][ startX + j ] is set equal to palette[ map[ y * 4 + i ][ x * 4 + j ] ] for
i = 0..size - 1 and j = 0..size - 1.

### Reconstruction and Dequantization

This section details the process of reconstructing a block of coefficients
using dequantization and inverse transforms.


#### Dequantization Functions

This section defines the functions get_dc_quant and get_ac_quant that are
needed by the dequantization process.

The quantization parameters are derived from lookup tables.

The function dc_q( b ) is specified as
dc_qlookup[ (BitDepth-8) \>\> 1 ][ Clip3( 0, 255, b ) ] where dc_qlookup is
defined as follows:

~~~~~ c
dc_qlookup[ 3 ][ 256 ] = {
  {
    4, 8, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16,
    17, 18, 19, 19, 20, 21, 22, 23, 24, 25, 26, 26,
    27, 28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37,
    38, 38, 39, 40, 41, 42, 43, 43, 44, 45, 46, 47,
    48, 48, 49, 50, 51, 52, 53, 53, 54, 55, 56, 57,
    57, 58, 59, 60, 61, 62, 62, 63, 64, 65, 66, 66,
    67, 68, 69, 70, 70, 71, 72, 73, 74, 74, 75, 76,
    77, 78, 78, 79, 80, 81, 81, 82, 83, 84, 85, 85,
    87, 88, 90, 92, 93, 95, 96, 98, 99, 101, 102, 104,
    105, 107, 108, 110, 111, 113, 114, 116, 117, 118, 120, 121,
    123, 125, 127, 129, 131, 134, 136, 138, 140, 142, 144, 146,
    148, 150, 152, 154, 156, 158, 161, 164, 166, 169, 172, 174,
    177, 180, 182, 185, 187, 190, 192, 195, 199, 202, 205, 208,
    211, 214, 217, 220, 223, 226, 230, 233, 237, 240, 243, 247,
    250, 253, 257, 261, 265, 269, 272, 276, 280, 284, 288, 292,
    296, 300, 304, 309, 313, 317, 322, 326, 330, 335, 340, 344,
    349, 354, 359, 364, 369, 374, 379, 384, 389, 395, 400, 406,
    411, 417, 423, 429, 435, 441, 447, 454, 461, 467, 475, 482,
    489, 497, 505, 513, 522, 530, 539, 549, 559, 569, 579, 590,
    602, 614, 626, 640, 654, 668, 684, 700, 717, 736, 755, 775,
    796, 819, 843, 869, 896, 925, 955, 988, 1022, 1058, 1098, 1139,
    1184, 1232, 1282, 1336
  },
  {
    4, 9, 10, 13, 15, 17, 20, 22, 25, 28, 31, 34,
    37, 40, 43, 47, 50, 53, 57, 60, 64, 68, 71, 75,
    78, 82, 86, 90, 93, 97, 101, 105, 109, 113, 116, 120,
    124, 128, 132, 136, 140, 143, 147, 151, 155, 159, 163, 166,
    170, 174, 178, 182, 185, 189, 193, 197, 200, 204, 208, 212,
    215, 219, 223, 226, 230, 233, 237, 241, 244, 248, 251, 255,
    259, 262, 266, 269, 273, 276, 280, 283, 287, 290, 293, 297,
    300, 304, 307, 310, 314, 317, 321, 324, 327, 331, 334, 337,
    343, 350, 356, 362, 369, 375, 381, 387, 394, 400, 406, 412,
    418, 424, 430, 436, 442, 448, 454, 460, 466, 472, 478, 484,
    490, 499, 507, 516, 525, 533, 542, 550, 559, 567, 576, 584,
    592, 601, 609, 617, 625, 634, 644, 655, 666, 676, 687, 698,
    708, 718, 729, 739, 749, 759, 770, 782, 795, 807, 819, 831,
    844, 856, 868, 880, 891, 906, 920, 933, 947, 961, 975, 988,
    1001, 1015, 1030, 1045, 1061, 1076, 1090, 1105, 1120, 1137, 1153, 1170,
    1186, 1202, 1218, 1236, 1253, 1271, 1288, 1306, 1323, 1342, 1361, 1379,
    1398, 1416, 1436, 1456, 1476, 1496, 1516, 1537, 1559, 1580, 1601, 1624,
    1647, 1670, 1692, 1717, 1741, 1766, 1791, 1817, 1844, 1871, 1900, 1929,
    1958, 1990, 2021, 2054, 2088, 2123, 2159, 2197, 2236, 2276, 2319, 2363,
    2410, 2458, 2508, 2561, 2616, 2675, 2737, 2802, 2871, 2944, 3020, 3102,
    3188, 3280, 3375, 3478, 3586, 3702, 3823, 3953, 4089, 4236, 4394, 4559,
    4737, 4929, 5130, 5347
  },
  {
    4, 12, 18, 25, 33, 41, 50, 60,
    70, 80, 91, 103, 115, 127, 140, 153,
    166, 180, 194, 208, 222, 237, 251, 266,
    281, 296, 312, 327, 343, 358, 374, 390,
    405, 421, 437, 453, 469, 484, 500, 516,
    532, 548, 564, 580, 596, 611, 627, 643,
    659, 674, 690, 706, 721, 737, 752, 768,
    783, 798, 814, 829, 844, 859, 874, 889,
    904, 919, 934, 949, 964, 978, 993, 1008,
    1022, 1037, 1051, 1065, 1080, 1094, 1108, 1122,
    1136, 1151, 1165, 1179, 1192, 1206, 1220, 1234,
    1248, 1261, 1275, 1288, 1302, 1315, 1329, 1342,
    1368, 1393, 1419, 1444, 1469, 1494, 1519, 1544,
    1569, 1594, 1618, 1643, 1668, 1692, 1717, 1741,
    1765, 1789, 1814, 1838, 1862, 1885, 1909, 1933,
    1957, 1992, 2027, 2061, 2096, 2130, 2165, 2199,
    2233, 2267, 2300, 2334, 2367, 2400, 2434, 2467,
    2499, 2532, 2575, 2618, 2661, 2704, 2746, 2788,
    2830, 2872, 2913, 2954, 2995, 3036, 3076, 3127,
    3177, 3226, 3275, 3324, 3373, 3421, 3469, 3517,
    3565, 3621, 3677, 3733, 3788, 3843, 3897, 3951,
    4005, 4058, 4119, 4181, 4241, 4301, 4361, 4420,
    4479, 4546, 4612, 4677, 4742, 4807, 4871, 4942,
    5013, 5083, 5153, 5222, 5291, 5367, 5442, 5517,
    5591, 5665, 5745, 5825, 5905, 5984, 6063, 6149,
    6234, 6319, 6404, 6495, 6587, 6678, 6769, 6867,
    6966, 7064, 7163, 7269, 7376, 7483, 7599, 7715,
    7832, 7958, 8085, 8214, 8352, 8492, 8635, 8788,
    8945, 9104, 9275, 9450, 9639, 9832, 10031, 10245,
    10465, 10702, 10946, 11210, 11482, 11776, 12081, 12409,
    12750, 13118, 13501, 13913, 14343, 14807, 15290, 15812,
    16356, 16943, 17575, 18237, 18949, 19718, 20521, 21387
  }
}
~~~~~

The function ac_q( b ) is specified as ac_qlookup[
(BitDepth-8) \>\> 1 ][ Clip3( 0, 255, b ) ] where ac_qlookup is defined as follows:

~~~~~ c
ac_qlookup[ 3 ][ 256 ] = {
  {
    4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
    55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
    79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
    91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,
    104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
    128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
    152, 155, 158, 161, 164, 167, 170, 173, 176, 179, 182, 185,
    188, 191, 194, 197, 200, 203, 207, 211, 215, 219, 223, 227,
    231, 235, 239, 243, 247, 251, 255, 260, 265, 270, 275, 280,
    285, 290, 295, 300, 305, 311, 317, 323, 329, 335, 341, 347,
    353, 359, 366, 373, 380, 387, 394, 401, 408, 416, 424, 432,
    440, 448, 456, 465, 474, 483, 492, 501, 510, 520, 530, 540,
    550, 560, 571, 582, 593, 604, 615, 627, 639, 651, 663, 676,
    689, 702, 715, 729, 743, 757, 771, 786, 801, 816, 832, 848,
    864, 881, 898, 915, 933, 951, 969, 988, 1007, 1026, 1046, 1066,
    1087, 1108, 1129, 1151, 1173, 1196, 1219, 1243, 1267, 1292, 1317, 1343,
    1369, 1396, 1423, 1451, 1479, 1508, 1537, 1567, 1597, 1628, 1660, 1692,
    1725, 1759, 1793, 1828
  },
  {
    4, 9, 11, 13, 16, 18, 21, 24, 27, 30, 33, 37,
    40, 44, 48, 51, 55, 59, 63, 67, 71, 75, 79, 83,
    88, 92, 96, 100, 105, 109, 114, 118, 122, 127, 131, 136,
    140, 145, 149, 154, 158, 163, 168, 172, 177, 181, 186, 190,
    195, 199, 204, 208, 213, 217, 222, 226, 231, 235, 240, 244,
    249, 253, 258, 262, 267, 271, 275, 280, 284, 289, 293, 297,
    302, 306, 311, 315, 319, 324, 328, 332, 337, 341, 345, 349,
    354, 358, 362, 367, 371, 375, 379, 384, 388, 392, 396, 401,
    409, 417, 425, 433, 441, 449, 458, 466, 474, 482, 490, 498,
    506, 514, 523, 531, 539, 547, 555, 563, 571, 579, 588, 596,
    604, 616, 628, 640, 652, 664, 676, 688, 700, 713, 725, 737,
    749, 761, 773, 785, 797, 809, 825, 841, 857, 873, 889, 905,
    922, 938, 954, 970, 986, 1002, 1018, 1038, 1058, 1078, 1098, 1118,
    1138, 1158, 1178, 1198, 1218, 1242, 1266, 1290, 1314, 1338, 1362, 1386,
    1411, 1435, 1463, 1491, 1519, 1547, 1575, 1603, 1631, 1663, 1695, 1727,
    1759, 1791, 1823, 1859, 1895, 1931, 1967, 2003, 2039, 2079, 2119, 2159,
    2199, 2239, 2283, 2327, 2371, 2415, 2459, 2507, 2555, 2603, 2651, 2703,
    2755, 2807, 2859, 2915, 2971, 3027, 3083, 3143, 3203, 3263, 3327, 3391,
    3455, 3523, 3591, 3659, 3731, 3803, 3876, 3952, 4028, 4104, 4184, 4264,
    4348, 4432, 4516, 4604, 4692, 4784, 4876, 4972, 5068, 5168, 5268, 5372,
    5476, 5584, 5692, 5804, 5916, 6032, 6148, 6268, 6388, 6512, 6640, 6768,
    6900, 7036, 7172, 7312
  },
  {
    4, 13, 19, 27, 35, 44, 54, 64,
    75, 87, 99, 112, 126, 139, 154, 168,
    183, 199, 214, 230, 247, 263, 280, 297,
    314, 331, 349, 366, 384, 402, 420, 438,
    456, 475, 493, 511, 530, 548, 567, 586,
    604, 623, 642, 660, 679, 698, 716, 735,
    753, 772, 791, 809, 828, 846, 865, 884,
    902, 920, 939, 957, 976, 994, 1012, 1030,
    1049, 1067, 1085, 1103, 1121, 1139, 1157, 1175,
    1193, 1211, 1229, 1246, 1264, 1282, 1299, 1317,
    1335, 1352, 1370, 1387, 1405, 1422, 1440, 1457,
    1474, 1491, 1509, 1526, 1543, 1560, 1577, 1595,
    1627, 1660, 1693, 1725, 1758, 1791, 1824, 1856,
    1889, 1922, 1954, 1987, 2020, 2052, 2085, 2118,
    2150, 2183, 2216, 2248, 2281, 2313, 2346, 2378,
    2411, 2459, 2508, 2556, 2605, 2653, 2701, 2750,
    2798, 2847, 2895, 2943, 2992, 3040, 3088, 3137,
    3185, 3234, 3298, 3362, 3426, 3491, 3555, 3619,
    3684, 3748, 3812, 3876, 3941, 4005, 4069, 4149,
    4230, 4310, 4390, 4470, 4550, 4631, 4711, 4791,
    4871, 4967, 5064, 5160, 5256, 5352, 5448, 5544,
    5641, 5737, 5849, 5961, 6073, 6185, 6297, 6410,
    6522, 6650, 6778, 6906, 7034, 7162, 7290, 7435,
    7579, 7723, 7867, 8011, 8155, 8315, 8475, 8635,
    8795, 8956, 9132, 9308, 9484, 9660, 9836, 10028,
    10220, 10412, 10604, 10812, 11020, 11228, 11437, 11661,
    11885, 12109, 12333, 12573, 12813, 13053, 13309, 13565,
    13821, 14093, 14365, 14637, 14925, 15213, 15502, 15806,
    16110, 16414, 16734, 17054, 17390, 17726, 18062, 18414,
    18766, 19134, 19502, 19886, 20270, 20670, 21070, 21486,
    21902, 22334, 22766, 23214, 23662, 24126, 24590, 25070,
    25551, 26047, 26559, 27071, 27599, 28143, 28687, 29247
  }
}
~~~~~

The function get_qindex( ignoreDeltaQ ) returns the quantizer index for the current block and is specified by the following:

  * If seg_feature_active( SEG_LVL_ALT_Q ) is equal to 1 the following ordered steps apply:

    1. Set the variable data equal to FeatureData[ segment_id ][ SEG_LVL_ALT_Q ].

    2. If segmentation_abs_or_delta_update is equal to 0, set data equal to
       base_q_idx + data

    3. Return Clip3( 0, 255, data ).

  * Otherwise, if ignoreDeltaQ is equal to 0 and delta_q_present is equal to 1, return CurrentQIndex.

  * Otherwise, return base_q_idx.

The function get_dc_quant( plane ) returns the quantizer value for the dc
coefficient for a particular plane and is derived as follows:

  * If plane is equal to 0, return dc_q( get_qindex( 0 ) + deltaQYDc ).

  * Otherwise, return dc_q( get_qindex( 0 ) + deltaQUVDc ).

The function get_ac_quant( plane ) returns the quantizer value for the ac
coefficient for a particular plane and is derived as follows:

  * If plane is equal to 0, return ac_q( get_qindex( 0 ) ).

  * Otherwise, return ac_q( get_qindex( 0 ) + deltaQUVAc ).


#### Reconstruct Process

The reconstruct process is invoked to perform dequantization, inverse
transform and reconstruction. This process is triggered at a point defined by
a function call to reconstruct in the residual syntax table described in
[section 6.4.24][].

The inputs to this process are:

  * a variable plane specifying which plane is being reconstructed,

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the current transform block,

  * a variable txSz, specifying the size of the transform block.

The outputs of this process are reconstructed samples in the current frame
CurrFrame.

The reconstruction and dequantization process is defined as follows:

The variable dqDenom is set equal to 2 if txSz is equal to TX_32X32, otherwise
dqDenom is set equal to 1.

The variable n (specifying the base 2 logarithm of the width of the transform
block) is set equal to 2 + txSz.

The variable n0 (specifying the width of the transform block) is set equal
to 1 \<\< n.

The variable flipUD is derived as follows. If PlaneTxType is equal to one of FLIPADST_DCT, 
FLIPADST_ADST, V_FLIPADST, or FLIPADST_FLIPADST, flipUD is set equal to 1. Otherwise, 
flipUD is set equal to 0.

The variable flipLR is derived as follows. If PlaneTxType is equal to one of DCT_FLIPADST, 
ADST_FLIPADST, H_FLIPADST, or FLIPADST_FLIPADST, flipLR is set equal to 1. Otherwise, 
flipLR is set equal to 0.

The following ordered steps apply:

  1. For i = 0..(n0-1), for j = 0..(n0-1), the following ordered steps apply:
  
      a. The variable q is derived as follows:
        
        * If i is equal to 0 and j is equal to 0, the variable q is set equal to get_dc_quant( plane ).
      
        * Otherwise (i, j or both are not equal to 0), the variable q is set equal to get_ac_quant( plane ).
      
      b. The variable q2 is derived as follows:
      
        * If using_qmatrix is equal to 1, PlaneTxType is less than IDTX, and SegQMLevel[ segment_id ] is less than 15, q2 is set
         equal to Round2( q * quantizer_matrix[ SegQMLevel[ segment_id ] ][ plane > 0 ][ qm_offset[ txSz ] + i * n0 + j ], 4 ).
         
        * Otherwise, q2 is set equal to q.
      
      c. Dequant[ i ][ j ] is set equal to ( Tokens[ i * n0 + j ] *
         q2 ) / dqDenom.

  2. Invoke the 2D inverse transform block process defined in [section 8.8.2][]
     with the variable n as input. The inverse transform outputs are stored
     back to the Dequant buffer.

  3. For i = 0..(n0-1), for j = 0..(n0-1), the following applies:
  
      * The variable xx is set equal to flipLR ? ( n0 - j - 1 ) : j.
        
      * The variable yy is set equal to flipUD ? ( n0 - i - 1 ) : i.
      
      * CurrFrame[ plane ][ y + yy ][ x + xx ] is set equal to
        Clip1( CurrFrame[ plane ][ y + yy ][ x + xx ] + Dequant[ i ][ j ] ).

It is a requirement of bitstream conformance that the values written into the
Dequant array in steps 1 and 2 are representable by a signed integer with 8 +
BitDepth bits.


### Inverse Transform Process

This section details the inverse transforms used during the reconstruction
processes detailed in [section 8.7][].


#### 1D Transforms

##### Butterfly Functions

This section defines the butterfly functions B, H, SB, SH used by the 1D
transform processes.

The inverse transform process works by writing values into an array T. It is a
requirement of bitstream conformance that the values saved into the array T
are representable by a signed integer using 8 + BitDepth bits of precision.

**Note:** The inverse asymmetric discrete sine transforms also make use of an
intermediate array named S. The values in this array require higher precision
to avoid overflow. Using signed integers with 24 + BitDepth bits of precision
is enough to avoid overflow.

The function brev(numBits, x) returns the bit-reversal of numBits of x and is
specified as follows:

~~~~~ c
brev( numBits, x ) {
    t = 0
    for ( i = 0; i < numBits; i++ ) {
        bit = (x >> i) & 1
        t += bit << (numBits - 1 - i)
    }
    return t
}
~~~~~

The function B( a, b, angle, 0 ) performs a butterfly rotation specified by
the following ordered steps:

  1. The variable x is set equal to T[ a ] * cos64( angle ) - T[ b ] *
     sin64( angle ).

  2. The variable y is set equal to T[ a ] * sin64( angle ) + T[ b ] *
     cos64( angle ).

  3. T[ a ] is set equal to Round2( x, 14 ).

  4. T[ b ] is set equal to Round2( y, 14 ).

It is a requirement of bitstream conformance that the values saved into the
array T by this function are representable by a signed integer using 8 +
BitDepth bits of precision.

The function cos64( angle ) is specified for integer values of the input angle
by the following ordered steps:

  1. Set a variable angle2 equal to angle & 127.

  2. If angle2 is greater than or equal to 0 and less than or equal to 32,
     return cos64_lookup[ angle2 ].

  3. If angle2 is greater than 32 and less than or equal to 64, return
     cos64_lookup[ 64 - angle2 ] * -1.

  4. If angle2 is greater than 64 and less than or equal to 96, return
     cos64_lookup[ angle2 - 64 ] * -1.

  5. Otherwise (if angle2 is greater than 96 and less than 128), return
     cos64_lookup[ 128 - angle2 ].

Where cos64_lookup is a constant lookup table defined as:

~~~~~ c
cos64_lookup[ 33 ] = {
    16384, 16364, 16305, 16207, 16069, 15893, 15679, 15426,
    15137, 14811, 14449, 14053, 13623, 13160, 12665, 12140,
    11585, 11003, 10394, 9760, 9102, 8423, 7723, 7005,
    6270, 5520, 4756, 3981, 3196, 2404, 1606, 804,
    0
}
~~~~~

The function sin64( angle ) is defined to be cos64( angle - 32 ).

**Note:** The cos64 function implements the expression round( 16384 *
cos( angle * pi / 64 ) ). The sin64 function implements the expression
round( 16384 * sin( angle * pi / 64 ) ).

When the angle is equal to 16 + 32*k for integer k the butterfly rotation can
be equivalently performed with two fewer multiplications (because the
magnitude of cos64(16 + 32*k) is always equal to that of sin64(16 + 32*k))
by the following process:

  1. The variable v is set equal to (angle & 32) ? T[ a ] +
     T[ b ] : T[ a ] - T[ b ].

  2. The variable w is set equal to (angle & 32) ? -T[ a ] +
     T[ b ] : T[ a ] + T[ b ].

  3. The variable x is set equal to v * cos64( angle ).

  4. The variable y is set equal to w * cos64( angle ).

  5. T[ a ] is set equal to Round2( x, 14 ).

  6. T[ b ] is set equal to Round2( y, 14 ).

It is a requirement of bitstream conformance that the angle is equal to 16 +
32*k for integer k, the variables v and w are representable by a signed
integer using 8 + BitDepth bits of precision.

The function B( a ,b, angle, 1 ) performs a butterfly rotation and flip
specified by the following ordered steps:

  1. The function B( a, b, angle, 0 ) is invoked.

  2. The contents of T[ a ] and T[ b ] are exchanged.

The function H( a, b, 0 ) performs a Hadamard rotation specified by the
following ordered steps:

  1. The variable x is set equal to T[ a ].

  2. The variable y is set equal to T[ b ].

  3. T[ a ] is set equal to x + y.

  4. T[ b ] is set equal to x - y.

It is a requirement of bitstream conformance that the values saved into the
array T by this function are representable by a signed integer using 8 +
BitDepth bits of precision.

The function H( a, b, 1 ) performs a Hadamard rotation with flipped indices
and is specified as follows:

  1. The function H( b, a, 0 ) is invoked.

The function SB( a, b, angle, 0 ) performs a butterfly rotation according to
the following ordered steps:

  1. S[ a ] is set equal to T[ a ] * cos64( angle ) - T[ b ] * sin64( angle ).

  2. S[ b ] is set equal to T[ a ] * sin64( angle ) + T[ b ] * cos64( angle ).

The function SB( a, b, angle, 1 ) performs a butterfly rotation and flip according to the following ordered steps:

  1. The function SB( a, b, angle, 0 ) is invoked.

  2. The contents of S[ a ] and S[ b ] are exchanged.

The function SH( a, b ) performs a Hadamard rotation and rounding specified by
the following ordered steps:

  1. T[ a ] is set equal to Round2( S[ a ] + S[ b ], 14 ).

  2. T[ b ] is set equal to Round2( S[ a ] - S[ b ], 14 ).


##### Inverse DCT Array Permutation Process

This process performs an in-place permutation of the array T of length 2n
for 2  n  5 which is required before execution of the inverse DCT process.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

A temporary array named copyT is set equal to T.

T[ i ] is set equal to copyT[ brev( n, i ) ] for i = 0..((1 \<\< n) - 1).


##### Inverse DCT Process

This process performs an in-place inverse discrete cosine transform of the
permuted array T which is of length 2n for 2  n  5.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

The variable n0 is set equal to 1 \<\< n.

The variable n1 is set equal to 1 \<\< (n - 1).

The variable n2 is set equal to 1 \<\< (n - 2).

The variable n3 is set equal to 1 \<\< (n - 3).

The following ordered steps apply:

  1. If n is equal to 2, invoke B( 0, 1, 16, 1 ), otherwise recursively invoke
     the inverse DCT defined in this section with the variable n set equal to
     n - 1.

  2. Invoke B( n1+i, n0-1-i, 32-brev( 5, n1+i), 0 ) for i = 0..(n2-1).

  3. If n is greater than or equal to 3:

     a. Invoke H( n1+4*i+2*j, n1+1+4*i+2*j, j ) for i = 0..(n3-1), j = 0..1.

  4. If n is equal to 5:

     a. Invoke B( n0-n+3-n2*j-4*i, n1+n-4+n2*j+4*i, 28-16*i+56*j, 1 )
        for i = 0..1, j = 0..1.

     b. Invoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3.

  5. If n is greater than or equal to 4:

     a. Invoke B( n0-n+2-i-n2*j, n1+n-3+i+n2*j, 24+48*j, 1 )
        for i = 0..(n==5), j = 0..1.

     b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7),
        j = 0..1.

  6. If n is greater than or equal to 3:

     a. Invoke B( n0-n3-1-i, n1+n3+i, 16, 1 ) for i = 0..(n3-1).

  7. Invoke H( i, n0-1-i, 0 ) for i = 0..(n1-1).


##### Inverse ADST Input Array Permutation Process

This process performs the in-place permutation of the array T of length 2n
which is required as the first step of the inverse ADST.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

The variable n0 is set equal to 1 \<\< n.

The variable n1 is set equal to 1 \<\< (n - 1).

A temporary array named copyT is set equal to T.

The values at even locations T[ 2 * i ] are set equal to
copyT[ n0 - 1 - 2 * i ] for i = 0..(n1-1).

The values at odd locations T[ 2 * i + 1 ] are set equal to copyT[ 2 * i ]
for i = 0..(n1-1).


##### Inverse ADST Output Array Permutation Process

This process performs the in-place permutation of the array T of length 2n
which is required before the final step of the inverse ADST.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

A temporary array named copyT is set equal to T.

The permutation depends on n as follows:

  * If n is equal to 4, T[ 8*a + 4*b + 2*c + d ] is set equal to
    copyT[ 8*(d^c) + 4*(c^b) + 2*(b^a) + a ] for a = 0..1 and b = 0..1
    and c = 0..1 and d = 0..1.

  * Otherwise (n is equal to 3), T[ 4*a + 2*b + c ] is set equal to
    copyT[ 4*(c^b) + 2*(b^a) + a ] for a = 0..1 and b = 0..1 and c = 0..1.


##### Inverse ADST4 Process

This process does an in-place transform of the array T to perform an inverse
ADST.

The following ordered steps apply:

~~~~~ c
s0 = SINPI_1_9 * T[ 0 ]
s1 = SINPI_2_9 * T[ 0 ]
s2 = SINPI_3_9 * T[ 1 ]
s3 = SINPI_4_9 * T[ 2 ]
s4 = SINPI_1_9 * T[ 2 ]
s5 = SINPI_2_9 * T[ 3 ]
s6 = SINPI_4_9 * T[ 3 ]
v = T[ 0 ] - T[ 2 ] + T[ 3 ]
s7 = SINPI_3_9 * v
x0 = s0 + s3 + s5
x1 = s1 - s4 - s6
x2 = s7
x3 = s2
s0 = x0 + x3
s1 = x1 + x3
s2 = x2
s3 = x0 + x1 - x3
T[ 0 ] = Round2( s0, 14 )
T[ 1 ] = Round2( s1, 14 )
T[ 2 ] = Round2( s2, 14 )
T[ 3 ] = Round2( s3, 14 )
~~~~~

It is a requirement of bitstream conformance that the values saved into the
variable v and into the array T by this function are representable by a signed
integer using 8 + BitDepth bits of precision.

The constants used in this function are defined as:

| Name of constant  | Value of constant
|:-----------------:|:-----------------:
| SINPI_1_9         | 5283
| SINPI_2_9         | 9929
| SINPI_3_9         | 13377
| SINPI_4_9         | 15212


##### Inverse ADST8 Process

This process does an in-place transform of the array T using a higher
precision array S for intermediate results. The following ordered steps apply:

  1. Invoke the ADST input array permutation process specified in [section 8.8.1.4][] with the input variable n set equal to 3.

  2. Invoke SB( 2*i, 1+2*i, 30-8*i, 1 ) for i = 0..3.

  3. Invoke SH( i, 4+i ) for i = 0..3.

  4. Invoke SB( 4+3*i, 5+i, 24-16*i, 1 ) for i = 0..1.

  5. Invoke SH( 4+i, 6+i ) for i = 0..1.

  6. Invoke H( i, 2+i, 0 ) for i = 0..1.

  7. Invoke B( 2+4*i, 3+4*i, 16, 1 ) for i = 0..1.

  8. Invoke the ADST output array permutation process specified in
     [section 8.8.1.5][] with the input variable n set equal to 3.

  9. Set T[ 1+2*i ] equal to -T[ 1+2*i ] for i = 0..3.


##### Inverse ADST16 Process

This process does an in-place transform of the array T using a higher
precision array S for intermediate results. The following ordered steps apply:

  1. Invoke the ADST input array permutation process specified in
     [section 8.8.1.4][] with the input variable n set equal to 4.

  2. Invoke SB( 2*i, 1+2*i, 31-4*i, 1 ) for i = 0..7.

  3. Invoke SH( i, 8+i ) for i = 0..7.

  4. Invoke SB( 8+2*i, 9+2*i, 28-16*i, 1 ) for i = 0..3.

  5. Invoke SH( 8+i, 12+i ) for i = 0..3.

  6. Invoke H( i, 4+i, 0 ) for i = 0..3.

  7. Invoke SB( 4+8*i+3*j, 5+8*i+j, 24-16*j, 1 ) for i = 0..1, for j = 0..1.

  8. Invoke SH( 4+8*j+i, 6+8*j+i ) for i = 0..1, j = 0..1.

  9. Invoke H( 8*j+i, 2+8*j+i, 0 ) for i = 0..1, for j = 0..1.

  10. Invoke B( 2+4*j+8*i, 3+4*j+8*i, 48+64*(i^j), 0 ) for i = 0..1,
      for j = 0..1.

  11. Invoke the ADST output array permutation process specified in
      [section 8.8.1.5][] with the input variable n set equal to 4.

  12. Set T[ 1+12*j+2*i ] equal to -T[ 1+12*j+2*i ] for i = 0..1,
      for j = 0..1.


##### Inverse ADST Process

This process performs an in-place inverse ADST process on the array T of size
2n for 2  n  4.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

The process to invoke depends on n as follows:

  * If n is equal to 2, invoke the Inverse ADST4 process specified in
    [section 8.8.1.6][].

  * Otherwise if n is equal to 3, invoke the Inverse ADST8 process specified
    in [section 8.8.1.7][].

  * Otherwise (n is equal to 4), invoke the Inverse ADST16 process specified
    in [section 8.8.1.8][].


##### Inverse Walsh-Hadamard Transform Process

The input to this process is a variable shift that specifies the amount of
pre-scaling.

This process does an in-place transform of the array T (of length 4) by the
following ordered steps:

~~~~~ c
a = T[ 0 ] >> shift
c = T[ 1 ] >> shift
d = T[ 2 ] >> shift
b = T[ 3 ] >> shift
a += c
d -= b
e = (a - d) >> 1
b = e - b
c = e - c
a -= b
d += c
T[ 0 ] = a
T[ 1 ] = b
T[ 2 ] = c
T[ 3 ] = d
~~~~~


#### 2D Inverse Transform

This process performs a 2D inverse transform for an array of size 2n by 2n
stored in the 2D array Dequant.

The input to this process is a variable n that specifies the base 2 logarithm
of the width of the transform.

Set the variable n0 equal to 1 \<\< n.

The variable is2To1Rect is derived as follows:

  * If the ratio of the transform width to the transform height is equal to 2,
    is2To1Rect is set equal to 1.
   
  * Otherwise, if the ratio of the transform height to the transform width is 
    equal to 2, is2To1Rect is set equal to 1.
    
  * Otherwise, is2To1Rect is set equal to 0.

The row transforms with i = 0..(n0-1) are applied as follows:

  * Set T[ j ] equal to Dequant[ i ][ j ] for j = 0..(n0-1).

  * If Lossless is equal to 1, invoke the Inverse WHT process as specified in
    [section 8.8.1.10][] with shift equal to 2.

  * Otherwise, if PlaneTxType is equal to one of DCT_DCT, ADST_DCT, FLIPADST_DCT or H_DCT,
    apply an inverse DCT as follows:

    1. Invoke the inverse DCT permutation process as specified in [section 8.8.1.2][] with the input variable n.

    2. Invoke the inverse DCT process as specified in [section 8.8.1.3][] with the
       input variable n.

  * Otherwise if PlaneTxType is equal to one of DCT_ADST, ADST_ADST, DCT_FLIPADST, FLIPADST_FLIPADST, 
    ADST_FLIPADST, FLIPADST_ADST, H_ADST, or H_FLIPADST, invoke the inverse ADST process as 
    specified in [section 8.8.1.9][] with input variable n.

  * Otherwise if PlaneTxType is equal to IDTX, BitDepth is less than or equal to 8, and
    is2To1Rect is equal to 0, TODO[Invoke IDTX_1].
    
  * Otherwise, TODO[Invoke IDTX_2].
  
  * Set Dequant[ i ][ j ] equal to T[ j ] for j = 0..(n0-1).

The column transforms with j = 0..(n0-1) are applied as follows:

  * Set T[ i ] equal to Dequant[ i ][ j ] for i = 0..(n0-1).

  * If Lossless is equal to 1, invoke the Inverse WHT process as specified in
    [section 8.8.1.10][] with shift equal to 0.

  * Otherwise, if PlaneTxType is equal to one of DCT_DCT, DCT_ADST, DCT_FLIPADST or
    V_DCT, apply an inverse DCT as follows:

      1. Invoke the inverse DCT permutation process as specified in
         [section 8.8.1.2][] with the input variable n.

      2. Invoke the inverse DCT process as specified in [section 8.8.1.3][]
         with the input variable n.

  * Otherwise, if PlaneTxType is equal to one of ADST_DCT, ADST_ADST, FLIPADST_DCT, 
    FLIPADST_FLIPADST, ADST_FLIPADST, FLIPADST_ADST, V_ADST, or V_FLIPADST,
    invoke the inverse ADST process as specified in [section 8.8.1.9][] with input
    variable n.

  * Otherwise, if PlaneTxType is equal to IDTX, BitDepth is less than or equal to 8,
    and is2To1Rect is equal to 0, TODO[Invoke IDTX_1].
    
  * Otherwise, TODO[Invoke IDTX_2].
  
  * The variable noRounding is derived as follows:
  
      * If Lossless is equal to 1, noRounding is set equal to 1.
      
      * Otherwise if PlaneTxType is equal to IDTX and is2To1Rect is equal to 1,
        noRounding is set equal to 1.
      
      * Otherwise if BitDepth is greater than 8, noRounding is set equal to 1.
      
      * Otherwise, noRounding is set equal to 0.
  
  * If noRounding is equal to 1, set Dequant[ i ][ j ] equal to T[ i ] for i = 0..(n0-1).
  
  * Otherwise (noRounding is equal to 0), set Dequant[ i ][ j ] equal to
    Round2( T[ i ], Min( 6, n + 2 ) ) for i = 0..(n0-1).


### Loop Filter Process

Input to this process is the array CurrFrame of reconstructed samples.

Output from this process is a modified array CurrFrame containing deblocked
samples.

The purpose of the loop filter is to eliminate (or at least reduce) visually
objectionable artifacts associated with the semi-independence of the coding of
super blocks and their constituent sub-blocks.

The loop filter is applied on all vertical boundaries followed by all horizontal boundaries as
follows:

~~~~~ c
for ( pass = 0; pass < 2; pass++ ) {
    for ( plane = 0; plane < 3; plane++ ) {
        rowStep = ( plane > 0 ) ? 1 : ( 1 << subsampling_y )
        colStep = ( plane > 0 ) ? 1 : ( 1 << subsampling_x )
        for ( row = 0; row < MiRows; row += rowStep )
            for ( col = 0; col < MiCols; col += colStep )
                loop_filter_edge( plane, pass, row, col )
    }
}
~~~~~

When the function loop_filter_edge is called, the edge loop filter process specified in 8.8.2 is invoked with the
variables plane, pass, row, and col as inputs.

**Note:** The loop filter is an integral part of the decoding process, in that
the results of loop filtering are used in the prediction of subsequent frames.

**Note:** The loop filtering is designed so that any order of filtering for the edges
will give identical results, provided that the vertical boundaries are filtered before the horizontal boundaries. 

**Note:** The loop filter applies after the macroblocks have been
"reconstructed" (i.e., had their prediction summed with their residual);
correct decoding is predicated on the fact that already-constructed portions
of the current frame referenced via intra prediction are not yet filtered.


#### Edge Loop Filter Process

The inputs to this process are:

  * a variable plane specifying whether we are filtering Y, U, or V samples,

  * a variable pass specifying the direction of the edges. pass equal to 0
    means we are filtering vertical block boundaries, and pass equal to 1
    means we are filtering horizontal block boundaries,

  * variables row and col specifying the location of the edge in units
    of 4x4 blocks in the luma plane.

The outputs of this process are modified values in the array CurrFrame.

The variables subX and subY describing the subsampling of the current plane
are derived as follows:

  * If plane is equal to 0, subX and subY are set equal to 0.

  * Otherwise (plane is not equal to 0), subX is set equal to subsampling_x
    and subY is set equal to subsampling_y.

The variables dx and dy are derived as follows:

  * If pass is equal to 0, then dx is set equal to 1, dy is set equal to 0.

  * Otherwise (pass is equal to 1), dy is set equal to 1, dx is set equal
    to 0.

dx and dy specify the offset between the samples to be filtered.

The variables x and y (containing the location in luma coordinates) are
derived as follows:

  * If pass is equal to 0, x is set equal to col * MI_SIZE,
   and y is set equal to row * MI_SIZE.

  * Otherwise (pass is equal to 1), x is set equal to col * MI_SIZE, and y is set equal to row * MI_SIZE.
       
The variable onScreen (equal to 1 if the samples on both sides of the
boundary lie in the visible area) is derived as follows:

  * If x is greater than or equal to FrameWidth, onScreen is set equal
    to 0.

  * Otherwise, if y is greater than or equal to FrameHeight, onScreen is
    set equal to 0.

  * Otherwise, if pass is equal to 0 and x is equal to 0, onScreen is set
    equal to 0.

  * Otherwise, if pass is equal to 1 and y is equal to 0, onScreen is set
    equal to 0.

  * Otherwise, onScreen is set equal to 1.
      
If onScreen is equal to 0 and i is equal to 0, then this process immediately returns and no filtering is applied to this edge.
       
The variables xP and yP (containing the location in the current plane) are derived as follows:
  
  * Set xP equal to x \>\> subX

  * Set yP equal to y \>\> subY  
    
The variables prevRow and prevCol (containing the location of the mode info block on the other side of the boundary) are derived as follows:
  
  * Set prevRow equal to row - ( dy \<\< suby )

  * Set prevCol equal to col - ( dx \<\< subx )

Set the variable MiSize equal to MiSizes[ row ][ col ].

Set the variable tx_size equal to TxSizes[ row ][ col ].

Set the variable txSz equal to (plane > 0) ? get_uv_tx_size( ) : tx_size.

Set the variable planeSize equal to get_plane_block_size( MiSize, plane )

Set the variable skip equal to Skips[ row ][ col ].
  
Set the variable isIntra equal to
     RefFrames[ row ][ col ][ 0 ] <= INTRA_FRAME.
  
Set the variable tx_size equal to TxSizes[ prevRow ][ prevCol ].

Set the variable prevTxSz equal to (plane > 0) ? get_uv_tx_size( ) : tx_size.

Set the variable prevSkip equal to Skips[ prevRow ][ prevCol ].

Set the variable prevIsIntra equal to
     RefFrames[ prevRow ][ prevCol ][ 0 ] <= INTRA_FRAME.

The variable isBlockEdge (equal to 1 if the samples cross a prediction
block edge) is derived as follows:

  * If pass is equal to 0 and xP is an exact multiple
    of 4*num_4x4_blocks_wide_lookup[ planeSize ], isBlockEdge is set equal to 1.

  * Otherwise, if pass is equal to 1 and yP is an exact multiple
    of 4*num_4x4_blocks_high_lookup[ planeSize ], isBlockEdge is set equal to 1.

  * Otherwise, isBlockEdge is set equal to 0.

The variable isTxEdge (equal to 1 if the samples cross a transform block
edge) is derived as follows:

  * If pass is equal to 0 and xP is an exact multiple of 4 \<\< txSz, isTxEdge is set
    equal to 1.
    
  * Otherwise, if pass is equal to 1 and yP is an exact multiple of 4 \<\< txSz, isTxEdge is set
    equal to 1.

  * Otherwise, isTxEdge is set equal to 0.
  
The variable isTileEdge (equal to 1 if the samples come from different tiles is derived as follows:

  * If TileNums[ prevRow ][ prevCol ] is equal to TileNums[ row ][ col ], isTileEdge is set equal to 0.
  
  * Otherwise, isTileEdge is set equal to 1
  
The variable isTileGroupEdge (equal to 1 if the samples come from different tile groups is derived as follows:

  * If TileStarts[ prevRow ][ prevCol ] is equal to TileStarts[ row ][ col ], isTileGroupEdge is set equal to 0.
  
  * Otherwise, isTileGroupEdge is set equal to 1

The variable applyFilter (equal to 1 if the samples are filtered) is
derived as follows:

  * If isTxEdge is equal to 0, applyFilter is set equal to 0.
  
  * Otherwise, if pass is equal to 0 and loop_filter_across_tiles is equal to 0 and isTileEdge is equal to 1, applyFilter is set equal to 0
  
  * Otherwise, if pass is equal to 1 and loop_filter_across_tiles is equal to 0
    and dependent_tiles is equal to 0 and isTileEdge is equal to 1, applyFilter is set equal to 0
    
  * Otherwise, if pass is equal to 1 and loop_filter_across_tiles is equal to 0
    and dependent_tiles is equal to 1 and isTileGroupEdge is equal to 1, applyFilter is set equal to 0

  * Otherwise, if isBlockEdge is equal to 1 or skip is equal to 0 or isIntra is equal to 1 or prevSkip is equal to 0 or prevIsIntra is equal to 1, applyFilter is set equal
    to 1.

  * Otherwise applyFilter is set equal to 0.

The filter size process specified in [section 8.9.2][] is invoked with the inputs
txSz, prevTxSz, pass, subX, and subY, plane and the output assigned to
the variable filterSize (containing the maximum filter size that can be
used).

The adaptive filter strength process specified in [section 8.9.3][] is invoked with
the inputs row and col, and the output assigned to the variables
lvl, limit, blimit, and thresh.
      
If lvl is equal to 0, the adaptive filter strength process specified in [section 8.9.3][] is invoked with
the inputs prevRow and prevCol, and the output assigned to the variables
lvl, limit, blimit, and thresh.
      
For the variable i taking values from 0 to MI_SIZE - 1, the following applies:

  * If applyFilter is equal to 1 and lvl is greater than zero, the sample
      filtering process specified in [section 8.9.5][] is invoked with the input variable
      x set equal to xP + dy * i, the input variable y set equal to yP + dx * i,
      and the variables plane, limit, blimit, thresh, plane, dx, dy,
      filterSize.
      
  **Note:** the vector (dx,dy) represents the direction of the filter, while (dy,dx) represents the direction of the boundary.


#### Filter Size Process

The inputs to this process are:

  * a variable txSz specifying the size of the transform block,
  
  * a variable prevTxSz specifying the size of the transform block on the other side of the boundary,

  * a variable pass specifying the direction of the edges,

  * variables subX and subY describing the subsampling of the current plane,
  
  * a variable plane specifying whether we are filtering Y, U, or V samples.

The output of this process is the variable filterSize containing the maximum
filter size that can be used.

The purpose of this process is to reduce the width of the chroma filters and to ensure
that different boundaries can be filtered in parallel.

The variable baseSize is set equal to Min(prevTxSz, txSz).

The output variable filterSize is derived as follows:

  * If plane is equal to 0, filterSize is set equal to Min( TX_16X16, baseSize ),

  * Otherwise, (plane is greater than 0), filterSize is set
    equal to Min( TX_8X8, baseSize ).

#### Adaptive Filter Strength Process

The inputs to this process are the variables row and col specifying
the luma location in units of 4x4 blocks.

The outputs of this process are the variables lvl, limit, blimit, and thresh.

The output variable lvl is derived as follows:

  * The variable segment is set equal to SegmentIds[ row ][ col ].

  * The variable ref is set equal to RefFrames[ row ][ col ][ 0 ].

  * The variable mode is set equal to YModes[ row ][ col ].

  * The variable modeType is derived as follows:

    1. If mode is equal to NEARESTMV or NEARMV or NEWMV, modeType is set equal
       to 1.

    2. Otherwise (if mode is an intra type or ZEROMV or ZERO_ZEROMV), modeType is set equal
       to 0.

  * The variable baseFilterLevel is set equal to Clip3(0, MAX_LOOP_FILTER, DeltaLFs[ row ][ col ] + loop_filter_level).

  * The adaptive filter strength selection process specified in [section 8.9.4][] is invoked, with segment,
    ref, modeType, and baseFilterLevel as inputs, and the output being the output variable
    lvl.

The variable shift is derived as follows:

  * If loop_filter_sharpness is greater than 4, shift is set equal to 2.

  * Otherwise, if loop_filter_sharpness is greater than 0, shift is set equal
    to 1.

  * Otherwise, shift is set equal to 0.

The output variable limit is derived as follows:

  * If loop_filter_sharpness is greater than 0, limit is set equal to
    Clip3( 1, 9 - loop_filter_sharpness, lvl \>\> shift ).

  * Otherwise, limit is set equal to Max( 1, lvl \>\> shift ).

The output variable blimit is set equal to 2 * (lvl + 2) + limit.

The output variable thresh is set equal to lvl \>\> 4.


#### Adaptive Filter Strength Selection Process

The inputs to this process are:

 * The variable baseFilterLevel, indicating the base loop filter level for this block,
 
 * The variable segment, specifying the current segment id,
 
 * The variable ref, specifying the reference frame type (INTRA_FRAME, LAST_FRAME, etc.),
 
 * The variable modeType, specifying the loop filter mode type.

The output of this process is a filter strength level.

This process is invoked to select a loop filter strength level.

The following ordered steps apply:

  1. The variable nShift is set equal to baseFilterLevel \>\> 5.

  2. lvlSeg is set equal to baseFilterLevel.

  3. If seg_feature_active_idx( segment, SEG_LVL_ALT_L ) is equal to 1 the following
     ordered steps apply:

     a. If segmentation_abs_or_delta_update is equal to 1, lvlSeg is set equal
        to FeatureData[ segment ][ SEG_LVL_ALT_L ].

     b. If segmentation_abs_or_delta_update is equal to 0, lvlSeg is set equal
        to FeatureData[ segment ][ SEG_LVL_ALT_L ] + lvlSeg.

     c. lvlSeg is set equal to Clip3( 0, MAX_LOOP_FILTER, lvlSeg ).

  4. If loop_filter_delta_enabled is equal to 1, then the following ordered steps apply:

     a. If ref is equal to INTRA_FRAME, then lvlSeg is set equal to lvlSeg +
        ( loop_filter_ref_deltas[ INTRA_FRAME ] \<\< nShift ).
        
     b. Otherwise, if ref is not equal to INTRA_FRAME, then lvlSeg is set equal to
        lvlSeg +
        ( loop_filter_ref_deltas[ ref ] \<\< nShift ) +
        ( loop_filter_mode_deltas[ modeType ] \<\< nShift ).
        
     c. lvlSeg is set equal to Clip3(0, MAX_LOOP_FILTER, lvlSeg).

  5. Return lvlSeg.


#### Sample Filtering Process

The inputs to this process are:

  * variables x and y specifying the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables limit, blimit, thresh that specify the strength of the filtering
    operation,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered,

  * a variable filterSize of specifying the maximum size of filter allowed.

The outputs of this process are modified values in the array CurrFrame.

First the filter mask process specified in [section 8.9.5.1][] is invoked with the
inputs x, y, plane, limit, blimit, thresh, dx, dy, and filterSize, and the
output is assigned to the variables hevMask, filterMask, flatMask, and
flatMask2.

Then the appropriate filter process is invoked with the inputs x, y, plane,
dx, dy as follows:

  * If filterMask is equal to 0, no filter is invoked.

  * Otherwise, if filterSize is equal to TX_4X4 or flatMask is equal to 0, the
    narrow filter process specified in [section 8.9.5.2][] is invoked with the
    additional input variable hevMask.

  * Otherwise, if filterSize is equal to TX_8X8 or flatMask2 is equal to 0,
    the wide filter process specified in [section 8.9.5.3][] is invoked with the
    additional input variable log2Size set to 3.

  * Otherwise, the wide filter process specified in [section 8.9.5.3][] is invoked
    with the additional input variable log2Size set to 4.


##### Filter Mask Process

The inputs to this process are:

  * variables x and y specifying the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables limit, blimit, thresh that specify the strength of the filtering
    operation,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered,

  * a variable filterSize of specifying the maximum size of filter allowed.

The outputs from this process are the variables:

  * hevMask,

  * filterMask,

  * flatMask, (only used if filterSize >= TX_8X8),

  * flatMask2 (only used if filterSize >= TX_16X16).

The values output for these masks depend on the differences between samples on
either side of the specified boundary. These samples are specified as follows:

~~~~~ c
q0 = CurrFrame[ plane ][ y ][ x ]
q1 = CurrFrame[ plane ][ y+dy ][ x+dx ]
q2 = CurrFrame[ plane ][ y+dy*2 ][ x+dx*2 ]
q3 = CurrFrame[ plane ][ y+dy*3 ][ x+dx*3 ]
q4 = CurrFrame[ plane ][ y+dy*4 ][ x+dx*4 ]
q5 = CurrFrame[ plane ][ y+dy*5 ][ x+dx*5 ]
q6 = CurrFrame[ plane ][ y+dy*6 ][ x+dx*6 ]
q7 = CurrFrame[ plane ][ y+dy*7 ][ x+dx*7 ]
p0 = CurrFrame[ plane ][ y-dy ][ x-dx ]
p1 = CurrFrame[ plane ][ y-dy*2 ][ x-dx*2 ]
p2 = CurrFrame[ plane ][ y-dy*3 ][ x-dx*3 ]
p3 = CurrFrame[ plane ][ y-dy*4 ][ x-dx*4 ]
p4 = CurrFrame[ plane ][ y-dy*5 ][ x-dx*5 ]
p5 = CurrFrame[ plane ][ y-dy*6 ][ x-dx*6 ]
p6 = CurrFrame[ plane ][ y-dy*7 ][ x-dx*7 ]
p7 = CurrFrame[ plane ][ y-dy*8 ][ x-dx*8 ]
~~~~~

**Note:** Samples q4, q5, q6, q7, p4, p5, p6 and p7 are only used if
filterSize is equal to TX_16X16.

The value of hevMask indicates whether the sample has high edge variance. It
is calculated as follows:

~~~~~ c
hevMask = 0
threshBd = thresh << (BitDepth - 8)
hevMask |= (Abs( p1 - p0 ) > threshBd)
hevMask |= (Abs( q1 - q0 ) > threshBd)
~~~~~

The value of filterMask indicates whether adjacent samples close to the
edge (within four samples either side of the specified boundary) vary by less
than the limits given by limit and blimit. It is used to determine if any
filtering should occur and is calculated as follows:

~~~~~ c
limitBd = limit << (BitDepth - 8)
blimitBd = blimit << (BitDepth - 8)
mask = 0
mask |= (Abs( p3 - p2 ) > limitBd)
mask |= (Abs( p2 - p1 ) > limitBd)
mask |= (Abs( p1 - p0 ) > limitBd)
mask |= (Abs( q1 - q0 ) > limitBd)
mask |= (Abs( q2 - q1 ) > limitBd)
mask |= (Abs( q3 - q2 ) > limitBd)
mask |= (Abs( p0 - q0 ) * 2 + Abs( p1 - q1 ) / 2 > blimitBd)
filterMask = (mask == 0)
~~~~~

The value of flatMask is only required when filterSize >= TX_8X8. It measures
whether at least four samples from each side of the specified boundary are in
a flat region. That is whether those samples are at most (1 \<\< (BitDepth - 8))
different from the sample on the boundary. It is calculated as follows:

~~~~~ c
thresholdBd = 1 << (BitDepth - 8)
if ( filterSize >= TX_8X8 ) {
    mask = 0
    mask |= (Abs( p1 - p0 ) > thresholdBd)
    mask |= (Abs( q1 - q0 ) > thresholdBd)
    mask |= (Abs( p2 - p0 ) > thresholdBd)
    mask |= (Abs( q2 - q0 ) > thresholdBd)
    mask |= (Abs( p3 - p0 ) > thresholdBd)
    mask |= (Abs( q3 - q0 ) > thresholdBd)
    flatMask = (mask == 0)
}
~~~~~

The value of flatMask2 is only required when filterSize >= TX_16X16. It
measures whether at least eight samples from each side of the specified
boundary are in a flat region assuming the first four on each side are
(so the full region is flat if flatMask & flatMask2 == 0). The value of
flatMask2 is calculated as follows:

~~~~~ c
thresholdBd = 1 << (BitDepth - 8)
if ( filterSize >= TX_16X16 ) {
    mask = 0
    mask |= (Abs( p7 - p0 ) > thresholdBd)
    mask |= (Abs( q7 - q0 ) > thresholdBd)
    mask |= (Abs( p6 - p0 ) > thresholdBd)
    mask |= (Abs( q6 - q0 ) > thresholdBd)
    mask |= (Abs( p5 - p0 ) > thresholdBd)
    mask |= (Abs( q5 - q0 ) > thresholdBd)
    mask |= (Abs( p4 - p0 ) > thresholdBd)
    mask |= (Abs( q4 - q0 ) > thresholdBd)
    flatMask2 = (mask == 0)
}
~~~~~

##### Narrow Filter Process

The inputs to this filter are:

  * a variable hevMask specifying whether this is a high edge variance case,

  * variables x, y specifying the the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables limit, blimit, thresh that specify the strength of the filtering
    operation,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered.

This process modifies up to two samples on each side of the specified boundary
depending on the value of hevMask as follows:

  * If hevMask is equal to 0 (i.e. the samples do not have high edge
    variance), this process modifies two samples on each side of the specified
    boundary, using a filter constructed from just the inner two (one from
    each side of the specified boundary).

  * Otherwise (the samples do have high edge variance), this process only
    modifies the one value on each side of the specified boundary, using a
    filter constructed from four input samples (two from each side of the
    specified boundary).

The process subtracts 0x80 \<\< (BitDepth - 8) from the input sample values so
that they are in the range -(1 \<\< (BitDepth - 1))
to (1 \<\< (BitDepth - 1)) - 1 inclusive. Intermediate values are made to be in
this range by the following function:

~~~~~ c
filter4_clamp( value ) {
    return Clip3( -(1 << (BitDepth - 1)), (1 << (BitDepth - 1)) - 1, value )
}
~~~~~

The process is specified as follows:

~~~~~ c
q0 = CurrFrame[ plane ][ y ][ x ]
q1 = CurrFrame[ plane ][ y+dy ][ x+dx ]
p0 = CurrFrame[ plane ][ y-dy ][ x-dx ]
p1 = CurrFrame[ plane ][ y-dy*2 ][ x-dx*2 ]
ps1 = p1 - (0x80 << (BitDepth - 8))
ps0 = p0 - (0x80 << (BitDepth - 8))
qs0 = q0 - (0x80 << (BitDepth - 8))
qs1 = q1 - (0x80 << (BitDepth - 8))
filter = hevMask ? filter4_clamp( ps1 - qs1 ) : 0
filter = filter4_clamp( filter + 3 * (qs0 - ps0) )
filter1 = filter4_clamp( filter + 4 ) >> 3
filter2 = filter4_clamp( filter + 3 ) >> 3
oq0 = filter4_clamp( qs0 - filter1 ) + (0x80 << (BitDepth - 8))
op0 = filter4_clamp( ps0 + filter2 ) + (0x80 << (BitDepth - 8))
CurrFrame[ plane ][ y ][ x ] = oq0
CurrFrame[ plane ][ y-dy ][ x-dx ] = op0
if ( !hevMask ) {
    filter = Round2( filter1, 1 )
    oq1 = filter4_clamp( qs1 - filter ) + (0x80 << (BitDepth - 8))
    op1 = filter4_clamp( ps1 + filter ) + (0x80 << (BitDepth - 8))
    CurrFrame[ plane ][ y+dy ][ x+dx ] = oq1
    CurrFrame[ plane ][ y-dy*2 ][ x-dx*2 ] = op1
}
~~~~~

##### Wide Filter Process

The inputs to this filter are:

  * variables x, y specifying the the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered,

  * a variable log2Size specifying the base 2 logarithm of the number of taps.

This filter is only applied when samples from each side of the boundary are
detected to be in a flat region.

The variable n (specifying the number of filter taps on each side of the
central sample) is set equal to (1 \<\< ( log2Size - 1 ) ) - 1.

This process modifies the samples on each side of the specified boundary by
applying a low pass filter as follows:

~~~~~ c
for( i = -n; i < n; i++ ) {
    t = CurrFrame[ plane ][ y+i*dy ][ x+i*dx ]
    for( j = -n; j <= n; j++ ) {
        p = Clip3( -(n+1), n, i+j )
        t += CurrFrame[ plane ][ y+p*dy ][ x+p*dx ]
    }
    F[ i ] = Round2( t, log2Size )
}
for( i = -n; i < n; i++ )
    CurrFrame[ plane ][ y+i*dy ][ x+i*dx ] = F[ i ]
~~~~~

where F is an array with indices from -n to n-1 used to store the filtered
results.


### Output Process

This process is invoked to optionally display a frame.

If show_existing_frame is equal to 1, then the decoder should output a previously decoded frame as follows:

  * The variable w is set equal to RefFrameWidth[ frame_to_show_map_idx ].

  * The variable h is set equal to RefFrameHeight[ frame_to_show_map_idx ].

  * The variable subX is set equal to RefSubsamplingX[ frame_to_show_map_idx ].

  * The variable subY is set equal to RefSubsamplingY[ frame_to_show_map_idx ].

  * The Y plane is w samples across by h samples down and the sample at
    location x samples across and y samples down is given by
    FrameStore[ frame_to_show_map_idx ][ 0 ][ y ][ x ] with x = 0..w - 1
    and y = 0..h - 1.

  * The U plane is (w + subX) \>\> subX samples across by (h + subY) \>\> subY
    samples down and the sample at location x samples across and y samples
    down is given by FrameStore[ frame_to_show_map_idx ][ 1 ][ y ][ x ]
    with x = 0..((w + subX) \>\> subX) - 1 and y = 0..((h + subY) \>\> subY) - 1.

  * The V plane is (w + subX) \>\> subX samples across by (h + subY) \>\> subY
    samples down and the sample at location x samples across and y samples
    down is given by FrameStore[ frame_to_show_map_idx ][ 2 ][ x ][ y ]
    with x = 0..((w + subX) \>\> subX) - 1 and y = 0..((h + subY) \>\> subY) - 1.

  * The bit depth for each sample is RefBitDepth[ frame_to_show_map_idx ].
    Otherwise, if show_frame is equal to 1, then the decoder should output the
    current frame as follows:

  * The variable w is set equal to FrameWidth.

  * The variable h is set equal to FrameHeight.

  * The variable subX is set equal to subsampling_x.

  * The variable subY is set equal to subsampling_y.

  * The Y plane is w samples across by h samples down and the sample at
    location x samples across and y samples down is given by
    CurrFrame[ 0 ][ y ][ x ] with x = 0..w - 1 and y = 0..h - 1.

  * The U plane is (w + subX) \>\> subX samples across by (h + subY) \>\> subY
    samples down and the sample at location x samples across and y samples
    down is given by CurrFrame[ 1 ][ y ][ x ]
    with x = 0..((w + subX) \>\> subX) - 1 and y = 0..((h + subY) \>\> subY) - 1.

  * The V plane is (w + subX) \>\> subX samples across by (h + subY) \>\> subY
    samples down and the sample at location x samples across and y samples
    down is given by CurrFrame[ 2 ][ x ][ y ]
    with x = 0..((w + subX) \>\> subX) - 1 and y = 0..((h + subY) \>\> subY) - 1.

  * The bit depth for each sample is BitDepth.


### Reference Frame Update Process

This process is invoked as the final step in decoding a frame.

The inputs to this process are the samples in the current frame
CurrFrame[ plane ][ x ][ y ].

The output from this process is an updated set of reference frames and
previous motion vectors.

The following ordered steps apply:

  1. For each value of i from 0 to NUM_REF_FRAMES - 1, the following applies
     if bit i of refresh_frame_flags is equal to 1 (i.e.
     if (refresh_frame_flags \>\> i) & 1 is equal to 1):

     * RefFrameWidth[ i ] is set equal to FrameWidth.

     * RefFrameHeight[ i ] is set equal to FrameHeight.

     * RefSubsamplingX[ i ] is set equal to subsampling_x.

     * RefSubsamplingY[ i ] is set equal to subsampling_y.

     * RefBitDepth[ i ] is set equal to BitDepth.

     * FrameStore[ i ][ 0 ][ y ][ x ] is set equal to CurrFrame[ 0 ][ y ][ x ]
       for x = 0..FrameWidth-1, for y = 0..FrameHeight-1.

     * FrameStore[ i ][ plane ][ y ][ x ] is set equal to
       CurrFrame[ plane ][ y ][ x ] for plane = 1..2,
       for x = 0..((FrameWidth + subsampling_x) \>\> subsampling_x) - 1,
       for y = 0..((FrameHeight + subsampling_y) \>\> subsampling_y) - 1.

  2. If show_existing_frame is equal to 0, the following applies:

     * PrevRefFrames[ row ][ col ][ list ] is set equal to
       RefFrames[ row ][ col ][ list ] for row = 0..MiRows-1,
       for col = 0..MiCols-1, for list = 0..1.

     * PrevMvs[ row ][ col ][ list ][ comp ] is set equal to
       Mvs[ row ][ col ][ list ][ comp ] for row = 0..MiRows-1,
       for col = 0..MiCols-1, for list = 0..1, for comp = 0..1.
       
     * PrevPredMvs[ row ][ col ][ list ][ comp ] is set equal to
       PredMvs[ row ][ col ][ list ][ comp ] for row = 0..MiRows-1,
       for col = 0..MiCols-1, for list = 0..1, for comp = 0..1.
