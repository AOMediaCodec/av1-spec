## Decoding Process


### General

Decoders shall produce output frames that are identical in all respects and have the same output order as
those produced by the decoding process specified herein.

The input to this process is a sequence of coded frames.

The output from this process is a sequence of decoded frames.

For each coded frame in turn the decoding process operates as follows:

  1. The syntax elements for the coded frame are extracted as specified in
     sections 6 and 7. The syntax tables include function calls indicating
     when the block decode processes are triggered.

  2. If loop_filter_level is not equal to 0, the loop filter process as
     specified in section 8.8 is invoked once the coded frame has been decoded.

  3. If all of the following conditions are true, PrevSegmentIds[ row ][ col ]
     is set equal to SegmentIds[ row ][ col ] for row = 0..MiRows-1, for
     col = 0..MiCols-1:

     * show_existing_frame is equal to 0,

     * segmentation_enabled is equal to 1,

     * segmentation_update_map is equal to 1.

  4. The output process as specified in section 8.9 is invoked.

  5. The reference frame update process as specified in section 8.10 is
     invoked.


### Frame Order Constraints

This section describes additional constraints on a bitstream that result from
the choice of frame types.

If a sequence starts with a key frame, then the additional constraints are
automatically satisfied.

Otherwise, the sequence can start with a number of non key frames (i.e. inter
frames and intra only frames) and extra care has to be taken to ensure that
the decoding process is well defined. It is a requirement of bitstream
conformance that the following applies:

  * When load_probs( ctx ) is invoked, this must load an initialized set of
    probabilities, i.e. there must have been an earlier invocation of
    save_probs( ctx ).

  * When ref_frame_idx[ i ] is decoded, it must identify an initialized
    reference frame, i.e. there must have been an earlier decoded frame which
    had (refresh_frame_flags>>ref_frame_idx[ i ])&1 equal to 1.

**Note:** This constraint means that the first coded frame cannot be an inter
frame.


### Clear Counts Process

This process is triggered when the function clear_counts is invoked during the
syntax decode of the frame described in section 6.1.

The following arrays store the number of times each value of a particular
syntax element has been decoded in a particular context.

~~~~~ c
counts_intra_mode[BLOCK_SIZE_GROUPS][INTRA_MODES]
counts_uvMode [INTRA_MODES][INTRA_MODES]
counts_partition[PARTITION_CONTEXTS][PARTITION_TYPES]
counts_interp_filter[INTERP_FILTER_CONTEXTS][INTERP_FILTERS]
counts_inter_mode[INTER_MODE_CONTEXTS][INTER_MODES]
counts_tx_size[TX_SIZES][TX_SIZE_CONTEXTS][TX_SIZES]
counts_is_inter[IS_INTER_CONTEXTS][2]
counts_comp_mode[COMP_MODE_CONTEXTS][2]
counts_single_ref[REF_CONTEXTS][2][2]
counts_comp_ref[REF_CONTEXTS][2]
counts_skip[SKIP_CONTEXTS][2]
counts_mv_joint[MV_JOINTS]
counts_mv_sign[2][2]
counts_mv_class[2][MV_CLASSES]
counts_mv_class0_bit[2][CLASS0_SIZE]
counts_mv_class0_fr[2][CLASS0_SIZE][MV_FR_SIZE]
counts_mv_class0_hp[2][2]
counts_mv_bits[2][MV_OFFSET_BITS][2]
counts_mv_fr[2][MV_FR_SIZE]
counts_mv_hp[2][2]
counts_token[TX_SIZES][BLOCK_TYPES][REF_TYPES][COEF_BANDS]
            [PREV_COEF_CONTEXTS][UNCONSTRAINED_NODES]
counts_segment_id[ MAX_SEGMENTS ]
counts_seg_node_predicted[ 3 ][ 2 ]
counts_seg_node_mispredicted[ MAX_SEGENTS ]
counts_more_coefs[TX_SIZES][BLOCK_TYPES][REF_TYPES][COEF_BANDS]
                 [PREV_COEF_CONTEXTS][2]
~~~~~

The numbers in square brackets define the size of each dimension of the array.

When the clear counts process is invoked, all of these counts are set equal to
0.

This process also creates arrays to accumulate the CDF values at the end of each tile.
An array of the same size is made of each of the CDF arrays mentioned in the semantics for setup_past_independence.
The name of the new array is the name of the CDF array prefixed with "Sum".  This process produces the following arrays:

  * SumPartitionCdf

  * SumSegmentIdCdf

  * SumTx8x8Cdf

  * SumTx16x16Cdf

  * SumTx32x32Cdf

  * SumInterpFilterCdf

  * SumMvJointCdf

  * SumMvClassCdf

  * SumMvFrCdf

  * SumMvClass0FrCdf

  * SumTailTokenCdf

  * SumAcHeadTokenCdf

  * SumDcHeadTokenCdf

When the clear counts process is invoked, every element of each of these arrays is set equal to 0.


### Probability Adaptation Process

This section defines processes used to perform backward updates of
probabilities based on the observed frequencies of different syntax elements.

These processes are triggered at points defined by function calls in the
refresh probs syntax table in section 6.1.2.

The processes make use of the functions merge_prob and merge_probs that are
specified next.


#### Merge Prob Process

The inputs to this process are:

  * a variable preProb specifying the original probability for a boolean,

  * variables ct0 and ct1 specifying the number of times the boolean was
    decoded as 0 and 1,

  * a variable countSat indicating how many times the boolean needs to be
    decoded for the maximum adaption to apply,

  * a variable maxUpdateFactor specifying the maximum amount the probability
    can be adjusted.

The output is a variable outProb containing the updated probability.
The variable den representing the total times this boolean has been decoded is set equal to ct0 + ct1.

The variable prob estimating the probability that the boolean is decoded as a 0 is set equal to (den == 0) ?
128 : Clip3( 1, 255, (ct0 * 256 + (den >> 1)) / den ).
The variable count is set equal to Min( ct0 + ct1, countSat ).
The variable factor is set equal to maxUpdateFactor * count / countSat.
The return variable outProb is set equal to Round2( preProb * (256 - factor) + prob * factor, 8 ).

#### Merge Probs Process

The inputs to this process are:

  * an array tree specifying the decode tree for a syntax element,

  * a variable i specifying the current location in the decode tree,

  * an array probs specifying the original probabilities for decoding the
    syntax element,

  * an array counts containing the number of times each value for the syntax
    element was decoded,

  * a variable countSat indicating how many times the boolean needs to be
    decoded for the maximum adaption to apply,

  * a variable maxUpdateFactor specifying the maximum amount the probability
    can be adjusted.

The outputs of this process are adjustments made to the input array named probs, and a return value
containing the total number of times this boolean was decoded.
The process is specified as follows:
merge_probs( tree, i, probs, counts, countSat, maxUpdateFactor ) {
 s = tree[ i ]
 leftCount = (s <= 0) ? counts[ -s ] :
 merge_probs( tree, s, probs, counts, countSat, maxUpdateFactor )
 r = tree[ i + 1 ]
 rightCount = (r <= 0) ? counts[ -r ] :
 merge_probs( tree, r, probs, counts, countSat, maxUpdateFactor )
 probs[ i >> 1 ] =
 merge_prob( probs[ i >> 1 ], leftCount, rightCount, countSat, maxUpdateFactor )
 return leftCount + rightCount
}


#### Coefficient Probability Adaption Process

This process is triggered when the function adapt_coef_probs is called from the refresh probs syntax table.
The variable updateFactor is set according to the type of this frame and the previous frame as follows:

  * If FrameIsIntra is equal to 1, updateFactor is set equal to 112.

  * Otherwise if LastFrameType is equal to KEY_FRAME, updateFactor is set
    equal to 128.

  * Otherwise, updateFactor is set equal to 112.

Then the coefficient probabilities are updated as follows:

~~~~~ c
for ( t = 0; t < 4; t++ )
    for ( i = 0; i < 2; i++ )
        for ( j = 0; j < 2; j++ )
            for ( k = 0; k < 6; k++ ) {
                maxL = (k == 0) ? 3 : 6
                for ( l = 0; l < maxL; l++ ) {
                    merge_probs( small_token_tree, 2,
                        coef_probs[ t ][ i ][ j ][ k ][ l ],
                        counts_token[ t ][ i ][ j ][ k ][ l ],
                        24, updateFactor )
                    merge_probs( binary_tree, 0,
                        coef_probs[ t ][ i ][ j ][ k ][ l ],
                        counts_more_coefs[ t ][ i ][ j ][ k ][ l ],
                        24, updateFactor )
                }
            }
~~~~~

where small_token_tree is defined as:

~~~~~ c
small_token_tree[ 6 ] = {
    0, 0, // Unused
    -ZERO_TOKEN, 4,
    -ONE_TOKEN, -TWO_TOKEN
}
~~~~~


#### Non Coefficient Probability Adaption Process

This process is triggered when the function adapt_noncoef_probs is called from
the refresh probs syntax table.

The probabilities are updated as follows:

~~~~~ c
for ( i = 0; i < IS_INTER_CONTEXTS; i++ )
    isInterProb[ i ] = adapt_prob( isInterProb[ i ], counts_is_inter[ i ] )
for ( i = 0; i < COMP_MODE_CONTEXTS; i++ )
    compModeProb[ i ] = adapt_prob( compModeProb[ i ], counts_comp_mode[ i ] )
for ( i = 0; i < REF_CONTEXTS; i++ )
    compRefProb[ i ] = adapt_prob( compRefProb[ i ], counts_comp_ref[ i ] )
for ( i = 0; i < REF_CONTEXTS; i++ )
    for ( j = 0; j < 2; j++ )
        singleRefProb[ i ][ j ] = adapt_prob( singleRefProb[ i ][ j ], counts_single_ref[ i ][ j ] )
for ( i = 0; i < INTER_MODE_CONTEXTS; i++ )
    adapt_probs( inter_mode_tree, interModeProbs[ i ], counts_inter_mode[ i ] )
for ( i = 0; i < BLOCK_SIZE_GROUPS; i++ )
    adapt_probs( intra_mode_tree, yModeProbs[ i ], counts_intra_mode[ i ] )
for ( i = 0; i < SKIP_CONTEXTS; i++ )
    skipProb[ i ] = adapt_prob( skipProb[ i ], counts_skip[ i ] )
if ( interpolation_filter == SWITCHABLE ) {
    for ( i = 0; i < INTERP_FILTER_CONTEXTS; i++ )
        adapt_probs( interp_filter_tree, interpFilterProbs[ i ], counts_interp_filter[ i ] )
}
if ( TxMode == TX_MODE_SELECT ) {
    for ( i = 0; i < TX_SIZE_CONTEXTS; i++ ) {
        adapt_probs( tx_size_8_tree, tx_probs[ TX_8X8 ][ i ], counts_tx_size[ TX_8X8 ][ i ] )
        adapt_probs( tx_size_16_tree,tx_probs[ TX_16X16 ][ i ],counts_tx_size[ TX_16X16 ][ i ] )
        adapt_probs( tx_size_32_tree,tx_probs[ TX_32X32 ][ i ],counts_tx_size[ TX_32X32 ][ i ] )
    }
}
adapt_probs( mv_joint_tree, mvJointProbs, counts_mv_joint )
for ( i = 0; i < 2; i++ ) {
    mvSignProb[ i ] = adapt_prob( mvSignProb[ i ], counts_mv_sign[ i ] )
    adapt_probs( mv_class_tree, mvClassProbs[ i ], counts_mv_class[ i ] )
    mvClass0BitProb[ i ] = adapt_prob( mvClass0BitProb[ i ], counts_mv_class0_bit[ i ] )
    for ( j = 0; j < MV_OFFSET_BITS; j++ )
        mvBitsProb[ i ][ j ] = adapt_prob( mvBitsProb[ i ][ j ], counts_mv_bits[ i ][ j ] )
    for ( j = 0; j < CLASS0_SIZE; j++ )
        adapt_probs( mv_fr_tree, mvClass0FrProbs[ i ][ j ], counts_mv_class0_fr[ i ][ j ] )
    adapt_probs( mv_fr_tree, mvFrProbs[ i ], counts_mv_fr[ i ] )
    if ( allow_high_precision_mv ) {
        mvClass0HpProb[ i ] = adapt_prob( mvClass0HpProb[ i ], counts_mv_class0_hp[ i ] )
        mvHpProb[ i ] = adapt_prob( mvHpProb[ i ], counts_mv_hp[ i ] )
    }
    If ( segmentation_temporal_update ) {
        for ( i = 0; i < 3; i++ )
            merge_probs( SegmentationPredProbs[ i ], counts_seg_node_predicted[ i ] )
        adapt_probs( segment_tree, SegmentTreeProbs, counts_seg_node_mispredicted )
    } else {
        adapt_probs( segment_tree, SegmentTreeProbs, counts_ segment_id )
    }
}
~~~~~

where adapt_probs is specified as:

~~~~~ c
adapt_probs( tree, probs, counts ) {
    merge_probs( tree, 0, probs, counts, COUNT_SAT, MAX_UPDATE_FACTOR )
}
~~~~~

and adapt_prob is specified as:

~~~~~ c
adapt_prob( prob, counts ) {
    return merge_prob( prob, counts[ 0 ], counts[ 1 ], COUNT_SAT, MAX_UPDATE_FACTOR )
}
~~~~~

#### CDF Averaging Process

This process is triggered when the function average_cdf is called from
the refresh probs syntax table.

The frame CDF arrays are set equal to the average of the tile CDF arrays as follows (in this code, the operations apply to each element of the arrays in turn):

~~~~~ c
PartitionCdf = SumPartitionCdf / NumTiles
SegmentIdCdf = SumSegmentIdCdf / NumTiles
Tx8x8Cdf = SumTx8x8Cdf / NumTiles
Tx16x16Cdf = SumTx16x16Cdf / NumTiles
Tx32x32Cdf = SumTx32x32Cdf / NumTiles
InterpFilterCdf = SumInterpFilterCdf / NumTiles
MvJointCdf = SumMvJointCdf / NumTiles
MvClassCdf = SumMvClassCdf / NumTiles
MvFrCdf = SumMvFrCdf / NumTiles
MvClass0FrCdf = SumMvClass0FrCdf / NumTiles
TailTokenCdf = SumTailTokenCdf / NumTiles
AcHeadTokenCdf = SumAcHeadTokenCdf / NumTiles
DcHeadTokenCdf = SumDcHeadTokenCdf / NumTiles
~~~~~


### Prediction Processes

The following sections define the processes used for predicting the sample
values.

These processes are triggered at points defined by function calls to
predict_intra and predict_inter in the residual syntax table described in
section 6.4.21.


#### Intra Prediction Process

The intra prediction process is invoked for intra coded blocks to predict a
part of the block corresponding to a transform block. When the transform size
is smaller than the block size, this process can be invoked multiple times
within a single block for the same plane, and the invocations are in raster
order within the block.

The inputs to this process are:

  * the already reconstructed samples in the current frame CurrFrame,

  * a variable plane specifying which plane is being predicted,

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the current transform block,

  * a variable haveLeft that is equal to 1 if there are valid samples to the
    left of this transform block,

  * a variable haveAbove that is equal to 1 if there are valid samples above
    this transform block,

  * a variable notOnRight that is equal to 1 if the transform block is not on
    the right edge of the block,

  * a variable txSz, specifying the size of the transform block,

  * a variable blockIdx, specifying how much of the block has already been
    predicted in units of 4x4 samples.

The outputs of this process are intra predicted samples in the current frame
CurrFrame.

The variable mode is specified by:

  * If plane is greater than 0, mode is set equal to uvMode .

  * Otherwise, if MiSize is greater than or equal to BLOCK_8X8, mode is set
    equal to yMode.

  * Otherwise, mode is set equal to sub_modes[ blockIdx ].

The variable log2Size specifying the base 2 logarithm of the width of the
transform block is set equal to txSz + 2.

The variable size is set equal to 1 << log2Size.

The variable maxX is set equal to (MiCols * 8) - 1.

The variable maxY is set equal to (MiRows * 8) - 1.

If plane is greater than 0, then:

  * maxX is set equal to ((MiCols * 8) >> subsampling_x) - 1.

  * maxY is set equal to ( (MiRows * 8) >> subsampling_y) - 1.

The array aboveRow[ i ] for i = 0..size-1 is specified by:

  * If haveAbove is equal to 0, aboveRow[ i ] is set equal to
    (1<<(BitDepth-1)) - 1.

  * Otherwise, aboveRow[ i ] is set equal to
    CurrFrame[ plane ][ y-1 ][ Min(maxX, x+i) ].

The array aboveRow[ i ] for i = size..2*size-1 is specified by:

  * If haveAbove is equal to 1 and notOnRight is equal to 1 and txSz is equal
    to 0, aboveRow[ i ] is set equal to
    CurrFrame[ plane ][ y-1 ][ Min(maxX, x+i) ].

  * Otherwise, aboveRow[ i ] is set equal to aboveRow[ size-1 ].

The array aboveRow[ i ] for i = -1 is specified by:

  * If haveAbove is equal to 1 and haveLeft is equal to 1, aboveRow[ -1 ] is
    set equal to CurrFrame[ plane ][ y-1 ][ Min(maxX, x-1) ].

  * Otherwise if haveAbove is equal to 1, aboveRow[ -1] is set equal to
    (1<<(BitDepth-1)) + 1.

  * Otherwise, aboveRow[ -1 ] is set equal to (1<<(BitDepth-1)) - 1.

The array leftCol[ i ] for i = 0..size-1 is specified by:

  * If haveLeft is equal to 1, leftCol[ i ] is set equal to
    CurrFrame[ plane ][ Min(maxY, y+i) ][ x-1 ].

  * Otherwise, leftCol[ i ] is set equal to (1<<(BitDepth-1)) + 1.

A 2D array named pred containing the intra predicted samples is constructed as follows:

  * If mode is equal to V_PRED, pred[ i ][ j ] is set equal to aboveRow[ j ]
    with j = 0..size-1 and i = 0..size-1 (each row of the block is filled with
    a copy of aboveRow).

  * Otherwise if mode is equal to H_PRED, pred[ i ][ j ] is set equal to
    leftCol[ i ] with j = 0..size-1 and i = 0..size-1 (each column of the
    block is filled with a copy of leftCol).

  * Otherwise if mode is equal to D207_PRED, the following applies:

    1. pred[ i ][ j ] = Round2( leftCol[ i + j/2 ] +
       leftCol[ I + 1 + j/2 ], 1 ) for even values of i in the
       range 0..size-2

    2. pred[ i ][ j ] = Round2( leftCol[ i + j/2 ] + 2 *
       leftCol[ i + 1 + j/2 ] + leftCol[ I + 2 + j/2 ], 2 ) for odd values
       of i in the range 0..size-1

  * Otherwise if mode is equal to D45_PRED, the following applies:

    1. pred[ i ][ j ] = Round2( aboveRow[ i + j ] + 2 *
       aboveRow[ i + j + 1 ] + aboveRow[ i + j + 1 ], 2 )
       if (i + j + 1 >= 2 * size)

    2. pred[ i ][ j ] = Round2( aboveRow[ i + j ] + 2 *
       aboveRow[ i + j + 1 ] + aboveRow[ i + j + 2 ], 2 )
       if (i + j + 1 < 2 * size)

  * Otherwise if mode is equal to D63_PRED, the following applies:

    1. pred[ i ][ j ] = Round2( aboveRow [ i/2 + j ] +
       aboveRow [ I/2 + j + 1 ], 1 ) for even values of j in the
       range 0..size-2

    2. pred[ i ][ j ] = Round2( aboveRow [ i/2 + j ] + 2 *
       aboveRow [ i/2 + j + 1 ] + aboveRow [ I/2 + j + 2, 2 )
       for odd values of j in the range 0..size-1.

  * Otherwise if mode is equal to D117_PRED, the following applies:

    1. pred[ 0 ][ j ] = Round2( aboveRow[ j - 1 ] + aboveRow[ j ], 1 )
       for j = 0..size-1

    2. pred[ 1 ][ 0 ] = Round2( leftCol[ 0 ] + 2 * aboveRow[ -1 ] +
       aboveRow[ 0 ], 2 )

    3. pred[ 1 ][ j ] = Round2( aboveRow[ j - 2 ] + 2 * aboveRow[ j - 1 ] +
       aboveRow[ j ], 2 ) for j = 1..size-1

    4. pred[ 2 ][ 0 ] = Round2( aboveRow[ -1 ] + 2 * leftCol[ 0 ] +
       leftCol[ 1 ], 2 )

    5. pred[ i ][ 0 ] = Round2( leftCol[ i - 3 ] + 2 * leftCol[ i - 2 ] +
       leftCol[ i - 1 ], 2 ) for i = 3..size-1

    6. pred[ i ][ j ] = pred[ i - 2 ][ j - 1 ] for i = 2..size-1,
       for j = 1..size-1

  * Otherwise if mode is equal to D135_PRED, the following applies:

    1. pred[ 0 ][ 0 ] = Round2( leftCol[ 0 ] + 2 * aboveRow[ -1 ] +
       aboveRow[ 0 ], 2 )

    2. pred[ 0 ][ j ] = Round2( aboveRow[ j - 2 ] + 2 * aboveRow[ j - 1 ] +
       aboveRow[ j ], 2 ) for j = 1..size-1

    3. pred[ 1 ][ 0 ] = Round2( aboveRow [ -1 ] + 2 * leftCol[ 0 ] +
       leftCol[ 1 ], 2 ) for i = 1..size-1

    4. pred[ i ][ 0 ] = Round2( leftCol[ i - 2 ] + 2 * leftCol[ i - 1 ] +
       leftCol[ i ], 2 ) for i = 2..size-1

    5. pred[ i ][ j ] = pred[ i - 1 ][ j - 1 ] for i = 1..size-1,
       for j = 1..size-1

  * Otherwise if mode is equal to D153_PRED, the following applies:

    1. pred[ 0 ][ 0 ] = Round2( leftCol[ 0 ] + aboveRow[ -1 ], 1 )

    2. pred[ i ][ 0 ] = Round2( leftCol[ i - 1] + leftCol[ i ], 1 )
       for i = 1..size-1

    3. pred[ 0 ][ 1 ] = Round2( leftCol[ 0 ] + 2 * aboveRow[ -1 ] +
       aboveRow[ 0 ], 2 )

    4. pred[ 1 ][ 1 ] = Round2( aboveRow[ -1 ] + 2 * leftCol [ 0 ] +
       leftCol [ 1 ], 2 )

    5. pred[ i ][ 1 ] = Round2( leftCol[ i - 2 ] + 2 * leftCol[ i - 1 ] +
       leftCol[ i ], 2 ) for i = 2..size-1

    6. pred[ 0 ][ j ] = Round2( aboveRow[ j - 3 ] + 2 * aboveRow[ j - 2 ] +
       aboveRow[ j - 1 ], 2 ) for j = 2..size-1

    7. pred[ i ][ j ] = pred[ i - 1 ][ j - 2 ] for i = 1..size-1,
       for j = 2..size-1

  * Otherwise if mode is equal to TM_PRED, pred[ i ][ j ] is set equal to
    Clip1( aboveRow[ j ] + leftCol[ i ] - aboveRow[ -1 ] ) for i = 0..size-1,
    for j = 0..size-1.

  * Otherwise if mode is equal to DC_PRED and haveLeft is equal to 1 and
    haveAbove is equal to 1, pred[ i ][ j ] is set equal to avg with
    i = 0..size-1 and j = 0..size-1. The variable avg (the average of the
    samples in union of aboveRow and leftCol) is specified as follows:

    ~~~~~ c
    sum = 0
    for ( k = 0; k < size; k++ ) {
        sum += leftCol[ k ]
        sum += aboveRow[ k ]
    }
    avg = (sum + size) >> (log2Size + 1)
    ~~~~~

  * Otherwise if mode is equal to DC_PRED and haveLeft is equal to 1 and
    haveAbove is equal to 0, pred[ i ][ j ] is set equal to leftAvg with
    i = 0..size-1 and j = 0..size-1. The variable leftAvg is specified as
    follows:

    ~~~~~ c
    sum = 0
    for ( k = 0; k < size; k++ ) {
        sum += leftCol[ k ]
    }
    leftAvg = (sum + (1 << (log2Size - 1) ) ) >> log2Size
    ~~~~~

  * Otherwise if mode is equal to DC_PRED and haveLeft is equal to 0 and
    haveAbove is equal to 1, pred[ i ][ j ] is set equal to aboveAvg with
    i = 0..size-1 and j = 0..size-1. The variable aboveAvg is specified
    as follows:

    ~~~~~ c
    sum = 0
    for ( k = 0; k < size; k++ ) {
        sum += aboveRow[ k ]
    }
    aboveAvg = (sum + (1 << (log2Size - 1) ) ) >> log2Size
    ~~~~~

  * Otherwise (mode is DC_PRED), pred[ i ][ j ] is set equal
    to 1<<(BitDepth - 1) with i = 0..size-1 and j = 0..size-1.

The current frame is updated as follows:

  * CurrFrame[ plane ][ y + i ][ x + j ] is set equal to pred[ i ][ j ]
    for i = 0..size-1 and j = 0..size-1.


#### Inter Prediction Process

The inter prediction process is invoked for inter coded blocks. When MiSize is
smaller than BLOCK_8X8, the prediction is done with a granularity of 4x4
samples, otherwise the whole plane is predicted at the same time. The inputs
to this process are:

  * a variable plane specifying which plane is being predicted,

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the region to be predicted,

  * variables w and h specifying the width and height of the region to be
    predicted,

  * a variable blockIdx, specifying how much of the block has already been
    predicted in units of 4x4 samples. The outputs of this process are inter
    predicted samples in the current frame CurrFrame. The variable isCompound
    is set equal to refFrame[ 1 ] > NONE. The prediction arrays are formed by
    the following ordered steps:

      1. The variable refList is set equal to 0.

      2. The motion vector selection process in section 8.5.2.1 is invoked
         with plane, refList, blockIdx as inputs and the output being the
         motion vector mv.

      3. The motion vector clamping process in section 8.5.2.2 is invoked with
         plane, mv as inputs and the output being the clamped motion vector
         clampedMv

      4. The motion vector scaling process in section 8.5.2.3 is invoked with
         plane, refList, x, y, clampedMv as inputs and the output being the
         initial location startX, startY, and the step sizes stepX, stepY.

      5. The block inter prediction process in section 8.5.2.4 is invoked with
         plane, refList, startX, startY, stepX, stepY, w, h as inputs and the
         output is assigned to the 2D array preds[ refList ].

      6. If isCompound is equal to 1, then the variable refList is set equal
         to 1 and steps 2, 3, 4 and 5 are repeated to form the prediction for
         the second reference. The inter predicted samples are then derived as
         follows:

         * If isCompound is equal to 0, CurrFrame[ plane ][ y + i ][ x + j ]
           is set equal to Clip1( Round2( preds[ 0 ][ i ][ j ], 9) ) for i = 0..h-1 and j = 0..w-1.

         * Otherwise, CurrFrame[ plane ][ y + i ][ x + j ] is set equal to
           Clip1( Round2( preds[ 0 ][ i ][ j ] + preds[ 1 ][ i ][ j ], 10 ) )
           for i = 0..h-1 and j = 0..w-1.


##### Motion Vector Selection Process

The inputs to this process are:

  * a variable plane specifying which plane is being predicted,

  * a variable refList specifying that we should select the motion vector from
    BlockMvs[ refList ],

  * a variable blockIdx, specifying how much of the block has already been
    predicted in units of 4x4 samples. The output of this process
    is a 2 element array called mv containing the motion vector for this
    block. The purpose of this process is to find the motion vector for this
    block. Motion vectors are specified for each luma block, but a chroma
    block may cover more than one luma block due to subsampling. In this case,
    an average motion vector is constructed for the chroma block. The motion
    vector array mv is derived as follows:

FIXME

  * If plane is equal to 0, or MiSize is greater than or equal to BLOCK_8X8,
    mv is set equal to BlockMvs[ refList ][ blockIdx ].

  * Otherwise, if subsampling_x is equal to 0 and subsampling_y is equal to 0,
    mv is set equal to BlockMvs[ refList ][ blockIdx ].

  * Otherwise, if subsampling_x is equal to 0 and subsampling_y is equal to 1,
    mv[ comp ] is set equal to round_mv_comp_q2(
    BlockMvs[ refList ][ blockIdx ][ comp ] +
    BlockMvs[ refList ][ blockIdx + 2 ][ comp ] ) for comp = 0..1.

  * Otherwise, if subsampling_x is equal to 1 and subsampling_y is equal to 0,
    mv[ comp ] is set equal to round_mv_comp_q2(
    BlockMvs[ refList ][ blockIdx ][ comp ] +
    BlockMvs[ refList ][ blockIdx + 1 ][ comp ] ) for comp = 0..1.

  * Otherwise, (subsampling_x is equal to 1 and subsampling_y is equal to 1),
    mv[ comp ] is set equal to round_mv_comp_q4(
    BlockMvs[ refList ][ 0 ][ comp ] + BlockMvs[ refList ][ 1 ][ comp ] +
    BlockMvs[ refList ][ 2 ][ comp ] + BlockMvs[ refList ][ 3 ][ comp ] )
    for comp = 0..1.

The functions round_mv_comp_q2 and round_mv_comp_q4 perform division with rounding to the nearest integer and are specified as:

~~~~~ c
round_mv_comp_q2( value ) {
    return (value < 0 ? value - 1 : value + 1) / 2
}
round_mv_comp_q4( value ) {
    return (value < 0 ? value - 2 : value + 2) / 4
}
~~~~~

**Note:** When subsampling_x is equal to 1, and subsampling_y is equal to 0,
the chroma motion vector for the bottom block is computed as an average of the
top-right and bottom-left luma motion vectors because blockIdx is equal to 1
for the bottom chroma block.


##### Motion Vector Clamping Process

The inputs to this process are:

  * a variable plane specifying which plane is being predicted,

  * a variable mv specifying the motion vector to be clamped.

The output of this process is a 2 element array called clampedMv containing
the clamped motion vector for this block. The purpose of this process is to
change the motion vector into the appropriate precision for the current plane
and to clamp motion vectors that go too far off the edge of the frame. The
variables sx and sy are set equal to the subsampling for the current plane
as follows:

  * If plane is equal to 0, sx is set equal to 0 and sy is set equal to 0.

  * Otherwise, sx is set equal to subsampling_x and sy is set equal to
    subsampling_y.

The output array clampedMv is specified by the following steps:

~~~~~ c
bh = num8x8BlocksHighLookup[ MiSize ]
mbToTopEdge = -((MiRow * MI_SIZE) * 16) >> sy
mbToBottomEdge = (((MiRows - bh - MiRow) * MI_SIZE) * 16) >> sy
bw = num8x8BlocksWideLookup[ MiSize ]
mbToLeftEdge = -((MiCol * MI_SIZE) * 16) >> sx
mbToRightEdge = (((MiCols - bw - MiCol) * MI_SIZE) * 16) >> sx
spelLeft = (INTERP_EXTEND + ((bw * MI_SIZE) >> sx) ) << SUBPEL_BITS
spelRight = spelLeft - SUBPEL_SHIFTS
spelTop = (INTERP_EXTEND + ((bh * MI_SIZE) >> sy) ) << SUBPEL_BITS
spelBottom = spelTop - SUBPEL_SHIFTS
clampedMv[ 0 ] = Clip3( mbToTopEdge - spelTop, mbToBottomEdge + spelBottom,
    (2 * mv[ 0 ]) >> sy )
clampedMv[ 1 ] = Clip3( mbToLeftEdge - spelLeft, mbToRightEdge + spelRight,
    (2 * mv[ 1 ]) >> sx )
~~~~~

**Note:** The clamping is applied before the motion vector is scaled.


##### Motion Vector Scaling Process

The inputs to this process are:

  * a variable plane specifying which plane is being predicted,

  * a variable refList specifying that we should scale to match reference
    frame refFrame[ refList ],

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the region to be predicted,

  * a variable clampedMv specifying the clamped motion vector.

The outputs of this process are the variables startX and startY giving the
reference block location in units of 1/16 th of a sample, and variables xStep
and yStep giving the step size in units of 1/16 th of a sample.

This process is responsible for computing the sampling locations in the
reference frame based on the motion vector. The sampling locations are also
adjusted to compensate for any difference in the size of the reference frame
compared to the current frame.

A variable refIdx specifying which reference frame is being used is set equal
to ref_frame_idx[ refFrame[ refList ] - LAST_FRAME ].

It is a requirement of bitstream conformance that all the following conditions
are satisfied:

  * 2 * FrameWidth >= RefFrameWidth[ refIdx ]

  * 2 * FrameHeight >= RefFrameHeight[ refIdx ]

  * FrameWidth <= 16 * RefFrameWidth[ refIdx ]

  * FrameHeight <= 16 * RefFrameHeight[ refIdx ]

A variable xScale is set equal to (RefFrameWidth[ refIdx ] <<
REF_SCALE_SHIFT) / FrameWidth.

A variable yScale is set equal to (RefFrameHeight[ refIdx ] <<
REF_SCALE_SHIFT) / FrameHeight.

(xScale and yScale specify the size of the reference frame relative to the
current frame in units where 16 is equivalent to the reference frame having
the same size.)

The variable baseX is set equal to (x * xScale) >> REF_SCALE_SHIFT.

The variable baseY is set equal to (y * yScale) >> REF_SCALE_SHIFT.

(baseX and baseY specify the location of the block in the reference frame if a
zero motion vector is used).

The variable lumaX is set equal to (plane > 0) ? x << subsampling_x : x.

The variable lumaY is set equal to (plane > 0) ? y << subsampling_y : y.
(lumaX and lumaY specify the location of the block to be predicted in the
current frame in units of luma samples.)

The variable fracX is set equal to ( (16 * lumaX * xScale) >>
REF_SCALE_SHIFT) & SUBPEL_MASK.

The variable fracY is set equal to ( (16 * lumaY * yScale) >>
REF_SCALE_SHIFT) & SUBPEL_MASK.

The variable dX is set equal to ( (clampedMv[ 1 ] * xScale) >>
REF_SCALE_SHIFT) + fracX.

The variable dY is set equal to ( (clampedMv[ 0 ] * yScale) >>
REF_SCALE_SHIFT) + fracY.

(dX and dY specify a scaled motion vector.)

The output variable stepX is set equal to (16 * xScale) >> REF_SCALE_SHIFT.

The output variable stepY is set equal to (16 * yScale) >> REF_SCALE_SHIFT.

The output variable startX is set equal to (baseX << SUBPEL_BITS) + dX.

The output variable startY is set equal to (baseY << SUBPEL_BITS) + dY.

**Note:** Even for chroma blocks the fractional part of the start position is
based on the luma block location in lumaX and lumaY.



##### Block Inter Prediction Process

The inputs to this process are:

  * a variable plane,

  * a variable refList specifying that we should predict from
    refFrame[ refList ],

  * variables x and y giving the block location in units of 1/16 th of a
    sample,

  * variables xStep and yStep giving the step size in units of 1/16 th of a
    sample. (These will be at most equal to 80 due to the restrictions on
    scaling between reference frames.)

  * variables w and h giving the width and height of the block in units of
    samples

The output from this process is the 2D array named pred containing inter
predicted samples.

A variable refIdx specifying which reference frame is being used is set equal
to ref_frame_idx[ refFrame[ refList ] - LAST_FRAME ].

A variable ref specifying the reference frame contents is set equal to
FrameStore[ refIdx ].

The variables subX and subY are set equal to the subsampling for the current
plane as follows:

  * If plane is equal to 0, subX is set equal to 0 and subY is set equal to 0.

  * Otherwise, subX is set equal to subsampling_x and subY is set equal to
   subsampling_y.

The variable lastX is set equal to ( (RefFrameWidth[ refIdx ] + subX) >>
subX) - 1.

The variable lastY is set equal to ( (RefFrameHeight[ refIdx ] + subY) >>
subY) - 1.

(lastX and lastY specify the coordinates of the bottom right sample of the reference plane.)

The variable intermediateHeight specifying the height required for the
intermediate array is set equal to (((h - 1) * yStep + 15) >> 4) + 8.

The sub-sample interpolation is effected via two one-dimensional convolutions.
First a horizontal filter is used to build up a temporary array, and then this
array is vertically filtered to obtain the final prediction. The fractional
parts of the motion vectors determine the filtering process. If the fractional
part is zero, then the filtering is equivalent to a straight sample copy.

The filtering is applied as follows:

  * The array intermediate is specified as follows:

    ~~~~~ c
    for ( r = 0; r < intermediateHeight; r++ ) {
        for ( c = 0; c < w; c++ ) {
            s = 0
            p = x + xStep * c
            for ( t = 0; t < 8; t++ )
                s += subpel_filters[ interp_filter ][ p & 15 ][ t ] *
                  ref[ plane ] [ Clip3( 0, lastY, (y >> 4) + r - 3 ) ]
                               [ Clip3( 0, lastX, (p >> 4) + t - 3 ) ]
            intermediate[ r ][ c ] = Round2(s, 5)
        }
    }
    ~~~~~

  * The array pred is specified as follows:

    ~~~~~ c
    for ( r = 0; r < h; r++ ) {
        for ( c = 0; c < w; c++ ) {
            s = 0
            p = (y & 15) + yStep * r
            for ( t = 0; t < 8; t++ )
                s += subpel_filters[ interp_filter ][ p & 15 ][ t ] *
                  intermediate[ (p >> 4) + t ][ c ]
            pred[ r ][ c ] = s
        }
    }
    ~~~~~

    where the constant array subpel_filters is specified as:

    ~~~~~ c
    subpel_filters[ 4 ][ 16 ][ 8 ] = {
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { 0, 2, -6, 126, 8, -2, 0, 0 },
        { 0, 2, -10, 122, 18, -4, 0, 0 },
        { 0, 2, -12, 116, 28, -8, 2, 0 },
        { 0, 2, -14, 110, 38, -10, 2, 0 },
        { 0, 2, -14, 102, 48, -12, 2, 0 },
        { 0, 2, -16, 94, 58, -12, 2, 0 },
        { 0, 2, -14, 84, 66, -12, 2, 0 },
        { 0, 2, -14, 76, 76, -14, 2, 0 },
        { 0, 2, -12, 66, 84, -14, 2, 0 },
        { 0, 2, -12, 58, 94, -16, 2, 0 },
        { 0, 2, -12, 48, 102, -14, 2, 0 },
        { 0, 2, -10, 38, 110, -14, 2, 0 },
        { 0, 2, -8, 28, 116, -12, 2, 0 },
        { 0, 0, -4, 18, 122, -10, 2, 0 },
        { 0, 0, -2, 8, 126, -6, 2, 0 }
      },
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { 0, 2, 28, 62, 34, 2, 0, 0 },
        { 0, 0, 26, 62, 36, 4, 0, 0 },
        { 0, 0, 22, 62, 40, 4, 0, 0 },
        { 0, 0, 20, 60, 42, 6, 0, 0 },
        { 0, 0, 18, 58, 44, 8, 0, 0 },
        { 0, 0, 16, 56, 46, 10, 0, 0 },
        { 0, -2, 16, 54, 48, 12, 0, 0 },
        { 0, -2, 14, 52, 52, 14, -2, 0 },
        { 0, 0, 12, 48, 54, 16, -2, 0 },
        { 0, 0, 10, 46, 56, 16, 0, 0 },
        { 0, 0, 8, 44, 58, 18, 0, 0 },
        { 0, 0, 6, 42, 60, 20, 0, 0 },
        { 0, 0, 4, 40, 62, 22, 0, 0 },
        { 0, 0, 4, 36, 62, 26, 0, 0 },
        { 0, 0, 2, 34, 62, 28, 2, 0 }
      },
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { -2, 2, -6, 126, 8, -2, 2, 0 },
        { -2, 6, -12, 124, 16, -6, 4, -2 },
        { -2, 8, -18, 120, 26, -10, 6, -2 },
        { -4, 10, -22, 116, 38, -14, 6, -2 },
        { -4, 10, -22, 108, 48, -18, 8, -2 },
        { -4, 10, -24, 100, 60, -20, 8, -2 },
        { -4, 10, -24, 90, 70, -22, 10, -2 },
        { -4, 12, -24, 80, 80, -24, 12, -4 },
        { -2, 10, -22, 70, 90, -24, 10, -4 },
        { -2, 8, -20, 60, 100, -24, 10, -4 },
        { -2, 8, -18, 48, 108, -22, 10, -4 },
        { -2, 6, -14, 38, 116, -22, 10, -4 },
        { -2, 6, -10, 26, 120, -18, 8, -2 },
        { -2, 4, -6, 16, 124, -12, 6, -2 },
        { 0, 2, -2, 8, 126, -6, 2, -2 }
      },
      {
        { 0, 0, 0, 128, 0, 0, 0, 0 },
        { 0, 0, 0, 120, 8, 0, 0, 0 },
        { 0, 0, 0, 112, 16, 0, 0, 0 },
        { 0, 0, 0, 104, 24, 0, 0, 0 },
        { 0, 0, 0, 96, 32, 0, 0, 0 },
        { 0, 0, 0, 88, 40, 0, 0, 0 },
        { 0, 0, 0, 80, 48, 0, 0, 0 },
        { 0, 0, 0, 72, 56, 0, 0, 0 },
        { 0, 0, 0, 64, 64, 0, 0, 0 },
        { 0, 0, 0, 56, 72, 0, 0, 0 },
        { 0, 0, 0, 48, 80, 0, 0, 0 },
        { 0, 0, 0, 40, 88, 0, 0, 0 },
        { 0, 0, 0, 32, 96, 0, 0, 0 },
        { 0, 0, 0, 24, 104, 0, 0, 0 },
        { 0, 0, 0, 16, 112, 0, 0, 0 },
        { 0, 0, 0, 8, 120, 0, 0, 0 }
      }
    }
    ~~~~~

**Note:** All the values in subpel_filters are even.

### Reconstruction and Dequantization

This section details the process of reconstructing a block of coefficients
using dequantization and inverse transforms.


#### Dequantization Functions

This section defines the functions get_dc_quant and get_ac_quant that are
needed by the dequantization process.

The quantization parameters are derived from lookup tables.

The function dc_q( b ) is specified as
dc_qlookup[ (BitDepth-8) >> 1 ][ Clip3( 0, 255, b ) ] where dc_lookup is
defined as follows:

~~~~~ c
dc_qlookup[ 3 ][ 256 ] = {
  {
    4, 8, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16,
    17, 18, 19, 19, 20, 21, 22, 23, 24, 25, 26, 26,
    27, 28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37,
    38, 38, 39, 40, 41, 42, 43, 43, 44, 45, 46, 47,
    48, 48, 49, 50, 51, 52, 53, 53, 54, 55, 56, 57,
    57, 58, 59, 60, 61, 62, 62, 63, 64, 65, 66, 66,
    67, 68, 69, 70, 70, 71, 72, 73, 74, 74, 75, 76,
    77, 78, 78, 79, 80, 81, 81, 82, 83, 84, 85, 85,
    87, 88, 90, 92, 93, 95, 96, 98, 99, 101, 102, 104,
    105, 107, 108, 110, 111, 113, 114, 116, 117, 118, 120, 121,
    123, 125, 127, 129, 131, 134, 136, 138, 140, 142, 144, 146,
    148, 150, 152, 154, 156, 158, 161, 164, 166, 169, 172, 174,
    177, 180, 182, 185, 187, 190, 192, 195, 199, 202, 205, 208,
    211, 214, 217, 220, 223, 226, 230, 233, 237, 240, 243, 247,
    250, 253, 257, 261, 265, 269, 272, 276, 280, 284, 288, 292,
    296, 300, 304, 309, 313, 317, 322, 326, 330, 335, 340, 344,
    349, 354, 359, 364, 369, 374, 379, 384, 389, 395, 400, 406,
    411, 417, 423, 429, 435, 441, 447, 454, 461, 467, 475, 482,
    489, 497, 505, 513, 522, 530, 539, 549, 559, 569, 579, 590,
    602, 614, 626, 640, 654, 668, 684, 700, 717, 736, 755, 775,
    796, 819, 843, 869, 896, 925, 955, 988, 1022, 1058, 1098, 1139,
    1184, 1232, 1282, 1336
  },
  {
    4, 9, 10, 13, 15, 17, 20, 22, 25, 28, 31, 34,
    37, 40, 43, 47, 50, 53, 57, 60, 64, 68, 71, 75,
    78, 82, 86, 90, 93, 97, 101, 105, 109, 113, 116, 120,
    124, 128, 132, 136, 140, 143, 147, 151, 155, 159, 163, 166,
    170, 174, 178, 182, 185, 189, 193, 197, 200, 204, 208, 212,
    215, 219, 223, 226, 230, 233, 237, 241, 244, 248, 251, 255,
    259, 262, 266, 269, 273, 276, 280, 283, 287, 290, 293, 297,
    300, 304, 307, 310, 314, 317, 321, 324, 327, 331, 334, 337,
    343, 350, 356, 362, 369, 375, 381, 387, 394, 400, 406, 412,
    418, 424, 430, 436, 442, 448, 454, 460, 466, 472, 478, 484,
    490, 499, 507, 516, 525, 533, 542, 550, 559, 567, 576, 584,
    592, 601, 609, 617, 625, 634, 644, 655, 666, 676, 687, 698,
    708, 718, 729, 739, 749, 759, 770, 782, 795, 807, 819, 831,
    844, 856, 868, 880, 891, 906, 920, 933, 947, 961, 975, 988,
    1001, 1015, 1030, 1045, 1061, 1076, 1090, 1105, 1120, 1137, 1153, 1170,
    1186, 1202, 1218, 1236, 1253, 1271, 1288, 1306, 1323, 1342, 1361, 1379,
    1398, 1416, 1436, 1456, 1476, 1496, 1516, 1537, 1559, 1580, 1601, 1624,
    1647, 1670, 1692, 1717, 1741, 1766, 1791, 1817, 1844, 1871, 1900, 1929,
    1958, 1990, 2021, 2054, 2088, 2123, 2159, 2197, 2236, 2276, 2319, 2363,
    2410, 2458, 2508, 2561, 2616, 2675, 2737, 2802, 2871, 2944, 3020, 3102,
    3188, 3280, 3375, 3478, 3586, 3702, 3823, 3953, 4089, 4236, 4394, 4559,
    4737, 4929, 5130, 5347
  },
  {
    4, 12, 18, 25, 33, 41, 50, 60,
    70, 80, 91, 103, 115, 127, 140, 153,
    166, 180, 194, 208, 222, 237, 251, 266,
    281, 296, 312, 327, 343, 358, 374, 390,
    405, 421, 437, 453, 469, 484, 500, 516,
    532, 548, 564, 580, 596, 611, 627, 643,
    659, 674, 690, 706, 721, 737, 752, 768,
    783, 798, 814, 829, 844, 859, 874, 889,
    904, 919, 934, 949, 964, 978, 993, 1008,
    1022, 1037, 1051, 1065, 1080, 1094, 1108, 1122,
    1136, 1151, 1165, 1179, 1192, 1206, 1220, 1234,
    1248, 1261, 1275, 1288, 1302, 1315, 1329, 1342,
    1368, 1393, 1419, 1444, 1469, 1494, 1519, 1544,
    1569, 1594, 1618, 1643, 1668, 1692, 1717, 1741,
    1765, 1789, 1814, 1838, 1862, 1885, 1909, 1933,
    1957, 1992, 2027, 2061, 2096, 2130, 2165, 2199,
    2233, 2267, 2300, 2334, 2367, 2400, 2434, 2467,
    2499, 2532, 2575, 2618, 2661, 2704, 2746, 2788,
    2830, 2872, 2913, 2954, 2995, 3036, 3076, 3127,
    3177, 3226, 3275, 3324, 3373, 3421, 3469, 3517,
    3565, 3621, 3677, 3733, 3788, 3843, 3897, 3951,
    4005, 4058, 4119, 4181, 4241, 4301, 4361, 4420,
    4479, 4546, 4612, 4677, 4742, 4807, 4871, 4942,
    5013, 5083, 5153, 5222, 5291, 5367, 5442, 5517,
    5591, 5665, 5745, 5825, 5905, 5984, 6063, 6149,
    6234, 6319, 6404, 6495, 6587, 6678, 6769, 6867,
    6966, 7064, 7163, 7269, 7376, 7483, 7599, 7715,
    7832, 7958, 8085, 8214, 8352, 8492, 8635, 8788,
    8945, 9104, 9275, 9450, 9639, 9832, 10031, 10245,
    10465, 10702, 10946, 11210, 11482, 11776, 12081, 12409,
    12750, 13118, 13501, 13913, 14343, 14807, 15290, 15812,
    16356, 16943, 17575, 18237, 18949, 19718, 20521, 21387
  }
}
~~~~~

The function ac_q( b ) is specified as ac_qlookup[
(BitDepth-8) >> 1 ][ Clip3( 0, 255, b ) ] where ac_lookup is defined as follows:

~~~~~ c
ac_qlookup[ 3 ][ 256 ] = {
  {
    4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
    43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
    55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
    79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
    91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,
    104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
    128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
    152, 155, 158, 161, 164, 167, 170, 173, 176, 179, 182, 185,
    188, 191, 194, 197, 200, 203, 207, 211, 215, 219, 223, 227,
    231, 235, 239, 243, 247, 251, 255, 260, 265, 270, 275, 280,
    285, 290, 295, 300, 305, 311, 317, 323, 329, 335, 341, 347,
    353, 359, 366, 373, 380, 387, 394, 401, 408, 416, 424, 432,
    440, 448, 456, 465, 474, 483, 492, 501, 510, 520, 530, 540,
    550, 560, 571, 582, 593, 604, 615, 627, 639, 651, 663, 676,
    689, 702, 715, 729, 743, 757, 771, 786, 801, 816, 832, 848,
    864, 881, 898, 915, 933, 951, 969, 988, 1007, 1026, 1046, 1066,
    1087, 1108, 1129, 1151, 1173, 1196, 1219, 1243, 1267, 1292, 1317, 1343,
    1369, 1396, 1423, 1451, 1479, 1508, 1537, 1567, 1597, 1628, 1660, 1692,
    1725, 1759, 1793, 1828
  },
  {
    4, 9, 11, 13, 16, 18, 21, 24, 27, 30, 33, 37,
    40, 44, 48, 51, 55, 59, 63, 67, 71, 75, 79, 83,
    88, 92, 96, 100, 105, 109, 114, 118, 122, 127, 131, 136,
    140, 145, 149, 154, 158, 163, 168, 172, 177, 181, 186, 190,
    195, 199, 204, 208, 213, 217, 222, 226, 231, 235, 240, 244,
    249, 253, 258, 262, 267, 271, 275, 280, 284, 289, 293, 297,
    302, 306, 311, 315, 319, 324, 328, 332, 337, 341, 345, 349,
    354, 358, 362, 367, 371, 375, 379, 384, 388, 392, 396, 401,
    409, 417, 425, 433, 441, 449, 458, 466, 474, 482, 490, 498,
    506, 514, 523, 531, 539, 547, 555, 563, 571, 579, 588, 596,
    604, 616, 628, 640, 652, 664, 676, 688, 700, 713, 725, 737,
    749, 761, 773, 785, 797, 809, 825, 841, 857, 873, 889, 905,
    922, 938, 954, 970, 986, 1002, 1018, 1038, 1058, 1078, 1098, 1118,
    1138, 1158, 1178, 1198, 1218, 1242, 1266, 1290, 1314, 1338, 1362, 1386,
    1411, 1435, 1463, 1491, 1519, 1547, 1575, 1603, 1631, 1663, 1695, 1727,
    1759, 1791, 1823, 1859, 1895, 1931, 1967, 2003, 2039, 2079, 2119, 2159,
    2199, 2239, 2283, 2327, 2371, 2415, 2459, 2507, 2555, 2603, 2651, 2703,
    2755, 2807, 2859, 2915, 2971, 3027, 3083, 3143, 3203, 3263, 3327, 3391,
    3455, 3523, 3591, 3659, 3731, 3803, 3876, 3952, 4028, 4104, 4184, 4264,
    4348, 4432, 4516, 4604, 4692, 4784, 4876, 4972, 5068, 5168, 5268, 5372,
    5476, 5584, 5692, 5804, 5916, 6032, 6148, 6268, 6388, 6512, 6640, 6768,
    6900, 7036, 7172, 7312
  },
  {
    4, 13, 19, 27, 35, 44, 54, 64,
    75, 87, 99, 112, 126, 139, 154, 168,
    183, 199, 214, 230, 247, 263, 280, 297,
    314, 331, 349, 366, 384, 402, 420, 438,
    456, 475, 493, 511, 530, 548, 567, 586,
    604, 623, 642, 660, 679, 698, 716, 735,
    753, 772, 791, 809, 828, 846, 865, 884,
    902, 920, 939, 957, 976, 994, 1012, 1030,
    1049, 1067, 1085, 1103, 1121, 1139, 1157, 1175,
    1193, 1211, 1229, 1246, 1264, 1282, 1299, 1317,
    1335, 1352, 1370, 1387, 1405, 1422, 1440, 1457,
    1474, 1491, 1509, 1526, 1543, 1560, 1577, 1595,
    1627, 1660, 1693, 1725, 1758, 1791, 1824, 1856,
    1889, 1922, 1954, 1987, 2020, 2052, 2085, 2118,
    2150, 2183, 2216, 2248, 2281, 2313, 2346, 2378,
    2411, 2459, 2508, 2556, 2605, 2653, 2701, 2750,
    2798, 2847, 2895, 2943, 2992, 3040, 3088, 3137,
    3185, 3234, 3298, 3362, 3426, 3491, 3555, 3619,
    3684, 3748, 3812, 3876, 3941, 4005, 4069, 4149,
    4230, 4310, 4390, 4470, 4550, 4631, 4711, 4791,
    4871, 4967, 5064, 5160, 5256, 5352, 5448, 5544,
    5641, 5737, 5849, 5961, 6073, 6185, 6297, 6410,
    6522, 6650, 6778, 6906, 7034, 7162, 7290, 7435,
    7579, 7723, 7867, 8011, 8155, 8315, 8475, 8635,
    8795, 8956, 9132, 9308, 9484, 9660, 9836, 10028,
    10220, 10412, 10604, 10812, 11020, 11228, 11437, 11661,
    11885, 12109, 12333, 12573, 12813, 13053, 13309, 13565,
    13821, 14093, 14365, 14637, 14925, 15213, 15502, 15806,
    16110, 16414, 16734, 17054, 17390, 17726, 18062, 18414,
    18766, 19134, 19502, 19886, 20270, 20670, 21070, 21486,
    21902, 22334, 22766, 23214, 23662, 24126, 24590, 25070,
    25551, 26047, 26559, 27071, 27599, 28143, 28687, 29247
  }
}
~~~~~

The function get_qindex( ) returns the quantizer index for the current block and is specified by the following:

  * If seg_feature_active( SEG_LVL_ALT_Q ) is equal to 1 the following ordered steps apply:

    1. Set the variable data equal to FeatureData[ segment_id ][ SEG_LVL_ALT_Q ].

    2. If segmentation_abs_or_delta_update is equal to 0, set data equal to
       base_q_idx + data

    3. Return Clip3( 0, 255, data ).

  * Otherwise, return base_q_idx.

The function get_dc_quant( plane ) returns the quantizer value for the dc
coefficient for a particular plane and is derived as follows:

  * If plane is equal to 0, return dc_q( get_qindex( ) + deltaQYDc ).

  * Otherwise, return dc_q( get_qindex( ) + deltaQUVDc ).

The function get_ac_quant( plane ) returns the quantizer value for the ac
coefficient for a particular plane and is derived as follows:

  * If plane is equal to 0, return ac_q( get_qindex( ) ).

  * Otherwise, return ac_q( get_qindex( ) + deltaQUVAc ).


#### Reconstruct Process

The reconstruct process is invoked to perform dequantization, inverse
transform and reconstruction. This process is triggered at a point defined by
a function call to reconstruct in the residual syntax table described in
section 6.4.21.

The inputs to this process are:

  * a variable plane specifying which plane is being reconstructed,

  * variables x and y specifying the location of the top left sample in the
    CurrFrame[ plane ] array of the current transform block,

  * a variable txSz, specifying the size of the transform block.

The outputs of this process are reconstructed samples in the current frame
CurrFrame.

The reconstruction and dequantization process is defined as follows:

The variable dqDenom is set equal to 2 if txSz is equal to TX_32X32, otherwise
dqDenom is set equal to 1.

The variable n (specifying the base 2 logarithm of the width of the transform
block) is set equal to 2 + txSz.

The variable n0 (specifying the width of the transform block) is set equal
to 1 << n.

The following ordered steps apply:

  1. Dequant[ i ][ j ] is set equal to ( Tokens[ i * n0 + j ] *
     get_ac_quant( plane ) ) / dqDenom for i = 0..(n0-1), for j = 0..(n0-1).

  2. Dequant[ 0 ][ 0 ] is set equal to ( Tokens[ 0 ] *
     get_dc_quant( plane ) ) / dqDenom.

  3. Invoke the 2D inverse transform block process defined in section 8.7.2
     with the variable n as input. The inverse transform outputs are stored
     back to the Dequant buffer.

  4. CurrFrame[ plane ][ y + i ][ x + j ] is set equal to
     Clip1( CurrFrame[ plane ][ y + i ][ x + j ] + Dequant[ i ][ j ] )
     for i = 0..(n0-1) and j = 0..(n0-1).

It is a requirement of bitstream conformance that the values written into the
Dequant array in steps 1 and 2 are representable by a signed integer with 8 +
BitDepth bits.


### Inverse Transform Process

This section details the inverse transforms used during the reconstruction
processes detailed in section 8.6.


#### 1D Transforms

##### Butterfly Functions

This section defines the butterfly functions B, H, SB, SH used by the 1D
transform processes.

The inverse transform process works by writing values into an array T. It is a
requirement of bitstream conformance that the values saved into the array T
are representable by a signed integer using 8 + BitDepth bits of precision.

**Note:** The inverse asymmetric discrete sine transforms also make use of an
intermediate array named S. The values in this array require higher precision
to avoid overflow. Using signed integers with 24 + BitDepth bits of precision
is enough to avoid overflow.

The function brev(numBits, x) returns the bit-reversal of numBits of x and is
specified as follows:

~~~~~ c
brev( numBits, x ) {
    t = 0
    for ( i = 0; i < numBits; i++ ) {
        bit = (x >> i) & 1
        t += bit << (numBits - 1 - i)
    }
    return t
}
~~~~~

The function B( a, b, angle, 0 ) performs a butterfly rotation specified by
the following ordered steps:

  1. The variable x is set equal to T[ a ] * cos64( angle ) - T[ b ] *
     sin64( angle ).

  2. The variable y is set equal to T[ a ] * sin64( angle ) + T[ b ] *
     cos64( angle ).

  3. T[ a ] is set equal to Round2( x, 14 ).

  4. T[ b ] is set equal to Round2( y, 14 ).

It is a requirement of bitstream conformance that the values saved into the
array T by this function are representable by a signed integer using 8 +
BitDepth bits of precision.

The function cos64( angle ) is specified for integer values of the input angle
by the following ordered steps:

  1. Set a variable angle2 equal to angle & 127.

  2. If angle2 is greater than or equal to 0 and less than or equal to 32,
     return cos64_lookup[ angle2 ].

  3. If angle2 is greater than 32 and less than or equal to 64, return
     cos64_lookup[ 64 - angle2 ] * -1.

  4. If angle2 is greater than 64 and less than or equal to 96, return
     cos64_lookup[ angle2 - 64 ] * -1.

  5. Otherwise (if angle2 is greater than 96 and less than 128), return
     cos64_lookup[ 128 - angle2 ].

Where cos64_lookup is a constant lookup table defined as:

~~~~~ c
cos64_lookup[ 33 ] = {
    16384, 16364, 16305, 16207, 16069, 15893, 15679, 15426,
    15137, 14811, 14449, 14053, 13623, 13160, 12665, 12140,
    11585, 11003, 10394, 9760, 9102, 8423, 7723, 7005,
    6270, 5520, 4756, 3981, 3196, 2404, 1606, 804,
    0
}
~~~~~

The function sin64( angle ) is defined to be cos64( angle - 32 ).

**Note:** The cos64 function implements the expression round( 16384 *
cos( angle * pi / 64 ) ). The sin64 function implements the expression
round( 16384 * sin( angle * pi / 64 ) ).

When the angle is equal to 16 + 32*k for integer k the butterfly rotation can
be equivalently performed with two fewer multiplications (because the
magnitude of cos64(16 + 32*k) is always equal to that of sin64(16 + 32*k))
by the following process:

  1. The variable v is set equal to (angle & 32) ? T[ a ] +
     T[ b ] : T[ a ] - T[ b ].

  2. The variable w is set equal to (angle & 32) ? -T[ a ] +
     T[ b ] : T[ a ] + T[ b ].

  3. The variable x is set equal to v * cos64( angle ).

  4. The variable y is set equal to w * cos64( angle ).

  5. T[ a ] is set equal to Round2( x, 14 ).

  6. T[ b ] is set equal to Round2( y, 14 ).

It is a requirement of bitstream conformance that the angle is equal to 16 +
32*k for integer k, the variables v and w are representable by a signed
integer using 8 + BitDepth bits of precision.

The function B( a ,b, angle, 1 ) performs a butterfly rotation and flip
specified by the following ordered steps:

  1. The function B( a, b, angle, 0 ) is invoked.

  2. The contents of T[ a ] and T[ b ] are exchanged.

The function H( a, b, 0 ) performs a Hadamard rotation specified by the
following ordered steps:

  1. The variable x is set equal to T[ a ].

  2. The variable y is set equal to T[ b ].

  3. T[ a ] is set equal to x + y.

  4. T[ b ] is set equal to x - y.

It is a requirement of bitstream conformance that the values saved into the
array T by this function are representable by a signed integer using 8 +
BitDepth bits of precision.

The function H( a, b, 1 ) performs a Hadamard rotation with flipped indices
and is specified as follows:

  1. The function H( b, a, 0 ) is invoked.

The function SB( a, b, angle, 0 ) performs a butterfly rotation according to
the following ordered steps:

  1. S[ a ] is set equal to T[ a ] * cos64( angle ) - T[ b ] * sin64( angle ).

  2. S[ b ] is set equal to T[ a ] * sin64( angle ) + T[ b ] * cos64( angle ).

The function SB( a, b, angle, 1 ) performs a butterfly rotation and flip according to the following ordered steps:

  1. The function SB( a, b, angle, 0 ) is invoked.

  2. The contents of S[ a ] and S[ b ] are exchanged.

The function SH( a, b ) performs a Hadamard rotation and rounding specified by
the following ordered steps:

  1. T[ a ] is set equal to Round2( S[ a ] + S[ b ], 14 ).

  2. T[ b ] is set equal to Round2( S[ a ] - S[ b ], 14 ).


##### Inverse DCT Array Permutation Process

This process performs an in-place permutation of the array T of length 2n
for 2  n  5 which is required before execution of the inverse DCT process.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

A temporary array named copyT is set equal to T.

T[ i ] is set equal to copyT[ brev( n, i ) ] for i = 0..((1 << n) - 1).


##### Inverse DCT Process

This process performs an in-place inverse discrete cosine transform of the
permuted array T which is of length 2n for 2  n  5.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

The variable n0 is set equal to 1 << n.

The variable n1 is set equal to 1 << (n-1).

The variable n2 is set equal to 1 << (n-2).

The variable n3 is set equal to 1 << (n-3).

The following ordered steps apply:

  1. If n is equal to 2, invoke B( 0, 1, 16, 1 ), otherwise recursively invoke
     the inverse DCT defined in this section with the variable n set equal to
     n - 1.

  2. Invoke B( n1+i, n0-1-i, 32-brev( 5, n1+i), 0 ) for i = 0..(n2-1).

  3. If n is greater than or equal to 3:

     a. Invoke H( n1+4*i+2*j, n1+1+4*i+2*j, j ) for i = 0..(n3-1), j = 0..1.

  4. If n is equal to 5:

     a. Invoke B( n0-n+3-n2*j-4*i, n1+n-4+n2*j+4*i, 28-16*i+56*j, 1 )
        for i = 0..1, j = 0..1.

     b. Invoke H( n1+n3*j+i, n1+n2-5+n3*j-i, j&1 ) for i = 0..1, j = 0..3.

  5. If n is greater than or equal to 4:

     a. Invoke B( n0-n+2-i-n2*j, n1+n-3+i+n2*j, 24+48*j, 1 )
        for i = 0..(n==5), j = 0..1.

     b. Invoke H( n1+n2*j+i, n1+n2-1+n2*j-i, j&1 ) for i = 0..(2n-7),
        j = 0..1.

  6. If n is greater than or equal to 3:

     a. Invoke B( n0-n3-1-i, n1+n3+i, 16, 1 ) for i = 0..(n3-1).

  7. Invoke H( i, n0-1-i, 0 ) for i = 0..(n1-1).


##### Inverse ADST Input Array Permutation Process

This process performs the in-place permutation of the array T of length 2n
which is required as the first step of the inverse ADST.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

The variable n0 is set equal to 1 << n.

The variable n1 is set equal to 1 << (n-1).

A temporary array named copyT is set equal to T.

The values at even locations T[ 2 * i ] are set equal to
copyT[ n0 - 1 - 2 * i ] for i = 0..(n1-1).

The values at odd locations T[ 2 * i + 1 ] are set equal to copyT[ 2 * i ]
for i = 0..(n1-1).


##### Inverse ADST Output Array Permutation Process

This process performs the in-place permutation of the array T of length 2n
which is required before the final step of the inverse ADST.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

A temporary array named copyT is set equal to T.

The permutation depends on n as follows:

  * If n is equal to 4, T[ 8*a + 4*b + 2*c + d ] is set equal to
    copyT[ 8*(d^c) + 4*(c^b) + 2*(b^a) + a ] for a = 0..1 and b = 0..1
    and c = 0..1 and d = 0..1.

  * Otherwise (n is equal to 3), T[ 4*a + 2*b + c ] is set equal to
    copyT[ 4*(c^b) + 2*(b^a) + a ] for a = 0..1 and b = 0..1 and c = 0..1.


##### Inverse ADST4 Process

This process does an in-place transform of the array T to perform an inverse
ADST.

The following ordered steps apply:

~~~~~ c
s0 = SINPI_1_9 * T[ 0 ]
s1 = SINPI_2_9 * T[ 0 ]
s2 = SINPI_3_9 * T[ 1 ]
s3 = SINPI_4_9 * T[ 2 ]
s4 = SINPI_1_9 * T[ 2 ]
s5 = SINPI_2_9 * T[ 3 ]
s6 = SINPI_4_9 * T[ 3 ]
v = T[ 0 ] - T[ 2 ] + T[ 3 ]
s7 = SINPI_3_9 * v
x0 = s0 + s3 + s5
x1 = s1 - s4 - s6
x2 = s7
x3 = s2
s0 = x0 + x3
s1 = x1 + x3
s2 = x2
s3 = x0 + x1 - x3
T[ 0 ] = Round2( s0, 14 )
T[ 1 ] = Round2( s1, 14 )
T[ 2 ] = Round2( s2, 14 )
T[ 3 ] = Round2( s3, 14 )
~~~~~

It is a requirement of bitstream conformance that the values saved into the
variable v and into the array T by this function are representable by a signed
integer using 8 + BitDepth bits of precision.

The constants used in this function are defined as:

| Name of constant  | Value of constant
|:-----------------:|:-----------------:
| SINPI_1_9         | 5283
| SINPI_2_9         | 9929
| SINPI_3_9         | 13377
| SINPI_4_9         | 15212


##### Inverse ADST8 Process

This process does an in-place transform of the array T using a higher
precision array S for intermediate results. The following ordered steps apply:

  1. Invoke the ADST input array permutation process specified in section
     8.7.1.4 with the input variable n set equal to 3.

  2. Invoke SB( 2*i, 1+2*i, 30-8*i, 1 ) for i = 0..3.

  3. Invoke SH( i, 4+i ) for i = 0..3.

  4. Invoke SB( 4+3*i, 5+i, 24-16*i, 1 ) for i = 0..1.

  5. Invoke SH( 4+i, 6+i ) for i = 0..1.

  6. Invoke H( i, 2+i, 0 ) for i = 0..1.

  7. Invoke B( 2+4*i, 3+4*i, 16, 1 ) for i = 0..1.

  8. Invoke the ADST output array permutation process specified in
     section 8.7.1.5 with the input variable n set equal to 3.

  9. Set T[ 1+2*i ] equal to -T[ 1+2*i ] for i = 0..3.


##### Inverse ADST16 Process

This process does an in-place transform of the array T using a higher
precision array S for intermediate results. The following ordered steps apply:

  1. Invoke the ADST input array permutation process specified in
     section 8.7.1.4 with the input variable n set equal to 4.

  2. Invoke SB( 2*i, 1+2*i, 31-4*i, 1 ) for i = 0..7.

  3. Invoke SH( i, 8+i ) for i = 0..7.

  4. Invoke SB( 8+2*i, 9+2*i, 28-16*i, 1 ) for i = 0..3.

  5. Invoke SH( 8+i, 12+i ) for i = 0..3.

  6. Invoke H( i, 4+i, 0 ) for i = 0..3.

  7. Invoke SB( 4+8*i+3*j, 5+8*i+j, 24-16*j, 1 ) for i = 0..1, for j = 0..1.

  8. Invoke SH( 4+8*j+i, 6+8*j+i ) for i = 0..1, j = 0..1.

  9. Invoke H( 8*j+i, 2+8*j+i, 0 ) for i = 0..1, for j = 0..1.

  10. Invoke B( 2+4*j+8*i, 3+4*j+8*i, 48+64*(i^j), 0 ) for i = 0..1,
      for j = 0..1.

  11. Invoke the ADST output array permutation process specified in
      section 8.7.1.5 with the input variable n set equal to 4.

  12. Set T[ 1+12*j+2*i ] equal to -T[ 1+12*j+2*i ] for i = 0..1,
      for j = 0..1.


##### Inverse ADST Process

This process performs an in-place inverse ADST process on the array T of size
2n for 2  n  4.

The input to this process is a variable n that specifies the base 2 logarithm
of the length of the input array.

The process to invoke depends on n as follows:

  * If n is equal to 2, invoke the Inverse ADST4 process specified in
    section 8.7.1.6.

  * Otherwise if n is equal to 3, invoke the Inverse ADST8 process specified
    in section 8.7.1.7.

  * Otherwise (n is equal to 4), invoke the Inverse ADST16 process specified
    in section 8.7.1.8.


##### Inverse Walsh-Hadamard Transform Process

The input to this process is a variable shift that specifies the amount of
pre-scaling.

This process does an in-place transform of the array T (of length 4) by the
following ordered steps:

~~~~~ c
a = T[ 0 ] >> shift
c = T[ 1 ] >> shift
d = T[ 2 ] >> shift
b = T[ 3 ] >> shift
a += c
d -= b
e = (a - d) >> 1
b = e - b
c = e - c
a -= b
d += c
T[ 0 ] = a
T[ 1 ] = b
T[ 2 ] = c
T[ 3 ] = d
~~~~~


#### 2D Inverse Transform

This process performs a 2D inverse transform for an array of size 2n by 2n
stored in the 2D array Dequant.

The input to this process is a variable n that specifies the base 2 logarithm
of the width of the transform.

Set the variable n0 equal to 1 << n.

The row transforms with i = 0..(n0-1) are applied as follows:

  * Set T[ j ] equal to Dequant[ i ][ j ] for j = 0..(n0-1).

  * If Lossless is equal to 1, invoke the Inverse WHT process as specified in
    section 8.7.1.10 with shift equal to 2.

  * Otherwise, if TxType is equal to DCT_DCT or TxType is equal to ADST_DCT,
    apply an inverse DCT as follows:

    1. Invoke the inverse DCT permutation process as specified in section
       8.7.1.2 with the input variable n.

    2. Invoke the inverse DCT process as specified in section 8.7.1.3 with the
       input variable n.

  * Otherwise (TxType is equal to DCT_ADST or TxType is equal to ADST_ADST),
    invoke the inverse ADST process as specified in section 8.7.1.9 with input
    variable n.

  * Set Dequant[ i ][ j ] equal to T[ j ] for j = 0..(n0-1).

The column transforms with j = 0..(n0-1) are applied as follows:

  * Set T[ i ] equal to Dequant[ i ][ j ] for i = 0..(n0-1).

  * If Lossless is equal to 1, invoke the Inverse WHT process as specified in
    section 8.7.1.10 with shift equal to 0.

  * Otherwise, if TxType is equal to DCT_DCT or TxType is equal to DCT_ADST,
    apply an inverse DCT as follows:

      1. Invoke the inverse DCT permutation process as specified in
         section 8.7.1.2 with the input variable n.

      2. Invoke the inverse DCT process as specified in section 8.7.1.3
         with the input variable n.

  * Otherwise (TxType is equal to ADST_DCT or TxType is equal to ADST_ADST),
    invoke the inverse ADST process as specified in section 8.7.1.9 with input
    variable n.

  * If Lossless is equal to 1, set Dequant[ i ][ j ] equal to T[ i ]
    for i = 0..(n0-1).

  * Otherwise (Lossless is equal to 0), set Dequant[ i ][ j ] equal to
    Round2( T[ i ], Min( 6, n + 2 ) ) for i = 0..(n0-1).


### Loop Filter Process

Input to this process is the array CurrFrame of reconstructed samples.

Output from this process is a modified array CurrFrame containing deblocked
samples.

The purpose of the loop filter is to eliminate (or at least reduce) visually
objectionable artifacts associated with the semi-independence of the coding of
super blocks and their constituent sub-blocks.

First the loop filter frame init process specified in section 8.8.1 is invoked.

Then, the loop filter is applied on a raster scan order of superblocks as
follows:

~~~~~ c
for ( row = 0; row < MiRows; row += 8 )
    for ( col = 0; col < MiCols; col += 8 )
        for ( plane = 0; plane < 3; plane++ )
            for ( pass = 0; pass < 2; pass++ )
~~~~~

The superblock loop filter process specified in 8.8.2 is invoked with the
variables plane, pass, row, and col as inputs.

**Note:** The loop filter is an integral part of the decoding process, in that
the results of loop filtering are used in the prediction of subsequent frames.

**Note:** Because many samples will be filtered more than once, the order in
which edges are processed given above needs to be respected by any
implementation. Within a single edge, the samples can be filtered in parallel.

**Note:** The loop filter applies after the macroblocks have been
"reconstructed" (i.e., had their prediction summed with their residual);
correct decoding is predicated on the fact that already-constructed portions
of the current frame referenced via intra prediction are not yet filtered.


#### Loop Filter Frame Init Process

The output of this process is the table LvlLookup.

This process is invoked once per frame to prepare a filter strength lookup
table.

The variable nShift is set equal to loop_filter_level >> 5.

The following ordered steps apply for segment_id = 0..MAX_SEGMENTS-1:

  1. lvlSeg is set equal to loop_filter_level.

  2. If seg_feature_active( SEG_LVL_ALT_L ) is equal to 1 the following
     ordered steps apply:

     a. If segmentation_abs_or_delta_update is equal to 1, lvlSeg is set equal
        to FeatureData[ segment_id ][SEG_LVL_ALT_L ].

     b. If segmentation_abs_or_delta_update is equal to 0, lvlSeg is set equal
        to FeatureData[ segment_id ][SEG_LVL_ALT_L ] + loop_filter_level.

     c. lvlSeg is set equal to Clip3( 0, MAX_LOOP_FILTER, lvlSeg ).

  3. If loop_filter_delta_update is equal to 0, then
     LvlLookup[ segment_id ][ ref ][ mode ] is set equal to lvlSeg for
     ref = INTRA_FRAME..MAX_REF_FRAMES-1 and for
     mode = 0..MAX_MODE_LF_DELTAS-1.

  4. If loop_filter_delta_enabled is equal to 1, then the following applies:

     ~~~~~ c
     intraLvl = lvlSeg + (loop_filter_ref_deltas[ INTRA_FRAME ] << nShift)
     LvlLookup[ segment_id ][ INTRA_FRAME ][ 0 ] = Clip3( 0, MAX_LOOP_FILTER, intraLvl )
     for ( ref = LAST_FRAME; ref < MAX_REF_FRAMES; ref++ ) {
         for ( mode = 0; mode < MAX_MODE_LF_DELTAS; mode++ ) {
             interLvl = lvlSeg + (loop_filter_ref_deltas[ ref ] << nShift)
                               + (loop_filter_mode_deltas[ mode ] << nShift)
             LvlLookup[ segment_id ][ ref ][ mode ] = Clip3( 0, MAX_LOOP_FILTER, interLvl )
          }
      }
      ~~~~~

#### Superblock Loop Filter Process

The inputs to this process are:

  * a variable plane specifying whether we are filtering Y, U, or V samples,

  * a variable pass specifying the direction of the edges. pass equal to 0
    means we are filtering vertical block boundaries, and pass equal to 1
    means we are filtering horizontal block boundaries,

  * variables row and col specifying the location of the superblock in units
    of 8x8 blocks.

The outputs of this process are modified values in the array CurrFrame.

The variables subX and subY describing the subsampling of the current plane
are derived as follows:

  * If plane is equal to 0, subX and subY are set equal to 0.

  * Otherwise (plane is not equal to 0), subX is set equal to subsampling_x
    and subY is set equal to subsampling_y.

The variables dx, dy, sub, and edgeLen are derived as follows:

  * If pass is equal to 0, then dx is set equal to 1, dy is set equal to 0,
    sub is set equal to subX, edgeLen is set equal to 64 >> subY.

  * Otherwise (pass is equal to 1), dy is set equal to 1, dx is set equal
    to 0, sub is set equal to subY, edgeLen is set equal to 64 >> subX.

dx and dy specify the offset between the samples to be filtered.

sub is the subsampling factor in the direction of the filter (i.e.
perpendicular to the boundary being filtered).

edgeLen is the length of the boundary in samples (64 for luma, but fewer for
chroma when subsampling is being used).

For the variable edge taking values between 0 and (16 >> sub) - 1 (in
increasing order) and i taking values from 0 to edgeLen - 1, the following
ordered steps apply:

  1. The variables x and y (containing the location in luma coordinates) are
     derived as follows:

     * If pass is equal to 0, x is set equal to col * 8 + edge * (4 << subX),
       and y is set equal to row * 8 + (i << subY).

     * Otherwise (pass is equal to 1), x is set equal to col * 8 + (i <<
       subX), and y is set equal to row * 8 + edge * (4 << subY).

  2. Set the variable loopCol equal to ( (x >> 3) >> subX ) << subX.

  3. Set the variable loopRow equal to ( (y >> 3) >> subY ) << subY. (loopRow
     and loopCol specify the luma location in units of 8x8 blocks.)

  4. Set the variable MiSize equal to MiSizes[ loopRow ][ loopCol ].

  5. Set the variable tx_size equal to TxSizes[ loopRow ][ loopCol ].

  6. Set the variable txSz equal to (plane > 0) ? get_uv_tx_size( ) : tx_size.

  7. The variable sbSize is derived as follows:

     * If sub is equal to 0, set sbSize equal to MiSize.

     * Otherwise (sub is equal to 1), set sbSize equal to Max(BLOCK_16X16,
       MiSize).

  8. Set the variable skip equal to Skips[ loopRow ][ loopCol ].

  9. Set the variable isIntra equal to
     RefFrames[ loopRow ][ loopCol ][ 0 ] <= INTRA_FRAME.

  10. The variable isBlockEdge (equal to 1 if the samples cross a prediction
      block edge) is derived as follows:

      * If pass is equal to 0 and x is an exact multiple
        of 8*num8x8BlocksWideLookup[ sbSize ], isBlockEdge is set equal to 1.

      * Otherwise, if pass is equal to 1 and y is an exact multiple
        of 8*num8x8BlocksHighLookup[ sbSize ], isBlockEdge is set equal to 1.

      * Otherwise, isBlockEdge is set equal to 0.

  11. The variable isTxEdge (equal to 1 if the samples cross a transform block
      edge) is derived as follows:

      * If pass is equal to 1 and subX is equal to 1 and MiCols is odd and
        edge is odd and (x + 8) >= MiCols * 8, isTxEdge is set equal
        to 0. (This corresponds to a case when the horizontal boundary of a
        chroma block crosses the right hand edge of the image.)

      * Otherwise, if edge is an exact multiple of 1 << txSz, isTxEdge is set
        equal to 1.

      * Otherwise, isTxEdge is set equal to 0.

  12. The variable is32Edge (equal to 1 if the samples cross a 32 sample
      boundary) is derived as follows:

      * If edge is an exact multiple of 8, is32Edge is set equal to 1.

      * Otherwise, is32Edge is set equal to 0.

  13. The variable onScreen (equal to 1 if the samples on both sides of the
      boundary lie in the visible area) is derived as follows:

      * If x is greater than or equal to 8 * MiCols, onScreen is set equal
        to 0.

      * Otherwise, if y is greater than or equal to 8 * MiRows, onScreen is
        set equal to 0.

      * Otherwise, if pass is equal to 0 and x is equal to 0, onScreen is set
        equal to 0.

      * Otherwise, if pass is equal to 1 and y is equal to 0, onScreen is set
        equal to 0.

      * Otherwise, onScreen is set equal to 1.

  14. The variable applyFilter (equal to 1 if the samples are filtered) is
      derived as follows:

      * If onScreen is equal to 0, applyFilter is set equal to 0.

      * Otherwise, if isBlockEdge is equal to 1, applyFilter is set equal
        to 1.

      * Otherwise, if isTxEdge is equal to 1 and isIntra is equal to 1,
        applyFilter is set equal to 1.

      * Otherwise, if isTxEdge is equal to 1 and skip is equal to 0,
        applyFilter is set equal to 1.

      * Otherwise applyFilter is set equal to 0.

  15. The filter size process specified in 8.8.3 is invoked with the inputs
      txSz, is32Edge, pass, x, y, subX, and subY and the output assigned to
      the variable filterSize (containing the maximum filter size that can be
      used).

  16. The adaptive filter strength process specified in 8.8.4 is invoked with
      the inputs loopRow and loopCol, and the output assigned to the variables
      lvl, limit, blimit, and thresh.

  17. If applyFilter is equal to 1 and lvl is greater than zero, the sample
      filtering process specified in 8.8.5 is invoked with the input variable
      x set equal to x >> subX, the input variable y set equal to y >> subY,
      and the variables plane, limit, blimit, thresh, plane, dx, dy,
      filterSize.


#### Filter Size Process

The inputs to this process are:

  * a variable txSz specifying the size of the transform block,

  * a variable is32Edge that is equal to 1 if the boundary is at a multiple
    of    32 samples,

  * a variable pass specifying the direction of the edges,

  * variables x and y specifying the location in luma coordinates,

  * variables subX and subY describing the subsampling of the current plane.

The output of this process is the variable filterSize containing the maximum
filter size that can be used.

The purpose of this process is to reduce the width of the chroma filters if
the filter would cross the frame boundary. In addition, the filter size is
clipped to a minimum size of TX_8X8 for boundaries on a multiple of 32
samples.

The variable baseSize is derived as follows:

  * If txSz is equal to TX_4X4 and is32Edge is equal to 1, baseSize is set
    equal to TX_8X8.

  * Otherwise, baseSize is set equal to Min(TX_16X16, txSz).

The output variable filterSize is derived as follows:

  * If all of the following conditions are true, filterSize is set equal to
    TX_8X8:

    1. pass is equal to 0 (indicating we are filtering vertical boundaries),

    2. subX is equal to 1,

    3. baseSize is equal to TX_16X16,

    4. x >> 3 is equal to MiCols - 1.

  * Otherwise, if all of the following conditions are true, filterSize is set
    equal to TX_8X8:

    1. pass is equal to 1 (indicating we are filtering horizontal boundaries),

    2. subY is equal to 1,

    3. baseSize is equal to TX_16X16,

    4. y >> 3 is equal to MiRows - 1.

  * Otherwise, filterSize is set equal to baseSize.


#### Adaptive Filter Strength Process

The inputs to this process are the variables loopRow and loopCol specifying
the luma location in units of 8x8 blocks.

The outputs of this process are the variables lvl, limit, blimit, and thresh.

The output variable lvl is derived as follows:

  * The variable segment is set equal to SegmentIds[ loopRow ][ loopCol ].

  * The variable ref is set equal to RefFrames[ loopRow ][ loopCol ][ 0 ].

  * The variable mode is set equal to YModes[ loopRow ][ loopCol ].

  * The variable modeType is derived as follows:

    1. If mode is equal to NEARESTMV or NEARMV or NEWMV, modeType is set equal
       to 1.

    2. Otherwise (if mode is an intra type or ZEROMV), modeType is set equal
       to 0.

  * The variable lvl is set equal to
    LvlLookup[ segment_id ][ ref ][ modeType ].

The variable shift is derived as follows:

  * If loop_filter_sharpness is greater than 4, shift is set equal to 2.

  * Otherwise, if loop_filter_sharpness is greater than 0, shift is set equal
    to 1.

  * Otherwise, shift is set equal to 0.

The output variable limit is derived as follows:

  * If loop_filter_sharpness is greater than 0, limit is set equal to
    Clip3( 1, 9 - loop_filter_sharpness, lvl >> shift ).

  * Otherwise, limit is set equal to Max( 1, lvl >> shift ).

The output variable blimit is set equal to 2 * (lvl + 2) + limit.

The output variable thresh is set equal to lvl >> 4.


#### Sample Filtering Process

The inputs to this process are:

  * variables x and y specifying the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables limit, blimit, thresh that specify the strength of the filtering
    operation,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered,

  * a variable filterSize of specifying the maximum size of filter allowed.

The outputs of this process are modified values in the array CurrFrame.

First the filter mask process specified in section 8.8.5.1 is invoked with the
inputs x, y, plane, limit, blimit, thresh, dx, dy, and filterSize, and the
output is assigned to the variables hevMask, filterMask, flatMask, and
flatMask2.

Then the appropriate filter process is invoked with the inputs x, y, plane,
dx, dy as follows:

  * If filterMask is equal to 0, no filter is invoked.

  * Otherwise, if filterSize is equal to TX_4X4 or flatMask is equal to 0, the
    narrow filter process specified in section 8.8.5.2 is invoked with the
    additional input variable hevMask.

  * Otherwise, if filterSize is equal to TX_8X8 or flatMask2 is equal to 0,
    the wide filter process specified in section 8.8.5.3 is invoked with the
    additional input variable log2Size set to 3.

  * Otherwise, the wide filter process specified in section 8.8.5.3 is invoked
    with the additional input variable log2Size set to 4.


##### Filter Mask Process

The inputs to this process are:

  * variables x and y specifying the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables limit, blimit, thresh that specify the strength of the filtering
    operation,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered,

  * a variable filterSize of specifying the maximum size of filter allowed.

The outputs from this process are the variables:

  * hevMask,

  * filterMask,

  * flatMask, (only used if filterSize >= TX_8X8),

  * flatMask2 (only used if filterSize >= TX_16X16).

The values output for these masks depend on the differences between samples on
either side of the specified boundary. These samples are specified as follows:

~~~~~ c
q0 = CurrFrame[ plane ][ y ][ x ]
q1 = CurrFrame[ plane ][ y+dy ][ x+dx ]
q2 = CurrFrame[ plane ][ y+dy*2 ][ x+dx*2 ]
q3 = CurrFrame[ plane ][ y+dy*3 ][ x+dx*3 ]
q4 = CurrFrame[ plane ][ y+dy*4 ][ x+dx*4 ]
q5 = CurrFrame[ plane ][ y+dy*5 ][ x+dx*5 ]
q6 = CurrFrame[ plane ][ y+dy*6 ][ x+dx*6 ]
q7 = CurrFrame[ plane ][ y+dy*7 ][ x+dx*7 ]
p0 = CurrFrame[ plane ][ y-dy ][ x-dx ]
p1 = CurrFrame[ plane ][ y-dy*2 ][ x-dx*2 ]
p2 = CurrFrame[ plane ][ y-dy*3 ][ x-dx*3 ]
p3 = CurrFrame[ plane ][ y-dy*4 ][ x-dx*4 ]
p4 = CurrFrame[ plane ][ y-dy*5 ][ x-dx*5 ]
p5 = CurrFrame[ plane ][ y-dy*6 ][ x-dx*6 ]
p6 = CurrFrame[ plane ][ y-dy*7 ][ x-dx*7 ]
p7 = CurrFrame[ plane ][ y-dy*8 ][ x-dx*8 ]
~~~~~

**Note:** Samples q4, q5, q6, q7, p4, p5, p6 and p7 are only used if
filterSize is equal to TX_16X16.

The value of hevMask indicates whether the sample has high edge variance. It
is calculated as follows:

~~~~~ c
hevMask = 0
threshBd = thresh << (BitDepth - 8)
hevMask |= (Abs( p1 - p0 ) > threshBd)
hevMask |= (Abs( q1 - q0 ) > threshBd)
~~~~~

The value of filterMask indicates whether adjacent samples close to the
edge (within four samples either side of the specified boundary) vary by less
than the limits given by limit and blimit. It is used to determine if any
filtering should occur and is calculated as follows:

~~~~~ c
limitBd = limit << (BitDepth - 8)
blimitBd = blimit << (BitDepth - 8)
mask = 0
mask |= (Abs( p3 - p2 ) > limitBd)
mask |= (Abs( p2 - p1 ) > limitBd)
mask |= (Abs( p1 - p0 ) > limitBd)
mask |= (Abs( q1 - q0 ) > limitBd)
mask |= (Abs( q2 - q1 ) > limitBd)
mask |= (Abs( q3 - q2 ) > limitBd)
mask |= (Abs( p0 - q0 ) * 2 + Abs( p1 - q1 ) / 2 > blimitBd)
filterMask = (mask == 0)
~~~~~

The value of flatMask is only required when filterSize >= TX_8X8. It measures
whether at least four samples from each side of the specified boundary are in
a flat region. That is whether those samples are at most (1 << (BitDepth - 8))
different from the sample on the boundary. It is calculated as follows:

~~~~~ c
thresholdBd = 1 << (BitDepth - 8)
if ( filterSize >= TX_8X8 ) {
    mask = 0
    mask |= (Abs( p1 - p0 ) > thresholdBd)
    mask |= (Abs( q1 - q0 ) > thresholdBd)
    mask |= (Abs( p2 - p0 ) > thresholdBd)
    mask |= (Abs( q2 - q0 ) > thresholdBd)
    mask |= (Abs( p3 - p0 ) > thresholdBd)
    mask |= (Abs( q3 - q0 ) > thresholdBd)
    flatMask = (mask == 0)
}
~~~~~

The value of flatMask2 is only required when filterSize >= TX_16X16. It
measures whether at least eight samples from each side of the specified
boundary are in a flat region assuming the first four on each side are
(so the full region is flat if flatMask & flatMask2 == 0). The value of
flatMask2 is calculated as follows:

~~~~~ c
thresholdBd = 1 << (BitDepth - 8)
if ( filterSize >= TX_16X16 ) {
    mask = 0
    mask |= (Abs( p7 - p0 ) > thresholdBd)
    mask |= (Abs( q7 - q0 ) > thresholdBd)
    mask |= (Abs( p6 - p0 ) > thresholdBd)
    mask |= (Abs( q6 - q0 ) > thresholdBd)
    mask |= (Abs( p5 - p0 ) > thresholdBd)
    mask |= (Abs( q5 - q0 ) > thresholdBd)
    mask |= (Abs( p4 - p0 ) > thresholdBd)
    mask |= (Abs( q4 - q0 ) > thresholdBd)
    flatMask2 = (mask == 0)
}
~~~~~

##### Narrow Filter Process

The inputs to this filter are:

  * a variable hevMask specifying whether this is a high edge variance case,

  * variables x, y specifying the the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables limit, blimit, thresh that specify the strength of the filtering
    operation,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered.

This process modifies up to two samples on each side of the specified boundary
depending on the value of hevMask as follows:

  * If hevMask is equal to 0 (i.e. the samples do not have high edge
    variance), this process modifies two samples on each side of the specified
    boundary, using a filter constructed from just the inner two (one from
    each side of the specified boundary).

  * Otherwise (the samples do have high edge variance), this process only
    modifies the one value on each side of the specified boundary, using a
    filter constructed from four input samples (two from each side of the
    specified boundary).

The process subtracts 0x80 << (BitDepth - 8) from the input sample values so
that they are in the range -(1 << (BitDepth - 1))
to (1 << (BitDepth - 1)) - 1 inclusive. Intermediate values are made to be in
this range by the following function:

~~~~~ c
filter4_clamp( value ) {
    return Clip3( -(1 << (BitDepth - 1)), (1 << (BitDepth - 1)) - 1, value )
}
~~~~~

The process is specified as follows:

~~~~~ c
q0 = CurrFrame[ plane ][ y ][ x ]
q1 = CurrFrame[ plane ][ y+dy ][ x+dx ]
p0 = CurrFrame[ plane ][ y-dy ][ x-dx ]
p1 = CurrFrame[ plane ][ y-dy*2 ][ x-dx*2 ]
ps1 = p1 - (0x80 << (BitDepth - 8))
ps0 = p0 - (0x80 << (BitDepth - 8))
qs0 = q0 - (0x80 << (BitDepth - 8))
qs1 = q1 - (0x80 << (BitDepth - 8))
filter = hevMask ? filter4_clamp( ps1 - qs1 ) : 0
filter = filter4_clamp( filter + 3 * (qs0 - ps0) )
filter1 = filter4_clamp( filter + 4 ) >> 3
filter2 = filter4_clamp( filter + 3 ) >> 3
oq0 = filter4_clamp( qs0 - filter1 ) + (0x80 << (BitDepth - 8))
op0 = filter4_clamp( ps0 + filter2 ) + (0x80 << (BitDepth - 8))
CurrFrame[ plane ][ y ][ x ] = oq0
CurrFrame[ plane ][ y-dy ][ x-dx ] = op0
if ( !hevMask ) {
    filter = Round2( filter1, 1 )
    oq1 = filter4_clamp( qs1 - filter ) + (0x80 << (BitDepth - 8))
    op1 = filter4_clamp( ps1 + filter ) + (0x80 << (BitDepth - 8))
    CurrFrame[ plane ][ y+dy ][ x+dx ] = oq1
    CurrFrame[ plane ][ y-dy*2 ][ x-dx*2 ] = op1
}
~~~~~

##### Wide Filter Process

The inputs to this filter are:

  * variables x, y specifying the the location within CurrFrame[ plane ],

  * a variable plane specifying whether the block is the Y, U or V plane,

  * variables dx and dy specifying the direction perpendicular to the edge
    being filtered,

  * a variable log2Size specifying the base 2 logarithm of the number of taps.

This filter is only applied when samples from each side of the boundary are
detected to be in a flat region.

The variable n (specifying the number of filter taps on each side of the
central sample) is set equal to (1 << ( log2Size - 1 ) ) -1.

This process modifies the samples on each side of the specified boundary by
applying a low pass filter as follows:

~~~~~ c
for( i = -n; i < n; i++ ) {
    t = CurrFrame[ plane ][ y+i*dy ][ x+i*dx ]
    for( j = -n; j <= n; j++ ) {
        p = Clip3( -(n+1), n, i+j )
        t += CurrFrame[ plane ][ y+p*dy ][ x+p*dx ]
    }
    F[ i ] = Round2( t, log2Size )
}
for( i = -n; i < n; i++ )
    CurrFrame[ plane ][ y+i*dy ][ x+i*dx ] = F[ i ]
~~~~~

where F is an array with indices from -n to n-1 used to store the filtered
results.


### Output Process

This process is invoked to optionally display a frame.

If show_existing_frame is equal to 1, then the decoder should output a previously decoded frame as follows:

  * The variable w is set equal to RefFrameWidth[ frame_to_show_map_idx ].

  * The variable h is set equal to RefFrameHeight[ frame_to_show_map_idx ].

  * The variable subX is set equal to RefSubsamplingX[ frame_to_show_map_idx ].

  * The variable subY is set equal to RefSubsamplingY[ frame_to_show_map_idx ].

  * The Y plane is w samples across by h samples down and the sample at
    location x samples across and y samples down is given by
    FrameStore[ frame_to_show_map_idx ][ 0 ][ y ][ x ] with x = 0..w - 1
    and y = 0..h - 1.

  * The U plane is (w + subX) >> subX samples across by (h + subY) >> subY
    samples down and the sample at location x samples across and y samples
    down is given by FrameStore[ frame_to_show_map_idx ][ 1 ][ y ][ x ]
    with x = 0..((w + subX) >> subX) - 1 and y = 0..((h + subY) >> subY) - 1.

  * The V plane is (w + subX) >> subX samples across by (h + subY) >> subY
    samples down and the sample at location x samples across and y samples
    down is given by FrameStore[ frame_to_show_map_idx ][ 2 ][ x ][ y ]
    with x = 0..((w + subX) >> subX) - 1 and y = 0..((h + subY) >> subY) - 1.

  * The bit depth for each sample is RefBitDepth[ frame_to_show_map_idx ].
    Otherwise, if show_frame is equal to 1, then the decoder should output the
    current frame as follows:

  * The variable w is set equal to FrameWidth.

  * The variable h is set equal to FrameHeight.

  * The variable subX is set equal to subsampling_x.

  * The variable subY is set equal to subsampling_y.

  * The Y plane is w samples across by h samples down and the sample at
    location x samples across and y samples down is given by
    CurrFrame[ 0 ][ y ][ x ] with x = 0..w - 1 and y = 0..h - 1.

  * The U plane is (w + subX) >> subX samples across by (h + subY) >> subY
    samples down and the sample at location x samples across and y samples
    down is given by CurrFrame[ 1 ][ y ][ x ]
    with x = 0..((w + subX) >> subX) - 1 and y = 0..((h + subY) >> subY) - 1.

  * The V plane is (w + subX) >> subX samples across by (h + subY) >> subY
    samples down and the sample at location x samples across and y samples
    down is given by CurrFrame[ 2 ][ x ][ y ]
    with x = 0..((w + subX) >> subX) - 1 and y = 0..((h + subY) >> subY) - 1.

  * The bit depth for each sample is BitDepth.


### Reference Frame Update Process

This process is invoked as the final step in decoding a frame.

The inputs to this process are the samples in the current frame
CurrFrame[ plane ][ x ][ y ].

The output from this process is an updated set of reference frames and
previous motion vectors.

The following ordered steps apply:

  1. For each value of i from 0 to NUM_REF_FRAMES - 1, the following applies
     if bit i of refresh_frame_flags is equal to 1 (i.e.
     if (refresh_frame_flags>>i)&1 is equal to 1):

     * RefFrameWidth[ i ] is set equal to FrameWidth.

     * RefFrameHeight[ i ] is set equal to FrameHeight.

     * RefSubsamplingX[ i ] is set equal to subsampling_x.

     * RefSubsamplingY[ i ] is set equal to subsampling_y.

     * RefBitDepth[ i ] is set equal to BitDepth.

     * FrameStore[ i ][ 0 ][ y ][ x ] is set equal to CurrFrame[ 0 ][ y ][ x ]
       for x = 0..FrameWidth-1, for y = 0..FrameHeight-1.

     * FrameStore[ i ][ plane ][ y ][ x ] is set equal to
       CurrFrame[ plane ][ y ][ x ] for plane = 1..2,
       for x = 0..((FrameWidth+subsampling_x) >> subsampling_x)-1,
       for y = 0..((FrameHeight+subsampling_y) >> subsampling_y)-1.

  2. If show_existing_frame is equal to 0, the following applies:

     * PrevRefFrames[ row ][ col ][ list ] is set equal to
       RefFrames[ row ][ col ][ list ] for row = 0..MiRows-1,
       for col = 0..MiCols-1, for list = 0..1.

     * PrevMvs[ row ][ col ][ list ][ comp ] is set equal to
       Mvs[ row ][ col ][ list ][ comp ] for row = 0..MiRows-1,
       for col = 0..MiCols-1, for list = 0..1, for comp = 0..1.
