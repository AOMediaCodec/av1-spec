## Bitstream Semantics

This section specifies the meaning of the syntax elements read in the syntax
structures.


### Frame Semantics

The bitstream consists of a sequence of coded frames.

Each coded frame is given to the decoding process in turn as a bitstream along
with a variable sz that gives the total number of bytes in the coded frame.

Methods of framing the coding frames in a container format are outside the
scope of this Specification. However, one common method of packing several
frames into a single superframe is described in Annex B.

**padding_bit** shall be equal to 0.


#### Trailing Bits Semantics

**zero_bit** shall be equal to 0 and is inserted into the bitstream to align
the bit position to a multiple of 8 bits.


#### Refresh Probs Semantics

**load_probs( ctx )** is a function call that indicates that the probability
tables are loaded from frame context number ctx in the range 0 to (FRAME_CONTEXTS - 1). When this
function is invoked the following takes place:

  * A copy of each probability table (except tx_probs and SkipProbs) is loaded
    from an area of memory indexed by ctx. (The memory contents of these frame
    contexts have been initialized by previous calls to save_probs).

  * A copy of each CDF array mentioned in the semantics for setup_past_independence is loaded
    from an area of memory indexed by ctx. (The memory contents of these frame
    contexts have been initialized by previous calls to save_probs).

**load_probs2( ctx )** is a function call that indicates that the probability
tables tx_probs and SkipProbs are loaded from frame context number ctx in the
range 0 to (FRAME_CONTEXTS - 1). When this function is invoked the following takes place:

  * A copy of the probability tables called tx_probs and SkipProbs are loaded
    from an area of memory indexed by ctx.

**adapt_probs** is a function call that indicates that the
probabilities are adjusted based on the observed counts. This process is described
in [section 8.4.3][].

**average_cdf** is a function call that indicates that the
CDF arrays are set equal to the average of the CDFs at the end of each tile. This process is described in [section 8.4.4][].

**clear_counts** is a function call that indicates that all the counters for
different syntax elements are reset to 0. This process is described in [section 8.3][].


### Uncompressed Header Semantics

**frame_marker** shall be equal to 2.

**profile_low_bit** and **profile_high_bit** combine to make the variable
Profile. AV1 supports 4 profiles:


| Profile | Bit depth | SRGB Colorspace support | Chroma subsampling
| ------- | --------- | ----------------------- | ------------------
| 0       | 8         | No                      | YUV 4:2:0
| 1       | 8         | Yes                     | YUV 4:2:2, YUV 4:4:0 or YUV 4:4:4
| 2       | 10 or 12  | No                      | YUV 4:2:0
| 3       | 10 or 12  | Yes                     | YUV 4:2:2, YUV 4:4:0 or YUV 4:4:4
{:.table }


**reserved_zero** shall be equal to 0.

**show_existing_frame** equal to 1, indicates the frame indexed by
frame_to_show_map_idx is to be displayed; show_existing_frame equal to 0
indicates that further processing is required.

**frame_to_show_map_idx** specifies the frame to be displayed. It is only
available if show_existing_frame is 1.

**LastFrameType** contains the frame_type for the previous frame.

**Note:** LastFrameType is undefined for the first frame, but this does not
cause a problem as the first frame will be an intra frame and in this case the
value for LastFrameType is not accessed.

**frame_type** equal to 0 indicates that the current frame is a key frame;
frame_type equal to 1 indicates that the current frame is not a key frame (it
is therefore an inter frame or an intra-only frame).


| frame_type | Name of frame_type
| ---------- | ------------------
| 0          | KEY_FRAME
| 1          | NON_KEY_FRAME
{:.table }


It is possible for bitstreams to start with a non key frame and still be
decodable. In this case there are a number of additional constraints on the
bitstream that are detailed in [section 8.2][].

**error_resilient_mode** equal to 1 indicates that error resilient mode is
enabled; error_resilient_mode equal to 0 indicates that error resilient mode
is disabled.

**Note:** Error resilient mode allows the syntax of a frame to be decoded
independently of previous frames.

**intra_only** equal to 1 indicates that the frame is an intra-only frame;
intra_only equal to 0 indicates that the frame is an inter frame.

**allow_screen_content_tools** equal to 1 indicates that intra blocks may use palette encoding; allow_screen_content_tools equal to 0
indicates that palette encoding is never used.

**intra_reset_all** equal to 1 indicates that all contexts should be reset; intra_reset_all equal to 0 indicates that only the context in the frame header should be reset.

**reset_frame_context** specifies whether the frame contexts are reset to
default values:

  * 0 means do not reset any frame context
  * 1 resets just the context specified in the frame header
  * 2 resets all contexts.

**refresh_frame_flags** contains a bitmask that specifies which reference frame
slots will be updated with the current frame after it is decoded.

See [section 8.12][] for details of the frame update process.

**ref_frame_idx** specifies which reference frames are used by inter frames. It
is a requirement of bitstream conformance that the selected reference frames
match the current frame in bit depth, profile, chroma subsampling, and color
space.

**ref_frame_sign_bias** specifies the intended direction of the motion vector
in time for each reference frame. A sign bias equal to 0 indicates that the
reference frame is a backwards reference; a sign bias equal to 1 indicates that
the reference frame is a forwards reference.

**Note:** The sign bias is just an indication that can improve the accuracy of
motion vector prediction and is not constrained to reflect the actual output
order of pictures.

**allow_high_precision_mv** equal to 0 specifies that motion vectors are
specified to quarter pel precision; allow_high_precision_mv equal to 1
specifies that motion vectors are specified to eighth pel precision.

**frame_context_idx** indicates the frame context to use.

**AllLossless** is a variable that is equal to 1 when all segments use lossless encoding.

**reduced_tx_set** equal to 1 specifies that the frame is restricted to a reduced subset
of the full set of transform types.

**header_size_in_bytes** indicates the size of the compressed header in bytes.

**setup_past_independence** is a function call that indicates that this frame
can be decoded without dependence on previous coded frames. When this function
is invoked the following takes place:

  * FeatureData[ i ][ j ] and FeatureEnabled[ i ][ j ] are set equal to 0 for
    i = 0..7 and j = 0..3.

  * segmentation_abs_or_delta_update is set equal to 0.

  * PrevSegmentIds[ row ][ col ] is set equal to 0 for row = 0..MiRows-1 and
    col = 0..MiCols-1.

  * loop_filter_delta_enabled is set equal to 1.

  * loop_filter_ref_deltas[ INTRA_FRAME ] is set equal to 1.

  * loop_filter_ref_deltas[ LAST_FRAME ] is set equal to 0.
  
  * loop_filter_ref_deltas[ LAST2_FRAME ] is set equal to 0.
  
  * loop_filter_ref_deltas[ LAST3_FRAME ] is set equal to 0.
  
  * loop_filter_ref_deltas[ BWDREF_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ GOLDEN_FRAME ] is set equal to -1.

  * loop_filter_ref_deltas[ ALTREF_FRAME ] is set equal to -1.
  
  * loop_filter_ref_deltas[ ALTREF2_FRAME ] is set equal to -1.

  * loop_filter_mode_deltas[ i ] is set equal to 0 for i = 0..1.

  * The probability tables are reset to default values. The default values are
    specified in [section 10.3][].
    
  * The cumulative distribution function arrays are reset to default values as follows:
  
    * IntraFrameYModeCdf is set to a copy of default_intra_frame_y_mode_cdf
    
    * YModeCdf is set to a copy of default_y_mode_cdf
    
    * UVModeCdf is set to a copy of default_uv_mode_cdf
    
    * PartitionCdf is set to a copy of default_partition_cdf
    
    * SegmentIdCdf is set to a copy of default_segment_id_cdf
    
    * Tx8x8Cdf is set to a copy of default_tx_8x8_cdf
    
    * Tx16x16Cdf is set to a copy of default_tx_16x16_cdf
    
    * Tx32x32Cdf is set to a copy of default_tx_32x32_cdf
    
    * InterpFilterCdf is set to a copy of default_interp_filter_cdf
    
    * NewMvCdf is set to a copy of default_new_mv_cdf
    
    * ZeroMvCdf is set to a copy of default_zero_mv_cdf
    
    * RefMvCdf is set to a copy of default_ref_mv_cdf
    
    * CompoundModeCdf is set to a copy of default_compound_mode_cdf
    
    * DrlModeCdf is set to a copy of default_drl_mode_cdf
    
    * MvJointCdf[ i ] is set to a copy of default_mv_joint_cdf for i = 0..MV_CONTEXTS
    
    * MvClassCdf[ i ] is set to a copy of default_mv_class_cdf for i = 0..MV_CONTEXTS
    
    * MvFrCdf[ i ] is set to a copy of default_mv_fr_cdf for i = 0..MV_CONTEXTS
    
    * MvClass0FrCdf[ i ] is set to a copy of default_mv_class0_fr_cdf for i = 0..MV_CONTEXTS
  
    * TailTokenCdf is set to a copy of default_tail_token_cdf
    
    * AcHeadTokenCdf is set to a copy of default_ac_head_token_cdf
    
    * DcHeadTokenCdf is set to a copy of default_dc_head_token_cdf
    
    * PaletteYSizeCdf is set to a copy of default_palette_y_size_cdf
    
    * PaletteUVSizeCdf is set to a copy of default_palette_uv_size_cdf
    
    * PaletteSize2YColorCdf is set to a copy of default_palette_size_2_y_color_cdf
    
    * PaletteSize2UVColorCdf is set to a copy of default_palette_size_2_uv_color_cdf
    
    * PaletteSize3YColorCdf is set to a copy of default_palette_size_3_y_color_cdf
    
    * PaletteSize3UVColorCdf is set to a copy of default_palette_size_3_uv_color_cdf
    
    * PaletteSize4YColorCdf is set to a copy of default_palette_size_4_y_color_cdf
    
    * PaletteSize4UVColorCdf is set to a copy of default_palette_size_4_uv_color_cdf
    
    * PaletteSize5YColorCdf is set to a copy of default_palette_size_5_y_color_cdf
    
    * PaletteSize5UVColorCdf is set to a copy of default_palette_size_5_uv_color_cdf
    
    * PaletteSize6YColorCdf is set to a copy of default_palette_size_6_y_color_cdf
    
    * PaletteSize6UVColorCdf is set to a copy of default_palette_size_6_uv_color_cdf
    
    * PaletteSize7YColorCdf is set to a copy of default_palette_size_7_y_color_cdf
    
    * PaletteSize7UVColorCdf is set to a copy of default_palette_size_7_uv_color_cdf
    
    * PaletteSize8YColorCdf is set to a copy of default_palette_size_8_y_color_cdf
    
    * PaletteSize8UVColorCdf is set to a copy of default_palette_size_8_uv_color_cdf
    
    * DeltaQCdf is set to a copy of default_delta_q_cdf

    * DeltaLFCdf is set to a copy of default_delta_lf_cdf
    
    * IntraTxTypeSet1Cdf is set to a copy of default_intra_tx_type_set1_cdf
    
    * IntraTxTypeSet2Cdf is set to a copy of default_intra_tx_type_set2_cdf
    
    * InterTxTypeSet1Cdf is set to a copy of default_inter_tx_type_set1_cdf
    
    * InterTxTypeSet2Cdf is set to a copy of default_inter_tx_type_set2_cdf
    
    * InterTxTypeSet3Cdf is set to a copy of default_inter_tx_type_set3_cdf

**save_probs( ctx )** is a function call that indicates that indicates that all
the probability tables and CDF arrays are saved into frame context number ctx in the range 0
to (FRAME_CONTEXTS - 1). When this function is invoked the following takes place:

A copy of each probability table and CDF array mentioned in the semantics for setup_past_independence is saved in an area of memory indexed by ctx. The memory contents of these
frame contexts are persistent in order to allow a subsequent inter frame to reload the probability tables.


#### Color Config Semantics

**ten_or_twelve_bit** equal to 1 indicates the bit depth is 12 bits;
ten_or_twelve_bit equal to 0 indicates that the bit depth is 10 bits.

**color_space** specifies the color space of the stream:


| color_space | Name of color space | Description
|:-----------:|:-------------------:| -----------
| 0           | CS_UNKNOWN          | Unknown (in this case the color space must be signaled outside the AV1 bitstream).
| 1           | CS_BT_601           | Rec. ITU-R BT.601-7
| 2           | CS_BT_709           | Rec. ITU-R BT.709-6
| 3           | CS_SMPTE_170        | SMPTE-170
| 4           | CS_SMPTE_240        | SMPTE-240
| 5           | CS_BT_2020_NCL      | Rec. ITU-R BT.2020-2 (nonconstant luminance)
| 6           | CS_BT_2020_CL       | Rec. ITU-R BT.2020-2 (constant luminance)
| 7           | CS_ICTCP            | Rec. ITU-R BT.2100-0
| 8           | CS_SRGB             | sRGB (IEC 61966-2-1)
| 9..31       | CS_RESERVED         | Reserved
{:.table }

It is a requirement of bitstream conformance that color_space is not equal to
CS_SRGB when profile_low_bit is equal to 0.

**transfer_function** specifies specifies opto-electronic characteristics of the source video:

| transfer_function | Name of transfer function| Description
|:-----------------:|:-------------------------: -----------
| 0                 | TF_UNKNOWN               | Unknown (in this case the source video transfer function must be signaled outside the AV1 bitstream).
| 1                 | TF_BT_709                | Rec. ITU-R BT.709-6, Rec. ITU-R BT.601-7 525 or 625, Rec. ITU-R BT.2020
| 2                 | TF_PQ                    | SMPTE ST 2084:2014 / BT.2100 PQ
| 3                 | TF_HLG                   | BT.2100 Hybrid Log-Gamma (HLG)
| 4..31             | TF_RESERVED              | 
{:.table }

**color_range** specifies the black level and range of the luma and chroma
signals as specified in Rec. ITU-R BT.709-6 and Rec. ITU-R BT.2020-2:


| color_range | Description   | Details
| ----------- | ------------- | -------
| 0           | Studio swing  | For BitDepth equals 8:<br> Y is between 16 and 235 inclusive.<br> U and V are between 16 and 240 inclusive.
|             |               | For BitDepth equals 10:<br>Y is between 64 and 940 inclusive.<br>U and V are between 64 and 960 inclusive.
|             |               | For BitDepth equals 12:<br>Y is between 256 and 3760.<br>U and V are between 256 and 3840 inclusive.
| 1           | Full swing    | No restriction on Y, U, V values.
{:.table }


**Note:** Note that this specification does not enforce the range of YUV values
when the YUV range is signaled as Studio swing. Therefore the application
should perform additional clamping and color conversion operations according to
the specified range.

**subsampling_x**, **subsampling_y** specify the chroma subsampling format:


| subsampling_x | subsampling_y | Description
| ------------- | ------------- | -----------
| 0             | 0             | YUV 4:4:4
| 0             | 1             | YUV 4:4:0
| 1             | 0             | YUV 4:2:2
| 1             | 1             | YUV 4:2:0
{:.table }


It is a requirement of bitstream conformance that either subsampling_x is equal
to 0 or subsampling_y is equal to 0 when profile_low_bit is equal to 1.

**Note:** In Chroma subsampling format 4:2:2, AV1 assumes that chroma
samples are co-located with luma samples if there is no explicit signaling
outside of the AV1 bitstream. When there is explicit signaling at the container
level, the signaled information overrides AV1's default assumption.

**reserved_zero** shall be equal to 0.

**chroma_sample_position** specifies the sample position for 4:2:0 streams:

| chroma_sample_position | Name of chroma sample position| Description
|:----------------------:|:------------------------------: -----------
| 0                      | CSP_UNKNOWN                   | Unknown (in this case the source video transfer function must be signaled outside the AV1 bitstream)
| 1                      | CSP_VERTICAL                  | Horizontally co-located with (0, 0) luma sample, vertical position in the middle between two luma samples
| 2                      | CSP_COLOCATED                 | co-located with (0, 0) luma sample   
| 3                      | CSP_RESERVED                  | 
{:.table }


#### Frame Size Semantics

**frame_width_minus_1** plus one is the width of the frame in pixels.

**frame_height_minus_1** plus one is the height of the frame in pixels.


#### Render Size Semantics

The render size is provided as a hint to the application about the desired
display size. It has no effect on the decoding process.

**render_and_frame_size_different** equal to 0 means that the render width and
height are inferred from the frame width and height.
render_and_frame_size_different equal to 1 means that the render width and
height are explicitly coded in the bitstream.

**Note:** It is legal for the bitstream to explicitly code the render
dimensions in the bitstream even if they are an exact match for the frame
dimensions.

**render_width_minus_1** plus one is the render width of the frame in pixels.

**render_height_minus_1** plus one is the render height of the frame in pixels.


#### Frame Size with Refs Semantics

For inter frames, the frame size is either set equal to the size of a reference
frame, or can be sent explicitly.

**found_ref** equal to 1 indicates that the frame dimensions can be inferred
from reference frame i where i is the loop counter in the syntax parsing
process for frame_size_with_refs. found_ref equal to 0 indicates that the
frame dimensions are not inferred from reference frame i.

Once the FrameWidth and FrameHeight have been computed for an inter frame, it
is a requirement of bitstream conformance that for at least one value of i in
the range 0..2, all the following conditions are true:

  * 2 * FrameWidth >= RefFrameWidth[ ref_frame_idx[ i ] ]
  * 2 * FrameHeight >= RefFrameHeight[ ref_frame_idx[ i ] ]
  * FrameWidth <= 16 * RefFrameWidth[ ref_frame_idx[ i ] ]
  * FrameHeight <= 16 * RefFrameHeight[ ref_frame_idx[ i ] ]

**Note:** This is a requirement even if all the blocks in an inter frame are
coded using intra prediction.


#### Compute Image Size Semantics

When compute_image_size is invoked, the following ordered steps occur:

  1. If this is the first time compute_image_size is invoked, or if either
     FrameWidth or FrameHeight have changed in value compared to the previous
     time this function was invoked, then the segmentation map is cleared to
     all zeros by setting SegmentId[ row ][ col ] equal to 0 for row =
     0..MiRows-1 and col = 0..MiCols-1.

  2. The variable UsePrevFrameMvs is set equal to 1 if all of the following
     conditions are true:

     a. This is not the first time compute_image_size is invoked.

     b. Both FrameWidth and FrameHeight have the same value compared to the
        previous time this function was invoked.

     c. show_frame was equal to 1 the previous time this function was invoked.

     d. error_resilient_mode is equal to 0.

     e. FrameIsIntra is equal to 0.

     Otherwise, UsePrevFrameMvs is set equal to 0.

**Note:** compute_image_size is not invoked and therefore segmentation map is
not cleared when show_existing_frame is equal to 1 even if the shown frame has
different dimensions.


#### Interpolation Filter Semantics

**is_filter_switchable** equal to 1 indicates that the filter selection is
signaled at the block level; is_filter_switchable equal to 0 indicates that the
filter selection is signaled at the frame level.

**interpolation_filter** specifies the filter selection used for performing
inter prediction:


| interpolation_filter  | Name of interpolation_filter
|:---------------------:|:----------------------------:
| 0                     | EIGHTTAP
| 1                     | EIGHTTAP_SMOOTH
| 2                     | EIGHTTAP_SHARP
| 3                     | BILINEAR
| 4                     | SWITCHABLE
{:.table }


#### Loop Filter Semantics

**loop_filter_level** indicates the loop filter strength.

**loop_filter_sharpness** indicates the sharpness level. The loop_filter_level
and loop_filter_sharpness together determine when a block edge is filtered, and
by how much the filtering can change the sample values.

The loop filter process is described in [section 8.9][].

**loop_filter_delta_enabled** equal to 1 means that the filter level depends on
the mode and reference frame used to predict a block. loop_filter_delta_enabled
equal to 0 means that the filter level does not depend on the mode and
reference frame.

**loop_filter_delta_update** equal to 1 means that the bitstream contains
additional syntax elements that specify which mode and reference frame deltas
are to be updated. loop_filter_delta_update equal to 0 means that these syntax
elements are not present.

**update_ref_delta** equal to 1 means that the bitstream contains the syntax
element loop_filter_ref_delta; update_ref_delta equal to 0 means that the
bitstream does not contain this syntax element.

**loop_filter_ref_deltas** contains the adjustment needed for the filter level
based on the chosen reference frame. If this syntax element is not present in
the bitstream, it maintains its previous value.

**update_mode_delta** equal to 1 means that the bitstream contains the syntax
element loop_filter_mode_deltas; update_mode_delta equal to 0 means that the
bitstream does not contain this syntax element.

**loop_filter_mode_deltas** contains the adjustment needed for the filter level
based on the chosen mode. If this syntax element is not present in the
bitstream, it maintains its previous value.

**Note:** The previous values for loop_filter_mode_deltas and
loop_filter_ref_deltas are intially set by the setup_past_independence function
and can be subsequently modified by these syntax elements being coded in a
previous frame.


#### Quantization Params Semantics

The residual is specified via decoded coefficients which are adjusted by one of
four quantization parameters before the inverse transform is applied. The
choice depends on the plane (Y or UV) and coefficient position (DC/AC
coefficient). The Dequantization process is specified in [section 8.7][].

**base_q_idx** indicates the base frame qindex. This is used for Y AC
coefficients and as the base value for the other quantizers.

**deltaQYDc** indicates the Y DC quantizer relative to base_q_idx.

**deltaQUVDc** indicates the UV DC quantizer relative to base_q_idx.

**deltaQUVAc** indicates the UV AC quantizer relative to base_q_idx.

**using_qmatrix** specifies that the quantizer matrix will be used to
compute quantizers.

**min_qmlevel** specifies the smallest level in the quantizer matrix that
may be used.

**max_qmlevel** specifies the largest level in the quantizer matrix that
may be used.


#### Delta Quantizer Semantics

**delta_coded** specifies that the delta_q syntax element is present in the
bitstream.

**delta_q** specifies an offset (relative to base_q_idx) for a particular
quantization parameter.


#### Segmentation Params Semantics

AV1 provides a means of segmenting the image and then applying various
adjustments at the segment level.

Up to 8 segments may be specified for any given frame. For each of these
segments it is possible to specify:

  1. A quantizer (absolute value or delta).
  2. A loop filter strength (absolute value or delta).
  3. A prediction reference frame.
  4. A block skip mode that implies both the use of a (0,0) motion vector and
     that no residual will be coded.

Each of these data values for each segment may be individually updated at the
frame level. Where a value is not updated in a given frame, the value from the
previous frame persists. The exceptions to this are key frames, intra only
frames or other frames where independence from past frame values is required
(for example to enable error resilience). In such cases all values are reset
as described in the semantics for setup_past_independence.

The segment affiliation (the segmentation map) is stored at the resolution of
4x4 blocks. If no explicit update is coded for a block's segment affiliation,
then it persists from frame to frame (until reset by a call to
setup_past_independence).

**segmentation_enabled** equal to 1 indicates that this frame makes use of the
segmentation tool; segmentation_enabled equal to 0 indicates that the frame
does not use segmentation.

**segmentation_update_map** equal to 1 indicates that the segmentation map are
updated during the decoding of this frame. segmentation_update_map equal to 0
means that the segmentation map from the previous frame is used.

**segmentation_temporal_update** equal to 1 indicates that the updates to the
segmentation map are coded relative to the existing segmentation map.
segmentation_temporal_update equal to 0 indicates that the new
segmentation map is coded without reference to the existing segmentation map.

**segmentation_update_data** equal to 1 indicates that new parameters are about
to be specified for each segment. segmentation_update_data equal to 0 indicates
that the segmentation parameters should keep their existing values.

**segmentation_abs_or_delta_update** equal to 0 indicates that the segmentation
parameters represent adjustments relative to the standard values.
segmentation_abs_or_delta_update equal to 1 indicates that the segmentation
parameters represent the actual values to be used.

**feature_enabled** equal to 0 indicates that the corresponding feature is
unused and has value equal to 0. feature_enabled equal to 1 indicates that the
feature value is coded in the bitstream.

**feature_value** specifies the magnitude of the feature data for a segment
feature.

**feature_sign** equal to 1 indicates that the feature data is given by
-feature_value. feature_sign equal to 0 indicates that the feature data is
given by feature_value. It is a requirement of bitstream conformance that
feature_sign is equal to 0 when segmentation_abs_or_delta_update is equal to 1.


#### Tile Info Semantics

**increment_tile_cols_log2** indicates whether the tile width is increased.

**TileColsLog2** specifies the base 2 logarithm of the desired number of tiles across the frame.

It is a requirement of bitstream conformance that tile_cols_log2 is less than
or equal to 6.

**tile_rows_log2** and **increment_tile_rows_log2** are used to compute TileRowsLog2.

**TileRowsLog2** specifies the base 2 logarithm of the desired number of tiles down the frame.

**Note:** For small frame sizes the actual number of tiles in the frame may be smaller than the desired number
because the tile size is rounded up to a multiple of the maximum superblock size.

**dependent_tiles** equal to 0 indicates that there are no syntax dependencies between tiles,
dependent_tiles equal to 1 indicates that there can be dependencies between tiles.

**Note:** When dependent_tiles is equal to 1, the context determination, motion vector prediction,
and intra prediction are allowed to depend on the tile above, but only if the tile above is in the same tile group.

**loop_filter_across_tiles** equal to 1 indicates that loop filtering is allowed across tile edges.
loop_filter_across_tiles equal to 0 indicates that loop filtering is not allowed across tile edges (unless dependent_tiles is equal to 1, in which case loop filtering
is allowed across tile edges for horizontal boundaries, but not across tile group edges).

**tile_size_bytes_minus_1** is used to compute TileSizeBytes.

**TileSizeBytes** specifies the number of bytes needed to code each tile size.

**tg_start** specifies the zero-based index of the first tile in the current tile group.

**tg_size_minus_1** is used to compute TgSize.

**TgSize** specifies the number of tiles in the current tile group.

**MaxSbTileWidth** specifies the width of each tile in units of maximum superblock size.

**MaxSbTileHeight** specifies the height of each tile in units of maximum superblock size.


#### Quantizer Index Delta Parameters Semantics

**delta_q_present** specifies whether quantizer index delta values are present in the bitstream.

**delta_q_res** specifies the left shift which should be applied to decoded quantizer index delta values.


#### Loop Filter Delta Parameters Semantics

**delta_lf_present** specifies whether loop filter delta values are present in the bitstream.

**delta_lf_res** specifies the left shift which should be applied to decoded loop filter delta values.

#### Global Motion Params Semantics

**is_global** specifies whether global motion parameters are present for a particular reference frame.

**is_rot_zoom** specifies whether a particular reference frame uses rotation and zoom global motion.

**is_translation** specifies whether a particular reference frame uses translation global motion.

#### Global Param Semantics

**absBits** is used to compute the range of values that can be used for this parameter.  The values allowed are in the range -(1 << absBits) to (1 << absBits).

**precBits** specifies the number of fractional bits used for representing this parameter in the bitstream.
All global motion parameters are stored in the model with WARPEDMODEL_PREC_BITS fractional bits, but the parameters are encoded with less precision in the bitstream.

#### Decode Subexp Semantics

**subexp_more_bits** equal to 0 specifies that the parameter is in the range mk to mk+a-1.  subexp_more_bits equal to 0 specifies that the parameter is greater than mk+a-1.

**subexp_bits** specifies the value of the parameter minus mk.

#### Decode Uniform Semantics

**v** and **extra_bit* are used to compute the value of an unsigned number in the range 0 to n-1.

### Compressed Header Semantics

The compressed header specifies the transform mode and updates to the
probability tables.


#### TX Mode Semantics

**tx_mode** specifies how the transform size is determined:


| tx_mode | Name of tx_mode
|:-------:|:---------------:
| 0       | ONLY_4X4
| 1       | ALLOW_8X8
| 2       | ALLOW_16X16
| 3       | ALLOW_32X32
| 4       | TX_MODE_SELECT
{:.table }


For tx_mode not equal to 4, the inverse transform will use the largest
transform size possible up to the limit set in tx_mode. For tx_mode equal to 4,
the choice of size is specified explicitly for each block.

**tx_mode_select** equal to 1 indicates that the transform mode is specified
within each mode info header. tx_mode_select equal to 0 indicates that the
transform mode is computed based on the size of the block and the maximum
transform size allowed by the frame header.


#### Diff Update Prob Semantics

**update_prob** equal to 1 indicates that an adjustment to the probability is
coded in the bitstream; update_prob equal to 0 indicates that the previous
value for probability are used.


#### Decode Term Subexp Semantics

**bit**, **sub_exp_val**, **sub_exp_val_minus_16**, **sub_exp_val_minus_32**,
**v** are combined to specify an adjustment to a probability in such a way that
fewer bits are required to specify small adjustments.


#### Inv Remap Prob Semantics

**deltaProb** is passed into this function to indicate how much the probability
are adjusted. It is a requirement of bitstream conformance that the value of
deltaProb is strictly less than MAX_PROB.


#### Coef Prob Semantics

**update_probs** equal to 1 indicates that the coefficient probabilities are
adjusted. update_probs equal to 0 indicates that the coefficient probabilities
should maintain their previous values.

The variable coefProbs specifies a set of probability models to be used for
transform coefficients decoding. When frame parallel mode is turned off, it
first runs backward update according to the previous frame decoding
information. It then goes through forward probability model update via
diff_update_prob, where it reads the difference in probabilities from the
bit-stream and adjust the effective model accordingly.


#### Frame Reference Mode Semantics

**reference_select** equal to 1 specifies that the mode info for inter blocks
contains the syntax element comp_mode that indicates whether to use single or
compound reference prediction. Reference_select equal to 0 specifies that all
inter blocks will use single or compound reference prediction.

**non_single_reference** equal to 0 specifies that single reference prediction
will be used. non_single_reference equal to 1 specifies that compound reference
prediction will be used.

**ReferenceMode** is a variable that specifies the type of inter prediction to
be used:


| ReferenceMode  | Name of ReferenceMode
|:---------------:|:----------------------:
| 0               | SINGLE_REFERENCE
| 1               | COMPOUND_REFERENCE
| 2               | REFERENCE_MODE_SELECT
{:.table }


**SINGLE_REFERENCE** indicates that all the inter blocks use only a single
reference frame to generate motion compensated prediction.

**COMPOUND_REFERENCE** requires all the inter blocks to use compound mode.
Single reference frame prediction is not allowed.

**REFERENCE_MODE_SELECT** allows each individual inter block to select between
single and compound prediction modes.

**allow_interintra_compound** equal to 1 specifies that the mode info for inter
blocks may contain the syntax element interintra. allow_interintra_compound equal to 0 specifies that
the syntax element interintra will not be present in this frame.

**allow_masked_compound** equal to 1 specifies that the mode info for inter blocks may contain the syntax element compound_type.
allow_masked_compound equal to 0 specifies that the syntax element compound_type will not be present in this frame.


### Tile Level


#### Decode Tiles Semantics

**NumTiles** specifies the total number of tiles in the frame.

**TileNum** is a variable giving the index (zero-based) of the current tile.

**tile_group_header** is a function call that indicates that the tile group header
should be inserted into the bitstream.  The bits in the tile group header 
are exactly the same as the bits sent for the uncompressed header syntax except for the values of tg_start and tg_size_minus_1.

It is a requirement of bitstream conformance that the value of tg_start (in the tile group header)
is equal to the value of TileNum at the point that tile_group_header is invoked.

It is a requirement of bitstream conformance that the contents of each tile group header
are identical to the contents of the uncompressed header, except for the syntax elements
tg_start and tg_size_minus_1.

It is a requirement of bitstream conformance that the value of TgSize is equal to zero when
the decode_tiles function returns. 

**tile_size** specifies the size in bytes of the next coded tile.

**Note:** This size includes any padding bytes added by the exit process for the Boolean decoder.
The size does not include the bytes used for tile_group_header, trailing_bits, and tile_size.

**AboveSameTileGroup** is a variable that specifies if the tile above is in the same tile group.


#### Decode Tile Semantics

**clear_left_context** is a function call that indicates that some arrays used
to determine the probabilities are zeroed. When this function is invoked the
arrays LeftNonzeroContext and LeftSegPredContext are set
equal to 0.

**Note:** LeftNonzeroContext[ plane ][ i ] and LeftSegPredContext[ i ] need to be set to 0 for
i = 0..MiRows-1, for plane = 0..2.

**clear_above_context** is a function call that indicates that some arrays used
to determine the probabilities are zeroed. When this function is invoked the
arrays AboveNonzeroContext and AboveSegPredContext are set
equal to 0.

**Note:** AboveNonzeroContext[ plane ][ i ] and AboveSegPredContext[ i ] need to be set to 0 for
i = 0..MiCols-1, for plane = 0..2.

**ReadDeltas** specifies whether the current block is the first one in the current superblock. Delta values
for the quantizer index and loop filter are only read on the first block of a superblock.


#### Clear Block Decoded Flags Semantics

**clear_block_decoded_flags** is a function which resets the array BlockDecoded so that all elements are
set to 0 at the beginning of a superblock. 

**notLastColumn** equal to 1 indicates that the current superblock is not in the rightmost column of the
current tile. notLastColumn equal to 0 indicates that the current superblock is in the rightmost column
of the current tile.

**BlockDecoded** is an array which stores one boolean value per 4x4 sample block per plane in the current
superblock, plus a border of one 4x4 sample block on all sides of the superblock. Except for the borders,
a value of 1 in BlockDecoded indicates that the corresponding 4x4 sample block has been decoded.
The borders are used when computing above-right and below-left availability along the top and left edges of
the superblock.


#### Decode Partition Semantics

**partition** specifies how a block is partitioned:


| partition | Name of partition
|:---------:|:-----------------:
| 0         | PARTITION_NONE
| 1         | PARTITION_HORZ
| 2         | PARTITION_VERT
| 3         | PARTITION_SPLIT
{:.table }


The variable **subSize** is computed from partition and indicates the size of the
component blocks within this block:


| subSize | Name of subSize
|:-------:|:---------------:
| 0       | BLOCK_4X4
| 1       | BLOCK_4X8
| 2       | BLOCK_8X4
| 3       | BLOCK_8X8
| 4       | BLOCK_8X16
| 5       | BLOCK_16X8
| 6       | BLOCK_16X16
| 7       | BLOCK_16X32
| 8       | BLOCK_32X16
| 9       | BLOCK_32X32
| 10      | BLOCK_32X64
| 11      | BLOCK_64X32
| 12      | BLOCK_64X64
{:.table }


The dimensions of these blocks are given in width, height order (e.g.
BLOCK_8X16 corresponds to a block that is 8 pixels wide, and 16 pixels high).

It is a requirement of bitstream conformance that get_plane_block_size( subSize, 1 ) is not equal to BLOCK_INVALID
every time subSize is computed.

**Note:** This requirement prevents the UV blocks from being too tall or too
wide (i.e. having aspect ratios outside the range 1:2 to 2:1).

**split_or_vert** is used to compute partition for blocks when only split or vert partitions are legal because of overlap with the right hand edge of the frame.

**split_or_horz** is used to compute partition for blocks when only split or horz partitions are legal because of overlap with the bottom edge of the frame.

#### Decode Block Semantics

**MiRow** is a variable holding the vertical location of the block in units of 4x4
pixels.

**MiCol** is a variable holding the horizontal location of the block in units of
4x4 pixels.

**MiSize** is a variable holding the size of the block with values having the same
interpretation for the variable subSize.

**HasChroma** is a variable that specifies whether chroma information is coded for this block.

Variable **AvailU** is equal to 0 if the information from the block above cannot
be used; AvailU is equal to 1 if the information from the block above can be
used.

Variable **AvailL** is equal to 0 if the information from the block to the left
can not be used; AvailL is equal to 1 if the information from the block to the
left can be used.

**Note:** Information from a block in a different tile can be used in some circumstances if the
block is above, but not if the block is to the left.


#### Intra Frame Mode Info Semantics

This syntax is used when coding an intra block within an intra frame.

**intra_frame_y_mode** specifies the direction of intra prediction filtering:

| intra_frame_y_mode  | Name of intra_frame_y_mode
|:-------------------:|:--------------------------:
| 0                   | DC_PRED
| 1                   | V_PRED
| 2                   | H_PRED
| 3                   | D45_PRED
| 4                   | D135_PRED
| 5                   | D117_PRED
| 6                   | D153_PRED
| 7                   | D207_PRED
| 8                   | D63_PRED
| 9                   | SMOOTH_PRED
| 10                  | TM_PRED
{:.table }


**uv_mode** specifies the chrominance intra prediction mode using
values with the same interpretation as in the semantics for intra_frame_y_mode.


#### Intra and Inter Segment ID Semantics

**segment_id** specifies which segment is associated with the current intra
block being decoded.

**seg_id_predicted** equal to 1 specifies that the segment_id are taken from
the segmentation map. seg_id_predicted equal to 0 specifies that the syntax
element segment_id are parsed.

**Note:** It is legal for seg_id_predicted to be equal to 0 even if the value
coded for the segment_id is equal to predictedSegmentId.

**Lossless** is a variable which, if equal to 1, indicates that the block
is coded using a special 4x4 transform designed for encoding frames that
are bit-identical with the original frames.


#### Skip Semantics

**skip** equal to 0 indicates that there may be some transform coefficients to
read for this block; skip equal to 1 indicates that there are no transform
coefficients.

**Note:** It is legal for skip to be equal to 0 even if all the transform
blocks contain immediate end of block markers. However, in this case note that
the process specified in [section 6.4.5][] will later modify the value of skip to
be equal to 1.


#### Quantizer Index Delta Semantics

**delta_q_abs** specifies the absolute value of the quantizer index delta value being decoded.
If delta_q_abs is equal to DELTA_Q_SMALL, the value is encoded using delta_q_rem_bits and
delta_q_abs_bits.

**delta_q_rem_bits** and **delta_q_abs_bits** encode the absolute value of the quantizer index delta
value being decoded, where the absolute value of the quantizer index delta value is of the form:

~~~~~ c
(1 << delta_q_rem_bits) + delta_q_abs_bits + 1
~~~~~

**delta_q_sign_bit** equal to 0 indicates that the quantizer index delta value is positive; delta_q_sign_bit
equal to 1 indicates that the quantizer index delta value is negative.


#### Loop Filter Delta Semantics

**delta_lf_abs** specifies the absolute value of the loop filter delta value being decoded.
If delta_lf_abs is equal to DELTA_LF_SMALL, the value is encoded using delta_lf_rem_bits and
delta_lf_abs_bits.

**delta_lf_rem_bits** and **delta_lf_abs_bits** encode the absolute value of the loop filter delta
value being decoded, where the absolute value of the loop filter delta value is of the form:

~~~~~ c
(1 << delta_lf_rem_bits) + delta_lf_abs_bits + 1
~~~~~

**delta_lf_sign_bit** equal to 0 indicates that the loop filter delta value is positive; delta_lf_sign_bit
equal to 1 indicates that the loop filter delta value is negative.

#### CDEF Params Semantics

**cdef_damping_minus_3** controls the amount of damping in the deringing filter.

**cdef_bits** specifies the number of bits needed to specify which CDEF filter to apply.

**cdef_y_pri_strength** and **cdef_uv_pri_strength** specify the strength of the primary filter.

**cdef_y_sec_strength** and **cdef_uv_sec_strength** specify the strength of the secondary filter.

**cdef_y_filter_skip** and **cdef_uv_filter_skip** specify whether to apply the filtering for skipped blocks.
Skipped blocks will only be filtered if this skip bit is equal to 1.

#### TX Size Semantics

**tx_size** specifies the transform size to be used for this block:


| tx_size | Name of tx_size
|:-------:|:---------------:
| 0       | TX_4X4
| 1       | TX_8X8
| 2       | TX_16X16
| 3       | TX_32X32
| 4       | TX_4X8
| 5       | TX_8X4
| 6       | TX_8X16
| 7       | TX_16X8
| 8       | TX_16X32
| 9       | TX_32X16


**Note:** tx_size is decoded for skipped intra blocks because tx_size controls
the granularity of the intra prediction.

**Note:** The tx_size syntax element in the bitstream only explicitly codes square sizes.  Rectangular sizes are signalled by transmitting a square tx_size that is larger than the block size.
tx_size is then overwritten to be the largest rectangular size that fits in the block.

#### Transform Type Semantics

**setType** specifies the transform set type.

| setType | Name of setType
|:-------:|:----------------------:
| 0       | TX_SET_DCTONLY
| 1       | TX_SET_DCT_IDTX
| 2       | TX_SET_DTT4_IDTX
| 3       | TX_SET_DTT4_IDTX_1DDCT
| 4       | TX_SET_DTT9_IDTX_1DDCT
| 5       | TX_SET_ALL16
{:.table }

**inter_tx_type** specifies the transform type for inter blocks.

**intra_tx_type** specifies the transform type for intra blocks.


#### Is Inter Semantics

**is_inter** equal to 0 specifies that the block is an intra block; is_inter
equal to 1 specifies that the block is an inter block.


#### Intra Block Mode Info Semantics

This syntax is used when coding an intra block within an inter frame.

**y_mode** and **uv_mode** specify the direction of intra
prediction using values with the same interpretation as for intra_frame_y_mode.


#### Inter Block Mode Info Semantics

This syntax is used when coding an inter block.

**compound_mode** specifies how the motion vector used by inter prediction is
obtained when using compound prediction. An offset is added to compound_mode to compute YMode as follows:

| YMode | Name of YMode
|:------:|:-------------
| 11     | NEARESTMV
| 12     | NEARMV
| 13     | ZEROMV
| 14     | NEWMV
| 15     | NEAREST_NEARESTMV
| 16     | NEAR_NEARMV 
| 17     | NEAREST_NEWMV 
| 18     | NEW_NEARESTMV 
| 19     | NEAR_NEWMV 
| 20     | NEW_NEARMV 
| 21     | ZERO_ZEROMV 
| 22     | NEW_NEWMV 
{:.table }

**Note:** The intra modes take values 0..10 so these YMode values start at 11.

**new_mv** equal to 0 means that a motion vector difference should be read.

**zero_mv** equal to 0 means that the motion vector should be set equal to default motion for the frame.

**ref_mv** equal to 0 means that the most likely motion vector should be used (called NEAREST),
ref_mv equal to 1 means that the second most likely motion vector should be used (called NEAR).

**interp_filter** specifies the type of filter used in inter prediction.
Values 0..3 are allowed with the same interpretation as for
interpolation_filter. One filter type is specified for the vertical filter
direction and one for the horizontal filter direction.

**Note:** The syntax element interpolation_filter from the uncompressed header
can specify the type of filter to be used for the whole frame. If it is set to
SWITCHABLE then the interp_filter syntax element is read from the bitstream
for every inter block.

**RefMvIdx** specifies which candidate in the RefStackMv should be used.  If there are not enough entries in the stack, a candidate from the RefListMv will be used instead.

**drl_mode** is a bit sent for candidates in the motion vector stack to indicate if they should be used.
drl_mode equal to 0 means to use the current value of idx.  drl_mode equal to 1 says to continue searching.
DRL stands for "Dynamic Reference List".


#### Ref Frames Semantics

**comp_mode** specifies whether single or compound prediction is used. Values
0 and 1 are used with the same interpretation as for ReferenceMode.

**comp_ref_type** is used for compound prediction to specify whether both reference frames come from the same direction or not:

| comp_ref_type | Name of comp_ref_type| Description
|:-------------:|:---------------------: -----------
| 0             | UNIDIR_COMP_REFERENCE| Both reference frames from the same direction
| 1             | BIDIR_COMP_REFERENCE | One forward and one backward reference frame
{:.table }

**uni_comp_ref**, **uni_comp_ref_p1**, and **uni_comp_ref_p2** specify which reference frames are in use when both come from the same direction.

**comp_ref**, **comp_ref_p1**, and **comp_ref_p2** specify the first reference frame when the two reference frames come from different directions.

**comp_bwdref** and **comp_bwdref_p1** specify the second reference frame when the two reference frames come from different directions.

**single_ref_p1**, **single_ref_p2**, **single_ref_p3**, **single_ref_p4**, **single_ref_p5**, and **single_ref_p6** specify the reference frame
when only a single
reference frame is in use.

**RefFrame[ 0 ]** specifies which frame is used to compute the predicted
samples for this block:


| RefFrame[ 0 ] | Name of ref_frame
|:-------------:|:-----------------:
| 0             | INTRA_FRAME
| 1             | LAST_FRAME
| 2             | LAST2_FRAME
| 3             | LAST3_FRAME
| 4             | GOLDEN_FRAME
| 5             | BWDREF_FRAME
| 6             | ALTREF2_FRAME
| 7             | ALTREF_FRAME
{:.table }


**RefFrame[ 1 ]** specifies which additional frame is used in compound
prediction:


| RefFrame[ 1 ] | Name of ref_frame
|:-------------:|:-----------------:
| -1            | NONE (this block uses single prediction)
| 0             | INTRA_FRAME (this block uses interintra prediction)
| 1             | LAST_FRAME
| 2             | LAST2_FRAME
| 3             | LAST3_FRAME
| 4             | GOLDEN_FRAME
| 5             | BWDREF_FRAME
| 6             | ALTREF2_FRAME
| 7             | ALTREF_FRAME
{:.table }

**Note:** Not all combinations of RefFrame[0] and RefFrame[1] can be coded.

#### Read Motion Mode Semantics

**use_obmc** equal to 1 means that OBMC should be used.  use_obmc equal to 0 means that simple translation should be used.

**motion_mode** specifies the type of motion compensation to perform:

| motion_mode   | Name of motion_mode
|:-------------:|:-----------------:
| 0             | SIMPLE
| 1             | OBMC
| 2             | LOCALWARP
| 3             | GLOBALWARP
{:.table }

**Note:** The motion_mode syntax_element cannot directly signal GLOBALWARP.

#### Read Inter Intra Semantics

**interintra** equal to 1 specifies that an inter prediction should be blended with an intra prediction.

**interintra_mode** specifies the type of intra prediction to be used:

| interintra_mode   | Name of interintra_mode
|:-----------------:|:-----------------:
| 0                 | II_DC_PRED
| 1                 | II_V_PRED
| 2                 | II_H_PRED
| 3                 | II_SMOOTH_PRED
{:.table }

**wedge_interintra** equal to 1 specifies that wedge blending should be used.  wedge_interintra equal to 0 specifies that intra blending should be used.

**wedge_index** specifies the angle to be used during wedge blending.

#### Read Compound Type Semantics

**compound_avg** equal to 1 means COMPOUND_AVERAGE blending should be used.  compound_avg equal to 0 means COMPOUND_SEG should be used.

**compound_type** specifies how the two predictions should be blended together:

| compound_type     | Name of compound_type
|:-----------------:|:-----------------:
| 0                 | COMPOUND_AVERAGE
| 1                 | COMPOUND_WEDGE
| 2                 | COMPOUND_SEG
| 3                 | COMPOUND_INTRA
{:.table }

**Note:** COMPOUND_INTRA cannot be directly signalled in the compound_type syntax element.  It is only used in interintra modes.

**wedge_index** specifies the angle to be used during wedge blending:

| wedge_index       | Name of wedge_index
|:-----------------:|:-----------------:
| 0                 | WEDGE_HORIZONTAL
| 1                 | WEDGE_VERTICAL
| 2                 | WEDGE_OBLIQUE27
| 3                 | WEDGE_OBLIQUE63
| 4                 | WEDGE_OBLIQUE117
| 5                 | WEDGE_OBLIQUE153

**wedge_sign** specifies the sign of the wedge blend.

**mask_type** specifies the type of mask to be used during blending:

| mask_type         | Name of mask_type
|:-----------------:|:-----------------:
| 0                 | UNIFORM_45
| 1                 | UNIFORM_45_INV
{:.table }

#### MV Semantics

**MvCtx** is used to determine which CDFs to use for the motion vector syntax elements.

**mv_joint** specifies which components of the motion vector difference are
non-zero:


| mv_joint  | Name of mv_joint  | Changes row | Changes col
|:---------:|:-----------------:|:-----------:|:-----------:
| 0         | MV_JOINT_ZERO     | No          | No
| 1         | MV_JOINT_HNZVZ    | No          | Yes
| 2         | MV_JOINT_HZVNZ    | Yes         | No
| 3         | MV_JOINT_HNZVNZ   | Yes         | Yes
{:.table }


The motion vector difference is added to the PredMv to compute the final
motion vector in Mv. It is a requirement of bitstream conformance that the
resulting motion vector satisfies -(1 \<\< 14) < Mv[ ref ][ comp ] <
(1 \<\< 14) - 1 for comp=0..1.


#### MV Component Semantics

**mv_sign** equal to 0 means that the motion vector difference is positive;
mv_sign equal to 1 means that the motion vector difference is negative.

**mv_class** specifies the class of the motion vector difference. A higher
class means that the motion vector difference represents a larger update:


| mv_class  | Name of mv_class
|:---------:|:----------------:
| 0         | MV_CLASS_0
| 1         | MV_CLASS_1
| 2         | MV_CLASS_2
| 3         | MV_CLASS_3
| 4         | MV_CLASS_4
| 5         | MV_CLASS_5
| 6         | MV_CLASS_6
| 7         | MV_CLASS_7
| 8         | MV_CLASS_8
| 9         | MV_CLASS_9
| 10        | MV_CLASS_10
{:.table }


**mv_class0_bit** specifies the integer part of the motion vector difference.
This is only present in the bitstream for class 0 motion vector differences.

**mv_class0_fr** specifies the first 2 fractional bits of the motion vector
difference. This is only present in the bitstream for class 0 motion vector
differences.

**mv_class0_hp** specifies the third fraction bit of the motion vector
difference. This is only present in the bitstream for class 0 motion vector
differences.

**mv_bit** specifies bit i of the integer part of the motion vector difference.

**mv_fr** specifies the first 2 fractional bits of the motion vector
difference.

**mv_hp** specifies the third fractional bit of the motion vector difference.


#### Residual Semantics

**AboveNonzeroContext** and **LeftNonzeroContext** are arrays that store at a
4 sample granularity which blocks contained coded coefficients.

**predict_intra** is a function call that indicates the conceptual point where
intra prediction happens. When this function is called, the intra prediction
process specified in [section 8.6.1][] is invoked.

**predict_inter** is a function call that indicates the conceptual point where
inter prediction happens. When this function is called, the inter prediction
process specified in [section 8.6.2][] is invoked.

**predict_palette** is a function call that indicates the conceptual point where
palette prediction happens. When this function is called, the palette prediction
process specified in [section 8.6.3][] is invoked.

**predict_chroma_from_luma** is a function call that indicates the conceptual point where
predicting chroma from luma happens. When this function is called, the predict chroma from luma
process specified in [section 8.6.4][] is invoked.

**MaxLumaW** and **MaxLumaH** are needed for chroma from luma prediction and store the extent of luma pixels that can be used for prediction.

**reconstruct** is a function call that indicates the conceptual point where
inverse transform and reconstruction happens. When this function is called,
the reconstruction process specified in [section 8.7.2][] is invoked.

**Note:** The predict_inter, predict_intra, predict_palette, predict_chroma_from_luma, and reconstruct functions do not
affect the syntax decode process.


#### Token Semantics

**moreCoefs** equal to 0 specifies that all the remaining coefficients in
this transform block are equal to 0 and that no more coefficients need to be
parsed for this transform block. moreCoefs equal to 1 indicates that
more coefficients should be read.

**dc_head_token** is used to compute combToken for the DC coefficient in a transform block.

**ac_head_token** is used to compute combToken for the AC coefficients in a transform block.

**last_head_token** is used to compute combToken for the last AC coefficient in a transform block.

**Note:** dc_head_token can specify any combination of token and moreCoefs.
ac_head_token cannot specify the case when both token and moreCoefs are equal to zero.
last_head_token cannot specify a zero token, and always specifies moreCoefs equal to zero.
These restriction ensure that there are no syntax elements corresponding to trailing zero coefficients.

**combToken** specifies the size of the coefficient and whether this is the last non-zero coefficient in the block.  The least significant bit contains moreCoefs, and the remaining bits specify the base value for token.

**tail_token** specifies an increment to be applied to compute the final token value.

**token** specifies the size range of the transform coefficient:


| token | Name of token
|:-----:|:-------------:
| 0     | ZERO_TOKEN
| 1     | ONE_TOKEN
| 2     | TWO_TOKEN
| 3     | THREE_TOKEN
| 4     | FOUR_TOKEN
| 5     | DCT_VAL_CATEGORY1
| 6     | DCT_VAL_CATEGORY2
| 7     | DCT_VAL_CATEGORY3
| 8     | DCT_VAL_CATEGORY4
| 9     | DCT_VAL_CATEGORY5
| 10    | DCT_VAL_CATEGORY6
{:.table }


**sign_bit** equal to 0 indicates that the transform coefficient is given by
coef; sign_bit equal to 1 indicates that the transform coefficient is given by
-coef.


#### Coef Semantics

**high_bit** is only present when the BitDepth is greater than 8 and token is
equal to DCT_VAL_CATEGORY6. high_bit contains some additional most significant
bits of the transform coefficients.

**coef_bit** represents the remaining bits of the transform coefficient.
Different tokens specify different numbers of remaining bits.


#### Intra Angle Info Semantics

**angle_delta_y** specifies the offset to be applied to the intra prediction angle specified 
by the prediction mode in the luma plane, biased by MAX_ANGLE_DELTA so as to encode a positive
value.

**angle_delta_uv** specifies the offset to be applied to the intra prediction angle specified 
by the prediction mode in the chroma plane biased by MAX_ANGLE_DELTA so as to encode a positive
value.

**AngleDeltaY** is computed from angle_delta_y by removing the MAX_ANGLE_DELTA offset to produce
the final luma angle offset value, which may be positive or negative.

**AngleDeltaUV** is computed from angle_delta_uv by removing the MAX_ANGLE_DELTA offset to produce
the final chroma angle offset value, which may be positive or negative.

#### Read CFL Alphas Semantics

**cfl_alpha_signs** contains the sign of the alpha values for U and V packed together into a single syntax element with 8 possible values.  (The combination of two zero signs is unnecessary.)

**signU** contains the sign of the alpha value for the U component:

| signU | Name of signU
|:-----:|:-------------:
| 0     | CFL_SIGN_ZERO
| 1     | CFL_SIGN_NEG
| 2     | CFL_SIGN_POS
{:.table }

**signV** contains the sign of the alpha value for the V component with the same interpretation as for signU.

**cfl_alpha_u** contains the absolute value of alpha minus one for the U component.

**cfl_alpha_v** contains the absolute value of alpha minus one for the V component.

**CflAlphaU** contains the signed value of the alpha component for the U component.

**CflAlphaV** contains the signed value of the alpha component for the V component.

#### Palette Mode Info Semantics

**has_palette_y** is a boolean value specifying whether a palette is encoded for the Y plane.

**has_palette_uv** is a boolean value specifying whether a palette is encoded for the UV plane.

**palette_size_y_minus_2** is used to compute PaletteSizeY.

**PaletteSizeY** is a variable holding the Y plane palette size.

**palette_size_uv_minus_2** is used to compute PaletteSizeUV.

**PaletteSizeUV** is a variable holding the UV plane palette size.

**palette_colors_y** is an array holding the Y plane palette colors.

**palette_colors_u** is an array holding the U plane palette colors.

**palette_colors_v** is an array holding the V plane palette colors.

#### Palette Tokens Semantics

**color_index_map_y** holds the index in palette_colors_y for the block's
Y plane top left pixel.

**color_index_map_uv** holds the index in palette_colors_u and palette_colors_v
for the block's UV plane top left pixel.

**palette_color_idx_y** holds the index in ColorOrder for a pixel in the block's
Y plane.

**palette_color_idx_uv** holds the index in ColorOrder for a pixel in the block's
UV plane.

#### Palette Colors Semantics

**ColorOrder** is an array holding the mapping from an encoded index to the palette.  ColorOrder is
ranked in order of frequency of occurrence of each color in the neighbourhood of the current block,
weighted by closeness to the current block.

**ColorContextHash** is a variable derived from the distribution of colors in the neighbourhood
of the current block, which is used to determine the probability context used to decode palette_color_idx_y
and palette_color_idx_uv.

#### Decode CDF Semantics

**cdef_idx** specifies which CDEF filtering parameters should be used for a particular 64 by 64 pixel block.
