## Bitstream Semantics

This section specifies the meaning of the syntax elements read in the syntax
structures.


### OBU Semantics

The bitstream consists of a sequence of open bitstream units (OBUs).

Each OBU is given to the decoding process in turn as a bitstream along
with a variable sz that gives the total number of bytes in the OBU.

**Note:** Encoders should always set sz equal to the actual size of the OBU.
Decoders should ignore any extra bytes if sz is greater than the actual size of the OBU.
(For example, this may be needed if a future version of AV1 defines some additional
fields at the end of the frame header, that are not strictly required for decoding,
but if interpreted can improve the decoding).
{:.alert .alert-info }

OBUs must begin at a byte boundary.

Methods of framing the OBUs in a container format are outside the
scope of this Specification. However, one simple method of packing OBUs
is described in Annex B.

#### OBU Header Semantics

OBUs are structured with a header and a payload.
The header identifies the type of the payload using the obu_type header parameter.

**obu_forbidden_bit** must be set to 0.

**Note:** This ensures that MPEG2 transport is
possible by preventing emulation of MPEG2 transport stream ids.
{:.alert .alert-info }

**obu_type** specifies the type of data structure contained in the OBU payload:

| obu_type | Name of obu_type
| -------- | ----------------
| 0        | Reserved
| 1        | OBU_SEQUENCE_HEADER
| 2        | OBU_TD
| 3        | OBU_FRAME_HEADER
| 4        | OBU_TILE_GROUP
| 5        | OBU_METADATA
| 6-14     | Reserved
| 15       | OBU_PADDING
{:.table .table-sm .table-bordered }

Reserved units are for future use and shall be ignored by AV1 decoder.

**obu_reserved_2bits** must be set to 0. The value is ignored by a decoder.

**obu_extension_flag** indicates if the optional obu_extension_header is present.

#### OBU Extension Header Semantics

**temporal_id** specifies the temporal level of the coded picture.

**spatial_id** specifies the spatial level of the coded picture.

**Note:** Spatial scalability here is assumed to mean that the reference pictures, if any, are from the same temporal unit and have a different spatial resolution.
{:.alert .alert-info }

**quality_id** specifies the quality level of the coded picture.

**Note:** Quality scalability here is assumed to mean that the reference pictures, if any,
are from the same temporal unit and have the exact same spatial resolution.
{:.alert .alert-info }

**reserved_flag** must be set to 0. The value is ignored by a decoder.

#### Trailing Bits Semantics

**zero_bit** shall be equal to 0 and is inserted into the bitstream to align
the bit position to a multiple of 8 bits.

### Reserved OBU Semantics

The reserved OBU allows the extension of this specification with additional OBU
types in a way that allows older decoders to ignore them.

**reserved_obu_payload_byte** is a payload byte of the reserved OBU.

### Sequence Header OBU Semantics

**profile_low_bit** and **profile_high_bit** combine to make the variable
Profile. AV1 supports 4 profiles:


| Profile | Bit depth | SRGB Colorspace support | Chroma subsampling
| ------- | --------- | ----------------------- | ------------------
| 0       | 8         | No                      | YUV 4:2:0
| 1       | 8         | Yes                     | YUV 4:2:2, YUV 4:4:0 or YUV 4:4:4
| 2       | 10 or 12  | No                      | YUV 4:2:0
| 3       | 10 or 12  | Yes                     | YUV 4:2:2, YUV 4:4:0 or YUV 4:4:4
{:.table .table-sm .table-bordered }


**reserved_zero** shall be equal to 0.

**level** specifies the level for the coded video sequence.

**frame_width_bits_minus_1** specifies the number of bits minus 1 used for transmitting the frame width syntax elements.

**frame_height_bits_minus_1** specifies the number of bits minus 1 used for transmitting the frame height syntax elements.

**max_frame_width_minus_1** specifies the maximum frame width minus 1 for the frames represented by this sequence header.

**max_frame_height_minus_1** specifies the maximum frame height minus 1 for the frames represented by this sequence header.

**frame_id_numbers_present_flag** specifies whether frame id numbers are present in the bitstream.

**Note:** Frame id numbers are not needed by the decoding process,
but allow decoders to spot when frames have been missed and take an appropriate action.
{:.alert .alert-info }

**frame_id_length_minus7** specifies the number of bits minus 7 used to encode the frame_id syntax element.

**delta_frame_id_length_minus2** specifies the number of bits minus 2 used to encode delta_frame_id syntax elements.


#### Color Config Semantics

**ten_or_twelve_bit** equal to 1 indicates the bit depth is 12 bits;
ten_or_twelve_bit equal to 0 indicates that the bit depth is 10 bits.

**color_space** specifies the color space of the stream:


| color_space | Name of color space | Description
|:-----------:|:-------------------:| -----------
| 0           | CS_UNKNOWN          | Unknown (in this case the color space must be signaled outside the AV1 bitstream).
| 1           | CS_BT_601           | Rec. ITU-R BT.601-7
| 2           | CS_BT_709           | Rec. ITU-R BT.709-6
| 3           | CS_SMPTE_170        | SMPTE-170
| 4           | CS_SMPTE_240        | SMPTE-240
| 5           | CS_BT_2020_NCL      | Rec. ITU-R BT.2020-2 (nonconstant luminance)
| 6           | CS_BT_2020_CL       | Rec. ITU-R BT.2020-2 (constant luminance)
| 7           | CS_ICTCP            | Rec. ITU-R BT.2100-0
| 8           | CS_SRGB             | sRGB (IEC 61966-2-1)
| 9..31       | CS_RESERVED         | Reserved
{:.table .table-sm .table-bordered }

It is a requirement of bitstream conformance that color_space is not equal to
CS_SRGB when profile_low_bit is equal to 0.

**transfer_function** specifies specifies opto-electronic characteristics of the
source video:

| transfer_function | Name of transfer function| Description
|:-----------------:|:-------------------------: -----------
| 0                 | TF_UNKNOWN               | Unknown (in this case the source video transfer function must be signaled outside the AV1 bitstream).
| 1                 | TF_BT_709                | Rec. ITU-R BT.709-6, Rec. ITU-R BT.601-7 525 or 625, Rec. ITU-R BT.2020
| 2                 | TF_PQ                    | SMPTE ST 2084:2014 / BT.2100 PQ
| 3                 | TF_HLG                   | BT.2100 Hybrid Log-Gamma (HLG)
| 4..31             | TF_RESERVED              |
{:.table .table-sm .table-bordered }

**color_range** specifies the black level and range of the luma and chroma
signals as specified in Rec. ITU-R BT.709-6 and Rec. ITU-R BT.2020-2:


| color_range | Description   | Details
| ----------- | ------------- | -------
| 0           | Studio swing  | For BitDepth equals 8:<br> Y is between 16 and 235 inclusive.<br> U and V are between 16 and 240 inclusive.
|             |               | For BitDepth equals 10:<br>Y is between 64 and 940 inclusive.<br>U and V are between 64 and 960 inclusive.
|             |               | For BitDepth equals 12:<br>Y is between 256 and 3760.<br>U and V are between 256 and 3840 inclusive.
| 1           | Full swing    | No restriction on Y, U, V values.
{:.table .table-sm .table-bordered }


**Note:** Note that this specification does not enforce the range of YUV values
when the YUV range is signaled as Studio swing. Therefore the application
should perform additional clamping and color conversion operations according to
the specified range.
{:.alert .alert-info }

**subsampling_x**, **subsampling_y** specify the chroma subsampling format:


| subsampling_x | subsampling_y | Description
| ------------- | ------------- | -----------
| 0             | 0             | YUV 4:4:4
| 0             | 1             | YUV 4:4:0
| 1             | 0             | YUV 4:2:2
| 1             | 1             | YUV 4:2:0
{:.table .table-sm .table-bordered }


It is a requirement of bitstream conformance that either subsampling_x is equal
to 0 or subsampling_y is equal to 0 when profile_low_bit is equal to 1.

**Note:** In Chroma subsampling format 4:2:2, AV1 assumes that chroma
samples are co-located with luma samples if there is no explicit signaling
outside of the AV1 bitstream. When there is explicit signaling at the container
level, the signaled information overrides AV1's default assumption.
{:.alert .alert-info }

**reserved_zero** shall be equal to 0.

**chroma_sample_position** specifies the sample position for 4:2:0 streams:

| chroma_sample_position | Name of chroma sample position| Description
|:----------------------:|:------------------------------: -----------
| 0                      | CSP_UNKNOWN                   | Unknown (in this case the source video transfer function must be signaled outside the AV1 bitstream)
| 1                      | CSP_VERTICAL                  | Horizontally co-located with (0, 0) luma sample, vertical position in the middle between two luma samples
| 2                      | CSP_COLOCATED                 | co-located with (0, 0) luma sample
| 3                      | CSP_RESERVED                  |
{:.table .table-sm .table-bordered }

### Temporal Delimiter OBU Semantics

**SeenFrameHeader** is a variable used to mark whether we have received the frame header for the current frame.

### Padding OBU Semantics

The padding OBU offers padding from 1 to 256 bytes.  Multiple padding units can be present, each padding with an arbitrary number of bytes.

**obu_padding_length** indicates the length of the remaining payload in bytes.

**obu_padding_byte** is a padding bytes.  Padding bytes may have arbitrary values and have no effect on the decoding process.

### Metadata OBU Semantics

**metadata_type** indicates the type of metadata:

| metadata_type | Name of metadata_type
| ------------- | ---------------------------
| 0             | METADATA_TYPE_PRIVATE_DATA
| 1             | METADATA_TYPE_HDR_CLL
| 2             | METADATA_TYPE_HDR_MDCV
| 3-65535       | Reserved
{:.table .table-sm .table-bordered }

#### Metadata Private Data Semantics

Private data allows the transfer of arbitrary, application-specific binary information.

**metadata_private_data_payload_byte[ i ]** carries the payload of the private data.
Private data may have arbitrary values and have no effect on the decoding process.

#### Metadata High Dynamic Range Content Light Level Semantics

**max_cll** specifies the maximum content light level as specified in CEA-861.3, Appendix A.

**max_fall** specifies the maximum frame-average light level as specified in CEA-861.3, Appendix A.

#### Metadata High Dynamic Range Mastering Display Color Volume Semantics

**primary_chromaticity_x[ i ]** specifies a 0.16 fixed-point X chromaticity coordinate as defined by CIE 1931, where i = 0,1,2 specifies Red, Green, Blue respectively.

**primary_chromaticity_y[ i ]** specifies a 0.16 fixed-point Y chromaticity coordinate as defined by CIE 1931, where i = 0,1,2 specifies Red, Green, Blue respectively.

**white_point_chromaticity_x[ i ]** specifies a 0.16 fixed-point white X chromaticity coordinate as defined by CIE 1931.

**white_point_chromaticity_y[ i ]** specifies a 0.16 fixed-point white Y chromaticity coordinate as defined by CIE 1931.

**luminance_max** is a 24.8 fixed-point maximum luminance, represented in candelas per square meter.

**luminance_min** is a 18.14 fixed-point minimum luminance, represented in candelas per square meter.


### Frame Header OBU Semantics

It is a requirement of bitstream conformance that a sequence header OBU has been received
before a frame header OBU.

**frame_header_copy** is a function call that indicates that a copy of the previous
frame_header_obu should be inserted at this point.

**Note:** Bitstreams may contain several copies of the frame_header_obu interspersed
with tile_group_obu to allow for greater error resilience.
However, all copies must contain identical contents.
{:.alert .alert-info }

**TileNum** is a variable giving the index (zero-based) of the current tile.

**MaxTileSize** is a variable that tracks the largest size in bytes of each tile.
(This is needed because the CDFs are updated based on the largest tile decoded.)

**decode_frame** is a function call that indicates that the decode frame process
specified in [section 7.2][] should be invoked.

#### Uncompressed Header Semantics

**show_existing_frame** equal to 1, indicates the frame indexed by
frame_to_show_map_idx is to be displayed; show_existing_frame equal to 0
indicates that further processing is required.

**frame_to_show_map_idx** specifies the frame to be displayed. It is only
available if show_existing_frame is 1.

**display_frame_id** provides the frame number for the frame to display.
It is a requirement of bitstream conformance that whenever display_frame_id is read, the value matches
the value of current_frame_id at the time that the frame indexed by
frame_to_show_map_idx was stored.

**frame_type** specifies the type of the frame:

| frame_type | Name of frame_type
| ---------- | ------------------
| 0          | KEY_FRAME
| 1          | INTER_FRAME
| 2          | INTRA_ONLY_FRAME
| 3          | SWITCH_FRAME
{:.table .table-sm .table-bordered }

It is possible for bitstreams to start with a non key frame and still be
decodable. In this case there are a number of additional constraints on the
bitstream that are detailed in [section 7.3][].

**show_frame** equal to 1 specifies that this frame should be immediately output once decoded.
show_frame equal to 0 specifies that this frame should not be immediately output.
(It may be output later if a later uncompressed header uses show_existing_frame equal to 1).

**error_resilient_mode** equal to 1 indicates that error resilient mode is
enabled; error_resilient_mode equal to 0 indicates that error resilient mode
is disabled.

**Note:** Error resilient mode allows the syntax of a frame to be decoded
independently of previous frames.
{:.alert .alert-info }

**current_frame_id** specifies the frame number for the current frame.
Frame numbers are additional information
that do not affect the decoding process, but provide decoders with a way of detecting
missing reference frames so that appropriate action can be taken.

**frame_size_override_flag** equal to 1 specifies that the frame size will be contained in the bitstream.
frame_size_override_flag equal to 0 specifies that the frame size is equal to the size in the sequence header.

**use_128x128_superblock**, when equal to 1, indicates that superblocks are
128x128 pixels. When equal to 0, it indicates that superblocks are 64x64
pixels.

**allow_screen_content_tools** equal to 1 indicates that intra blocks may use
palette encoding; allow_screen_content_tools equal to 0 indicates that palette
encoding is never used.

**seq_choose_integer_mv** equal to 1 indicates that the force_integer_mv syntax element
will be present in the frame headers of inter and intra-only frames.

**seq_force_integer_mv** equal to SELECT_INTEGER_MV indicates that the force_integer_mv syntax element
will be present in the frame headers of inter and intra-only frames.  Otherwise, seq_force_integer_mv
contains the value for force_integer_mv.

**refresh_frame_flags** contains a bitmask that specifies which reference frame
slots will be updated with the current frame after it is decoded.

See [section 7.15][] for details of the frame update process.

**ref_frame_idx** specifies which reference frames are used by inter frames. It
is a requirement of bitstream conformance that the selected reference frames
match the current frame in bit depth, profile, chroma subsampling, and color
space.

**ref_frame_sign_bias** specifies the intended direction of the motion vector
in time for each reference frame. A sign bias equal to 0 indicates that the
reference frame is a backwards reference; a sign bias equal to 1 indicates that
the reference frame is a forwards reference.

**Note:** The sign bias is just an indication that can improve the accuracy of
motion vector prediction and is not constrained to reflect the actual output
order of pictures.
{:.alert .alert-info }

**delta_frame_id_minus1** is used to calculate DeltaFrameId.

**DeltaFrameId** specifies the distance to the frame id for the reference frame.

**RefFrameId** specifies the frame id for the reference frame.
It is a requirement of bitstream conformance that whenever RefFrameId is calculated, the value matches
the value of current_frame_id at the time that the frame indexed by
ref_frame_idx was stored.

**force_integer_mv** equal to 1 specifies that motion vectors will always be integers.
force_integer_mv equal to 0 specifies that motion vectors can contain fractional bits.

**allow_high_precision_mv** equal to 0 specifies that motion vectors are
specified to quarter pel precision; allow_high_precision_mv equal to 1
specifies that motion vectors are specified to eighth pel precision.

**can_use_previous** equal to 1 specifies that information (motion vectors and global motion settings)
from a previous frame can be used when decoding the current frame.
can_use_previous equal to 0 specifies that this information will not be used.

**frame_parallel_decoding_mode** equal to 1 indicates that parallel decoding mode is enabled;
frame_parallel_decoding_mode equal to 0 indicates that parallel decoding mode is disabled.

**Note:** Parallel decoding mode means that the CDFs in the frame context are not updated at the
end of the frame.
This means that the next frame can start to be decoded as soon as the frame headers of the
current frame have been processed.
{:.alert .alert-info }

**frame_offset_update** specifies how many frames later this frame will be shown.

**DecodeOrder** specifies the offset of when this frame will be shown relative to the last key frame.

**DecodeOrders** specifies the decode order for each reference frame.

**CurrentVideoFrame** counts the number of frames that have been shown since the last key frame.
This variable should be initialized to zero in case the sequence starts with an intra only frame.

**Note:** The starting value of CurrentVideoFrame is unimportant because
the decoding process only depends on the relative value between values of DecodeOrder.
{:.alert .alert-info }

**AllLossless** is a variable that is equal to 1 when all segments use lossless
encoding.

**reduced_tx_set** equal to 1 specifies that the frame is restricted to a
reduced subset of the full set of transform types.

**setup_past_independence** is a function call that indicates that this frame
can be decoded without dependence on previous coded frames. When this function
is invoked the following takes place:

  * FeatureData[ i ][ j ] and FeatureEnabled[ i ][ j ] are set equal to 0 for
    i = 0..7 and j = 0..3.

  * PrevSegmentIds[ row ][ col ] is set equal to 0 for row = 0..MiRows-1 and
    col = 0..MiCols-1.

  * loop_filter_delta_enabled is set equal to 1.

  * loop_filter_ref_deltas[ INTRA_FRAME ] is set equal to 1.

  * loop_filter_ref_deltas[ LAST_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ LAST2_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ LAST3_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ BWDREF_FRAME ] is set equal to 0.

  * loop_filter_ref_deltas[ GOLDEN_FRAME ] is set equal to -1.

  * loop_filter_ref_deltas[ ALTREF_FRAME ] is set equal to -1.

  * loop_filter_ref_deltas[ ALTREF2_FRAME ] is set equal to -1.

  * loop_filter_mode_deltas[ i ] is set equal to 0 for i = 0..1.

  * The cumulative distribution function arrays are reset to default values as follows:

    * YModeCdf is set to a copy of Default_Y_Mode_Cdf

    * UVModeCdf is set to a copy of Default_Uv_Mode_Cdf
    
    * AngleDeltaCdf is set to a copy of Default_Angle_Delta_Cdf

    * PartitionW8Cdf is set to a copy of Default_Partition_W8_Cdf

    * PartitionCdf is set to a copy of Default_Partition_Cdf

    * SegmentIdCdf is set to a copy of Default_Segment_Id_Cdf

    * SegmentIdPredictedCdf is set to a copy of Default_Segment_Id_Predicted_Cdf

    * Tx8x8Cdf is set to a copy of Default_Tx_8x8_Cdf

    * Tx16x16Cdf is set to a copy of Default_Tx_16x16_Cdf

    * Tx32x32Cdf is set to a copy of Default_Tx_32x32_Cdf
    
    * Tx64x64Cdf is set to a copy of Default_Tx_64x64_Cdf
    
    * TxfmSplitCdf is set to a copy of Default_Txfm_Split_Cdf

    * InterpFilterCdf is set to a copy of Default_Interp_Filter_Cdf

    * MotionModeCdf is set to a copy of Default_Motion_Mode_Cdf

    * NewMvCdf is set to a copy of Default_New_Mv_Cdf

    * ZeroMvCdf is set to a copy of Default_Zero_Mv_Cdf

    * RefMvCdf is set to a copy of Default_Ref_Mv_Cdf

    * CompoundModeCdf is set to a copy of Default_Compound_Mode_Cdf

    * DrlModeCdf is set to a copy of Default_Drl_Mode_Cdf

    * IsInterCdf is set to a copy of Default_Is_Inter_Cdf

    * CompModeCdf is set to a copy of Default_Comp_Mode_Cdf

    * SkipCdf is set to a copy of Default_Skip_Cdf

    * CompRefCdf is set to a copy of Default_Comp_Ref_Cdf

    * CompBwdRefCdf is set to a copy of Default_Comp_Bwd_Ref_Cdf

    * SingleRefCdf is set to a copy of Default_Single_Ref_Cdf

    * MvJointCdf[ i ] is set to a copy of Default_Mv_Joint_Cdf for i = 0..MV_CONTEXTS-1

    * MvClassCdf[ i ] is set to a copy of Default_Mv_Class_Cdf for i = 0..MV_CONTEXTS-1

    * MvClass0BitCdf[ i ][ comp ] is set to a copy of Default_Mv_Class0_Bit_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

    * MvFrCdf[ i ] is set to a copy of Default_Mv_Fr_Cdf for i = 0..MV_CONTEXTS-1

    * MvClass0FrCdf[ i ] is set to a copy of Default_Mv_Class0_Fr_Cdf for i = 0..MV_CONTEXTS-1

    * MvClass0HpCdf[ i ][ comp ] is set to a copy of Default_Mv_Class0_Hp_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

    * MvSignCdf[ i ][ comp ] is set to a copy of Default_Mv_Sign_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1
    
    * MvBitCdf[ i ][ comp ] is set to a copy of Default_Mv_Bit_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

    * MvHpCdf[ i ][ comp ] is set to a copy of Default_Mv_Hp_Cdf for i = 0..MV_CONTEXTS-1 and comp = 0..1

    * PaletteYModeCdf is set to a copy of Default_Palette_Y_Mode_Cdf

    * PaletteUVModeCdf is set to a copy of Default_Palette_Uv_Mode_Cdf

    * PaletteYSizeCdf is set to a copy of Default_Palette_Y_Size_Cdf

    * PaletteUVSizeCdf is set to a copy of Default_Palette_Uv_Size_Cdf

    * PaletteSize2YColorCdf is set to a copy of
      Default_Palette_Size_2_Y_Color_Cdf

    * PaletteSize2UVColorCdf is set to a copy of
      Default_Palette_Size_2_Uv_Color_Cdf

    * PaletteSize3YColorCdf is set to a copy of
      Default_Palette_Size_3_Y_Color_Cdf

    * PaletteSize3UVColorCdf is set to a copy of
      Default_Palette_Size_3_Uv_Color_Cdf

    * PaletteSize4YColorCdf is set to a copy of
      Default_Palette_Size_4_Y_Color_Cdf

    * PaletteSize4UVColorCdf is set to a copy of
      Default_Palette_Size_4_Uv_Color_Cdf

    * PaletteSize5YColorCdf is set to a copy of
      Default_Palette_Size_5_Y_Color_Cdf

    * PaletteSize5UVColorCdf is set to a copy of
      Default_Palette_Size_5_Uv_Color_Cdf

    * PaletteSize6YColorCdf is set to a copy of
      Default_Palette_Size_6_Y_Color_Cdf

    * PaletteSize6UVColorCdf is set to a copy of
      Default_Palette_Size_6_Uv_Color_Cdf

    * PaletteSize7YColorCdf is set to a copy of
      Default_Palette_Size_7_Y_Color_Cdf

    * PaletteSize7UVColorCdf is set to a copy of
      Default_Palette_Size_7_Uv_Color_Cdf

    * PaletteSize8YColorCdf is set to a copy of
      Default_Palette_Size_8_Y_Color_Cdf

    * PaletteSize8UVColorCdf is set to a copy of
      Default_Palette_Size_8_Uv_Color_Cdf

    * DeltaQCdf is set to a copy of Default_Delta_Q_Cdf

    * DeltaLFCdf is set to a copy of Default_Delta_Lf_Cdf
    
    * DeltaLFMultiCdf[ i ] is set to a copy of Default_Delta_Lf_Cdf for i = 0..FRAME_LF_COUNT-1

    * IntraTxTypeSet1Cdf is set to a copy of Default_Intra_Tx_Type_Set1_Cdf

    * IntraTxTypeSet2Cdf is set to a copy of Default_Intra_Tx_Type_Set2_Cdf

    * InterTxTypeSet1Cdf is set to a copy of Default_Inter_Tx_Type_Set1_Cdf

    * InterTxTypeSet2Cdf is set to a copy of Default_Inter_Tx_Type_Set2_Cdf

    * InterTxTypeSet3Cdf is set to a copy of Default_Inter_Tx_Type_Set3_Cdf

    * UseObmcCdf is set to a copy of Default_Use_Obmc_Cdf

    * InterIntraCdf is set to a copy of Default_Inter_Intra_Cdf

    * CompRefTypeCdf is set to a copy of Default_Comp_Ref_Type_Cdf

    * CflSignCdf is set to a copy of Default_Cfl_Sign_Cdf

    * UniCompRefCdf is set to a copy of Default_Uni_Comp_Ref_Cdf

    * WedgeInterIntraCdf is set to a copy of Default_Wedge_Inter_Intra_Cdf

    * CompoundTypeCdf is set to a copy of Default_Compound_Type_Cdf

    * InterIntraModeCdf is set to a copy of Default_Inter_Intra_Mode_Cdf

    * CflAlphaCdf is set to a copy of Default_Cfl_Alpha_Cdf
    
    * UseWienerCdf is set to a copy of Default_Use_Wiener_Cdf
    
    * UseSgrprojCdf is set to a copy of Default_Use_Sgrproj_Cdf
    
    * RestorationTypeCdf is set to a copy of Default_Restoration_Type_Cdf
    
    * TxbSkipCdf is set to a copy of Default_Txb_Skip_Cdf.
    
    * EobFlagCdf is set to a copy of Default_Eob_Flag_Cdf.
    
    * EobExtraCdf is set to a copy of Default_Eob_Extra_Cdf.
    
    * DcSignCdf is set to a copy of Default_Dc_Sign_Cdf.
    
    * CoeffBaseEobCdf is set to a copy of Default_Coeff_Base_Eob_Cdf.
    
    * CoeffBaseCdf is set to a copy of Default_Coeff_Base_Cdf.
    
    * CoeffBrCdf is set to a copy of Default_Coeff_Br_Cdf.
    
**load_cdfs( ctx )** is a function call that indicates that the CDF tables are
loaded from frame context number ctx in the range 0 to (NUM_REF_FRAMES - 1).
When this function is invoked, a copy of each CDF array mentioned in the
semantics for setup_past_independence is loaded from an area of memory indexed
by ctx. (The memory contents of these frame contexts have been initialized by
previous calls to save_cdfs).  Once the CDF arrays have been loaded, the last entry
in each array is set to 0.

**Note:** The last entry in each CDF array is used to keep track of how many times
the CDF has been used within the current tile.  This allows the CDF to adapt faster
at the start of each tile.
{:.alert .alert-info }

**load_previous( )** is a function call that indicates that information from the
previous frame should be loaded for use in decoding the current frame.
When this function is invoked the following ordered steps apply:

  1. The variable prevFrame is set equal to ref_frame_idx[ 0 ].
  
  2. gm_params is set equal to SavedGmParams[ prevFrame ].
  
  3. If segmentation_enabled is equal to 1, PrevSegmentIds[ row ][ col ] is set equal to SavedSegmentIds[ prevFrame ][ row ][ col ] for row = 0..MiRows-1, for col = 0..MiCols-1
  
  4. If can_use_previous is equal to 1, the motion field estimation process in [section 7.5][] is invoked.

It is a requirement of bitstream conformance that if segmentation_enabled is equal to 1, prevFrame refers to a frame of the same
width and height as the current frame.
In other words, when this function is invoked, all of the following must be true:

  * RefFrameWidth[ prevFrame ] is equal to FrameWidth.
  
  * RefFrameHeight[ prevFrame ] is equal to FrameHeight.
  

#### Frame Size Semantics

**frame_width_minus_1** plus one is the width of the frame in pixels.

**frame_height_minus_1** plus one is the height of the frame in pixels.

It is a requirement of bitstream conformance that frame_width_minus_1 is less than or equal to max_frame_width_minus_1.

It is a requirement of bitstream conformance that frame_height_minus_1 is less than or equal to max_frame_height_minus_1.

#### Render Size Semantics

The render size is provided as a hint to the application about the desired
display size. It has no effect on the decoding process.

**render_and_frame_size_different** equal to 0 means that the render width and
height are inferred from the frame width and height.
render_and_frame_size_different equal to 1 means that the render width and
height are explicitly coded in the bitstream.

**Note:** It is legal for the bitstream to explicitly code the render
dimensions in the bitstream even if they are an exact match for the frame
dimensions.
{:.alert .alert-info }

**render_width_minus_1** plus one is the render width of the frame in pixels.

**render_height_minus_1** plus one is the render height of the frame in pixels.


#### Frame Size with Refs Semantics

For inter frames, the frame size is either set equal to the size of a reference
frame, or can be sent explicitly.

**found_ref** equal to 1 indicates that the frame dimensions can be inferred
from reference frame i where i is the loop counter in the syntax parsing
process for frame_size_with_refs. found_ref equal to 0 indicates that the
frame dimensions are not inferred from reference frame i.

Once the FrameWidth and FrameHeight have been computed for an inter frame, it
is a requirement of bitstream conformance that for all values of i in
the range 0..(REFS_PER_FRAME - 1), all the following conditions are true:

  * 2 * FrameWidth >= RefFrameWidth[ ref_frame_idx[ i ] ]
  * 2 * FrameHeight >= RefFrameHeight[ ref_frame_idx[ i ] ]
  * FrameWidth <= 16 * RefFrameWidth[ ref_frame_idx[ i ] ]
  * FrameHeight <= 16 * RefFrameHeight[ ref_frame_idx[ i ] ]

**Note:** This is a requirement even if all the blocks in an inter frame are
coded using intra prediction.
{:.alert .alert-info }


#### Compute Image Size Semantics

When compute_image_size is invoked, if this is the first time compute_image_size is invoked, or if either
FrameWidth or FrameHeight have changed in value compared to the previous
time this function was invoked, then the segmentation map is cleared to
all zeros by setting SegmentIds[ row ][ col ] equal to 0 for row =
0..MiRows-1 and col = 0..MiCols-1.

**Note:** compute_image_size is not invoked and therefore segmentation map is
not cleared when show_existing_frame is equal to 1 even if the shown frame has
different dimensions.
{:.alert .alert-info }


#### Interpolation Filter Semantics

**is_filter_switchable** equal to 1 indicates that the filter selection is
signaled at the block level; is_filter_switchable equal to 0 indicates that the
filter selection is signaled at the frame level.

**interpolation_filter** specifies the filter selection used for performing
inter prediction:


| interpolation_filter  | Name of interpolation_filter
|:---------------------:|:----------------------------:
| 0                     | EIGHTTAP
| 1                     | EIGHTTAP_SMOOTH
| 2                     | EIGHTTAP_SHARP
| 3                     | BILINEAR
| 4                     | SWITCHABLE
{:.table .table-sm .table-bordered }


#### Loop Filter Semantics

**loop_filter_level** is an array containing loop filter strength values. Different
loop filter strength values from the array are used depending on the image plane being
filtered, and the edge direction (vertical or horizontal) being filtered.

**loop_filter_sharpness** indicates the sharpness level. The loop_filter_level
and loop_filter_sharpness together determine when a block edge is filtered, and
by how much the filtering can change the sample values.

The loop filter process is described in [section 7.10][].

**loop_filter_delta_enabled** equal to 1 means that the filter level depends on
the mode and reference frame used to predict a block. loop_filter_delta_enabled
equal to 0 means that the filter level does not depend on the mode and
reference frame.

**loop_filter_delta_update** equal to 1 means that the bitstream contains
additional syntax elements that specify which mode and reference frame deltas
are to be updated. loop_filter_delta_update equal to 0 means that these syntax
elements are not present.

**update_ref_delta** equal to 1 means that the bitstream contains the syntax
element loop_filter_ref_delta; update_ref_delta equal to 0 means that the
bitstream does not contain this syntax element.

**loop_filter_ref_deltas** contains the adjustment needed for the filter level
based on the chosen reference frame. If this syntax element is not present in
the bitstream, it maintains its previous value.

**update_mode_delta** equal to 1 means that the bitstream contains the syntax
element loop_filter_mode_deltas; update_mode_delta equal to 0 means that the
bitstream does not contain this syntax element.

**loop_filter_mode_deltas** contains the adjustment needed for the filter level
based on the chosen mode. If this syntax element is not present in the
bitstream, it maintains its previous value.

**Note:** The previous values for loop_filter_mode_deltas and
loop_filter_ref_deltas are intially set by the setup_past_independence function
and can be subsequently modified by these syntax elements being coded in a
previous frame.
{:.alert .alert-info }


#### Quantization Params Semantics

The residual is specified via decoded coefficients which are adjusted by one of
four quantization parameters before the inverse transform is applied. The
choice depends on the plane (Y or UV) and coefficient position (DC/AC
coefficient). The Dequantization process is specified in [section 7.8][].

**base_q_idx** indicates the base frame qindex. This is used for Y AC
coefficients and as the base value for the other quantizers.

**deltaQYDc** indicates the Y DC quantizer relative to base_q_idx.

**deltaQUVDc** indicates the UV DC quantizer relative to base_q_idx.

**deltaQUVAc** indicates the UV AC quantizer relative to base_q_idx.

**using_qmatrix** specifies that the quantizer matrix will be used to
compute quantizers.

**min_qmlevel** specifies the smallest level in the quantizer matrix that
may be used.

**max_qmlevel** specifies the largest level in the quantizer matrix that
may be used.


#### Delta Quantizer Semantics

**delta_coded** specifies that the delta_q syntax element is present in the
bitstream.

**delta_q** specifies an offset (relative to base_q_idx) for a particular
quantization parameter.


#### Segmentation Params Semantics

AV1 provides a means of segmenting the image and then applying various
adjustments at the segment level.

Up to 8 segments may be specified for any given frame. For each of these
segments it is possible to specify:

  1. A quantizer (absolute value or delta).
  2. A loop filter strength (absolute value or delta).
  3. A prediction reference frame.
  4. A block skip mode that implies both the use of a (0,0) motion vector and
     that no residual will be coded.

Each of these data values for each segment may be individually updated at the
frame level. Where a value is not updated in a given frame, the value from the
previous frame persists. The exceptions to this are key frames, intra only
frames or other frames where independence from past frame values is required
(for example to enable error resilience). In such cases all values are reset
as described in the semantics for setup_past_independence.

The segment affiliation (the segmentation map) is stored at the resolution of
4x4 blocks. If no explicit update is coded for a block's segment affiliation,
then it persists from frame to frame (until reset by a call to
setup_past_independence).

**segmentation_enabled** equal to 1 indicates that this frame makes use of the
segmentation tool; segmentation_enabled equal to 0 indicates that the frame
does not use segmentation.

**segmentation_update_map** equal to 1 indicates that the segmentation map are
updated during the decoding of this frame. segmentation_update_map equal to 0
means that the segmentation map from the previous frame is used.

**segmentation_temporal_update** equal to 1 indicates that the updates to the
segmentation map are coded relative to the existing segmentation map.
segmentation_temporal_update equal to 0 indicates that the new
segmentation map is coded without reference to the existing segmentation map.

**segmentation_update_data** equal to 1 indicates that new parameters are about
to be specified for each segment. segmentation_update_data equal to 0 indicates
that the segmentation parameters should keep their existing values.

**feature_enabled** equal to 0 indicates that the corresponding feature is
unused and has value equal to 0. feature_enabled equal to 1 indicates that the
feature value is coded in the bitstream.

**feature_value** specifies the magnitude of the feature data for a segment
feature.

**feature_sign** equal to 1 indicates that the feature data is given by
-feature_value. feature_sign equal to 0 indicates that the feature data is
given by feature_value.


#### Tile Info Semantics

**uniform_tile_spacing_flag** equal to 1 means that the tiles are uniformly spaced
across the frame.  (In other words, all tiles are the same size except for the ones at the right and bottom edge which can be smaller.)
uniform_tile_spacing_flag equal to 0 means that the tile sizes are coded.

**increment_tile_cols_log2** indicates whether the tile width is increased.

**TileColsLog2** specifies the base 2 logarithm of the desired number of tiles
across the frame.

**TileCols** specifies the number of tiles across the frame.
It is a requirement of bitstream conformance that TileCols is less than or equal to MAX_TILE_COLS.

**increment_tile_rows_log2** is used to compute
TileRowsLog2.

**TileRowsLog2** specifies the base 2 logarithm of the desired number of tiles
down the frame.

**Note:** For small frame sizes the actual number of tiles in the frame may be
smaller than the desired number because the tile size is rounded up to a
multiple of the maximum superblock size.
{:.alert .alert-info }

**TileRows** specifies the number of tiles down the frame.
It is a requirement of bitstream conformance that TileRows is less than or equal to MAX_TILE_ROWS.

**sizeSb** is used to specify the width/height of each tile in units of 128x128 pixels.
It is a requirement of bitstream conformance that sizeSb is less than or equal to MAX_TILE_WIDTH_SB.

If uniform_tile_spacing_flag is equal to 0, it is a requirement of bitstream conformance that
startSb is equal to MaxSbCols when the loop writing MiColStarts exits.

If uniform_tile_spacing_flag is equal to 0, it is a requirement of bitstream conformance that
startSb is equal to MaxSbRows when the loop writing MiRowStarts exits.

**Note:** The requirements on startSb ensure that the sizes of each tile add up to the full size of the frame when measured in 128x128 units.
{:.alert .alert-info }

**MiColStarts** is an array specifying the start column (in units of 4x4 pixels)
for each tile across the image.

**MiRowStarts** is an array specifying the start row (in units of 4x4 pixels)
for each tile down the image.

**maxTileHeightSb** specifies the maximum height (in units of 128x128 pixels) that can be used for a tile (to avoid making tiles with too much area).

**maxTileHeightMi** contains the maximum height (in units of 4x4 pixels) that can be used for a tile.

**AllowDependentTileRow** is an array that specifies which tile rows are allowed to use
syntax dependencies between tiles.

**Note:** The AllowDependentTileRow array ensures that the syntax decode can be split into
independent units of a certain maximum size even when dependent_tiles is equal to 1.
{:.alert .alert-info }

**dependent_tiles** equal to 0 indicates that there are no syntax dependencies
between tiles, dependent_tiles equal to 1 indicates that there can be
dependencies between tiles.

**Note:** When dependent_tiles is equal to 1, the context determination, motion
vector prediction, and intra prediction are allowed to depend on the tile above,
but only if the tile above is in the same tile group.
{:.alert .alert-info }

**loop_filter_across_tiles** equal to 1 indicates that loop filtering is allowed
across tile edges. loop_filter_across_tiles equal to 0 indicates that loop
filtering is not allowed across tile edges (unless dependent_tiles is equal to
1, in which case loop filtering is allowed across tile edges for horizontal
boundaries, but not across tile group edges).

**tile_size_bytes_minus_1** is used to compute TileSizeBytes.

**TileSizeBytes** specifies the number of bytes needed to code each tile size.


#### Quantizer Index Delta Parameters Semantics

**delta_q_present** specifies whether quantizer index delta values are present
in the bitstream.

**delta_q_res** specifies the left shift which should be applied to decoded
quantizer index delta values.


#### Loop Filter Delta Parameters Semantics

**delta_lf_present** specifies whether loop filter delta values are present in
the bitstream.

**delta_lf_res** specifies the left shift which should be applied to decoded
loop filter delta values.

**delta_lf_multi** equal to 1 specifies that separate loop filter deltas are sent
for horizontal luma edges, vertical luma edges, the U edges, and the V edges.
delta_lf_multi equal to 0 specifies that the same loop filter delta is used for
all edges.

#### Global Motion Params Semantics

**is_global** specifies whether global motion parameters are present for a
particular reference frame.

**is_rot_zoom** specifies whether a particular reference frame uses rotation and
zoom global motion.

**is_translation** specifies whether a particular reference frame uses
translation global motion.


#### Global Param Semantics

**absBits** is used to compute the range of values that can be used for this
parameter. The values allowed are in the range -(1 \<\< absBits) to
(1 \<\< absBits).

**precBits** specifies the number of fractional bits used for representing this
parameter in the bitstream. All global motion parameters are stored in the model
with WARPEDMODEL_PREC_BITS fractional bits, but the parameters are encoded with
less precision in the bitstream.


#### Decode Subexp Semantics

**subexp_more_bits** equal to 0 specifies that the parameter is in the range mk
to mk+a-1.  subexp_more_bits equal to 0 specifies that the parameter is greater
than mk+a-1.

**subexp_bits** specifies the value of the parameter minus mk.


#### Decode Uniform Semantics

**v** and **extra_bit** are used to compute the value of an unsigned number in
the range 0 to n-1.


#### TX Mode Semantics

**tx_mode** specifies how the transform size is determined:


| tx_mode | Name of tx_mode
|:-------:|:---------------:
| 0       | ONLY_4X4
| 1       | ALLOW_8X8
| 2       | ALLOW_16X16
| 3       | ALLOW_32X32
| 4       | ALLOW_64X64
| 5       | TX_MODE_SELECT
{:.table .table-sm .table-bordered }


For tx_mode not equal to 4, the inverse transform will use the largest
transform size possible up to the limit set in tx_mode. For tx_mode equal to 4,
the choice of size is specified explicitly for each block.

**tx_mode_select** equal to 1 indicates that the transform mode is specified
within each mode info header. tx_mode_select equal to 0 indicates that the
transform mode is computed based on the size of the block and the maximum
transform size allowed by the frame header.

**tx_mode_64x64** is an extra bit read if tx_mode is initially read as ALLOW_32X32,
to determine whether to increment tx_mode to ALLOW_64X64. This reduces the number of
bits read on average to determine tx_mode.


#### Frame Reference Mode Semantics

**reference_select** equal to 1 specifies that the mode info for inter blocks
contains the syntax element comp_mode that indicates whether to use single or
compound reference prediction. Reference_select equal to 0 specifies that all
inter blocks will use single or compound reference prediction.

**non_single_reference** equal to 0 specifies that single reference prediction
will be used. non_single_reference equal to 1 specifies that compound reference
prediction will be used.

**ReferenceMode** is a variable that specifies the type of inter prediction to
be used:


| ReferenceMode  | Name of ReferenceMode
|:---------------:|:----------------------:
| 0               | SINGLE_REFERENCE
| 1               | COMPOUND_REFERENCE
| 2               | REFERENCE_MODE_SELECT
{:.table .table-sm .table-bordered }


**SINGLE_REFERENCE** indicates that all the inter blocks use only a single
reference frame to generate motion compensated prediction.

**COMPOUND_REFERENCE** requires all the inter blocks to use compound mode.
Single reference frame prediction is not allowed.

**REFERENCE_MODE_SELECT** allows each individual inter block to select between
single and compound prediction modes.

**allow_interintra_compound** equal to 1 specifies that the mode info for inter
blocks may contain the syntax element interintra. allow_interintra_compound
equal to 0 specifies that the syntax element interintra will not be present in
this frame.

**allow_masked_compound** equal to 1 specifies that the mode info for inter
blocks may contain the syntax element compound_type. allow_masked_compound equal
to 0 specifies that the syntax element compound_type will not be present in this
frame.

### Tile Group OBU Semantics

**NumTiles** specifies the total number of tiles in the frame.

**tg_start** specifies the zero-based index of the first tile in the current
tile group.

It is a requirement of bitstream conformance that the value of tg_start is equal to the value of TileNum at the point that
tile_group_obu is invoked.

**tg_end** specifies the zero-based index of the last tile in the current
tile group.

It is a requirement of bitstream conformance that the value of tg_end is
greater than or equal to tg_start.

It is a requirement of bitstream conformance that the value of tg_end for
the last tile group in each frame is equal to TileNum - 1.

**Note:** These requirements ensure that conceptually all tile groups are present and
received in order for the purposes of specifying the decode process.
{:.alert .alert-info }

**update_cdf** is a function call that indicates that the CDF arrays are set
equal to the final CDFs at the end of the largest tile (measured in bytes). This process is
described in [section 7.4][].

**tile_size** specifies the size in bytes of the next coded tile.

**Note:** This size includes any padding bytes added by the exit process for the
Boolean decoder. The size does not include the bytes used for tile_group_obu,
trailing_bits, and tile_size.
{:.alert .alert-info }

**AboveSameTileGroup** is a variable that specifies if the tile above can be used
for dependencies, which is true if the tile is in the
same tile group (and the current tile row is marked as allowing tile group dependencies).

**decode_frame** is a function call that indicates that the decode frame process
specified in [section 7.2][] should be invoked.

#### Decode Tile Semantics

**clear_left_context** is a function call that indicates that some arrays used
to determine the probabilities are zeroed. When this function is invoked the
arrays LeftLevelContext, LeftDcContext, and LeftSegPredContext are set
equal to 0.

**Note:** LeftLevelContext[ plane ][ i ], LeftDcContext[ plane ][ i ], and
LeftSegPredContext[ i ] need to be set to 0 for i = 0..MiRows-1, for plane = 0..2.
{:.alert .alert-info }

**clear_above_context** is a function call that indicates that some arrays used
to determine the probabilities are zeroed. When this function is invoked the
arrays AboveLevelContext, AboveDcContext, and AboveSegPredContext are set equal to 0.

**Note:** AboveLevelContext[ plane ][ i ], AboveDcContext[ plane ][ i ], and
AboveSegPredContext[ i ] need to be set to 0 for i = 0..MiCols-1, for plane = 0..2.
{:.alert .alert-info }

**ReadDeltas** specifies whether the current block is the first one in the
current superblock. Delta values for the quantizer index and loop filter are
only read on the first block of a superblock.


#### Clear Block Decoded Flags Semantics

**notLastColumn** equal to 1 indicates that the current superblock is not in the
rightmost column of the current tile. notLastColumn equal to 0 indicates that
the current superblock is in the rightmost column of the current tile.

**BlockDecoded** is an array which stores one boolean value per 4x4 sample block
per plane in the current superblock, plus a border of one 4x4 sample block on
all sides of the superblock. Except for the borders, a value of 1 in
BlockDecoded indicates that the corresponding 4x4 sample block has been decoded.
The borders are used when computing above-right and below-left availability
along the top and left edges of the superblock.


#### Decode Partition Semantics

**partition** specifies how a block is partitioned:


| partition | Name of partition
|:---------:|:-----------------:
| 0         | PARTITION_NONE
| 1         | PARTITION_HORZ
| 2         | PARTITION_VERT
| 3         | PARTITION_SPLIT
| 4         | PARTITION_HORZ_A
| 5         | PARTITION_HORZ_B
| 6         | PARTITION_VERT_A
| 7         | PARTITION_VERT_B
| 8         | PARTITION_HORZ_4
| 9         | PARTITION_VERT_4
{:.table .table-sm .table-bordered }


The variable **subSize** is computed from partition and indicates the size of
the component blocks within this block:


| subSize | Name of subSize
|:-------:|:---------------:
| 0       | BLOCK_4X4
| 1       | BLOCK_4X8
| 2       | BLOCK_8X4
| 3       | BLOCK_8X8
| 4       | BLOCK_8X16
| 5       | BLOCK_16X8
| 6       | BLOCK_16X16
| 7       | BLOCK_16X32
| 8       | BLOCK_32X16
| 9       | BLOCK_32X32
| 10      | BLOCK_32X64
| 11      | BLOCK_64X32
| 12      | BLOCK_64X64
| 13      | BLOCK_64X128
| 14      | BLOCK_128X64
| 15      | BLOCK_128X128
| 16      | BLOCK_4X16
| 17      | BLOCK_16X4
| 18      | BLOCK_8X32
| 19      | BLOCK_32X8
| 20      | BLOCK_16X64
| 21      | BLOCK_64X16
| 22      | BLOCK_32X128
| 23      | BLOCK_128X32
{:.table .table-sm .table-bordered }


The symbol BLOCK_LARGEST is defined as equal to BLOCK_128X128.

The dimensions of these blocks are given in width, height order (e.g.
BLOCK_8X16 corresponds to a block that is 8 pixels wide, and 16 pixels high).

It is a requirement of bitstream conformance that
get_plane_residual_size( subSize, 1 ) is not equal to BLOCK_INVALID every time
subSize is computed.

**Note:** This requirement prevents the UV blocks from being too tall or too
wide (i.e. having aspect ratios outside the range 1:2 to 2:1).
{:.alert .alert-info }

**split_or_vert** is used to compute partition for blocks when only split or
vert partitions are legal because of overlap with the right hand edge of the
frame.

**split_or_horz** is used to compute partition for blocks when only split or
horz partitions are legal because of overlap with the bottom edge of the frame.


#### Decode Block Semantics

**MiRow** is a variable holding the vertical location of the block in units of
4x4 pixels.

**MiCol** is a variable holding the horizontal location of the block in units of
4x4 pixels.

**MiSize** is a variable holding the size of the block with values having the
same interpretation for the variable subSize.

**HasChroma** is a variable that specifies whether chroma information is coded
for this block.

Variable **AvailU** is equal to 0 if the information from the block above cannot
be used; AvailU is equal to 1 if the information from the block above can be
used.

Variable **AvailL** is equal to 0 if the information from the block to the left
can not be used; AvailL is equal to 1 if the information from the block to the
left can be used.

**Note:** Information from a block in a different tile can be used in some
circumstances if the block is above, but not if the block is to the left.
{:.alert .alert-info }


#### Intra Frame Mode Info Semantics

This syntax is used when coding an intra block within an intra frame.

**intra_frame_y_mode** specifies the direction of intra prediction filtering:

| intra_frame_y_mode  | Name of intra_frame_y_mode
|:-------------------:|:--------------------------:
| 0                   | DC_PRED
| 1                   | V_PRED
| 2                   | H_PRED
| 3                   | D45_PRED
| 4                   | D135_PRED
| 5                   | D117_PRED
| 6                   | D153_PRED
| 7                   | D207_PRED
| 8                   | D63_PRED
| 9                   | SMOOTH_PRED
| 10                  | SMOOTH_V_PRED
| 11                  | SMOOTH_H_PRED
| 12                  | TM_PRED
| 13                  | UV_CFL_PRED
{:.table .table-sm .table-bordered }


**uv_mode** specifies the chrominance intra prediction mode using
values with the same interpretation as in the semantics for intra_frame_y_mode.


#### Intra and Inter Segment ID Semantics

**segment_id** specifies which segment is associated with the current intra
block being decoded.

**seg_id_predicted** equal to 1 specifies that the segment_id are taken from
the segmentation map. seg_id_predicted equal to 0 specifies that the syntax
element segment_id are parsed.

**Note:** It is legal for seg_id_predicted to be equal to 0 even if the value
coded for the segment_id is equal to predictedSegmentId.
{:.alert .alert-info }

**Lossless** is a variable which, if equal to 1, indicates that the block
is coded using a special 4x4 transform designed for encoding frames that
are bit-identical with the original frames.


#### Skip Semantics

**skip** equal to 0 indicates that there may be some transform coefficients to
read for this block; skip equal to 1 indicates that there are no transform
coefficients.


#### Quantizer Index Delta Semantics

**delta_q_abs** specifies the absolute value of the quantizer index delta value
being decoded. If delta_q_abs is equal to DELTA_Q_SMALL, the value is encoded
using delta_q_rem_bits and delta_q_abs_bits.

**delta_q_rem_bits** and **delta_q_abs_bits** encode the absolute value of the
quantizer index delta value being decoded, where the absolute value of the
quantizer index delta value is of the form:

~~~~~ c
(1 << delta_q_rem_bits) + delta_q_abs_bits + 1
~~~~~

**delta_q_sign_bit** equal to 0 indicates that the quantizer index delta value
is positive; delta_q_sign_bit equal to 1 indicates that the quantizer index
delta value is negative.


#### Loop Filter Delta Semantics

**delta_lf_abs** specifies the absolute value of the loop filter delta value
being decoded. If delta_lf_abs is equal to DELTA_LF_SMALL, the value is encoded
using delta_lf_rem_bits and delta_lf_abs_bits.

**delta_lf_rem_bits** and **delta_lf_abs_bits** encode the absolute value of the
loop filter delta value being decoded, where the absolute value of the loop
filter delta value is of the form:

~~~~~ c
( 1 << ( delta_lf_rem_bits + 1 ) ) + delta_lf_abs_bits + 1
~~~~~

**delta_lf_sign_bit** equal to 0 indicates that the loop filter delta value is
positive; delta_lf_sign_bit equal to 1 indicates that the loop filter delta
value is negative.


#### CDEF Params Semantics

**cdef_damping_minus_3** controls the amount of damping in the deringing filter.

**cdef_bits** specifies the number of bits needed to specify which CDEF filter
to apply.

**cdef_y_pri_strength** and **cdef_uv_pri_strength** specify the strength of the
primary filter.

**cdef_y_sec_strength** and **cdef_uv_sec_strength** specify the strength of the
secondary filter.

#### Loop Restoration Params Semantics

**lr_type** is used to compute FrameRestorationType.

**FrameRestorationType** specifies the type of restoration used for each plane as follows:

| lr_type | FrameRestorationType | Name of FrameRestorationType
|:-------:|:--------------------:|:---------------------------:
| 0       | 0                    | RESTORE_NONE
| 1       | 3                    | RESTORE_SWITCHABLE
| 2       | 1                    | RESTORE_WIENER
| 3       | 2                    | RESTORE_SGRPROJ
{:.table .table-sm .table-bordered }

**lr_unit_shift** specifies if the luma restoration size should be halved.

**lr_unit_extra_shift** specifies if the luma restoration size should be halved again.

**lr_uv_shift** is only present for 4:2:0 formats and specifies if the chroma size should be half the luma size.

**LoopRestorationSize[plane]** specifies for size of loop restoration units in units of samples in the current plane.


#### TX Size Semantics

**tx_size** specifies the transform size to be used for this block:


| tx_size | Name of tx_size
|:-------:|:---------------:
| 0       | TX_4X4
| 1       | TX_8X8
| 2       | TX_16X16
| 3       | TX_32X32
| 4       | TX_64X64
| 5       | TX_4X8
| 6       | TX_8X4
| 7       | TX_8X16
| 8       | TX_16X8
| 9       | TX_16X32
| 10      | TX_32X16
| 11      | TX_32X64
| 12      | TX_64X32
{:.table .table-sm .table-bordered }


**Note:** tx_size is decoded for skipped intra blocks because tx_size controls
the granularity of the intra prediction.
{:.alert .alert-info }

**Note:** The tx_size syntax element in the bitstream only explicitly codes
square sizes.  Rectangular sizes are signalled by transmitting a square tx_size
that is larger than the block size. tx_size is then overwritten to be the
largest rectangular size that fits in the block.
{:.alert .alert-info }

#### Inter TX Size Semantics

**MinTxSize** is a variable that contains a square transform size that would fit inside all the transforms within the block.
In other words, if the block contains transforms of size W[i] by H[i], then MinTxSize represents a transform of size m by m, where m is equal to the smallest value in both W and H.

**InterTxSizes** is an array that holds the transform sizes within inter frames.

**Note:** TxSizes and InterTxSizes contain different values.
All the values in TxSizes across a residual block will share the same value, while InterTxSizes can represent several different transform sizes within a residual block.
{:.alert .alert-info }

#### Var TX Size Semantics

**txfm_split** equal to 1 specifies that the block should be split into smaller transform sizes.
txfm_split equal to 0 specifies that the block should not be split any more.

#### Transform Type Semantics

**set** specifies the transform set.

| is_inter   | set | Name of transform set
|:----------:|:---:|:---------------------:|
| Don't care | 0   | TX_SET_DCTONLY        |
|          0 | 1   | TX_SET_INTRA_1        |
|          0 | 2   | TX_SET_INTRA_2        |
|          1 | 1   | TX_SET_INTER_1        |
|          1 | 2   | TX_SET_INTER_2        |
|          1 | 3   | TX_SET_INTER_3        |
{:.table .table-sm .table-bordered }

The transform sets determine what subset of transform types can be used, according to the following table.

| Transform type    | TX_SET_DCTONLY | TX_SET_INTRA_1 | TX_SET_INTRA_2 | TX_SET_INTER_1 | TX_SET_INTER_2 | TX_SET_INTER_3 |
|:-----------------:|:--------------:|:--------------:|:--------------:|:--------------:|:--------------:|:--------------:|
| DCT_DCT           | X              | X              | X              | X              | X              | X              |
| ADST_DCT          |                | X              | X              | X              | X              |                |
| DCT_ADST          |                | X              | X              | X              | X              |                |
| ADST_ADST         |                | X              | X              | X              | X              |                |
| FLIPADST_DCT      |                |                |                | X              | X              |                |
| DCT_FLIPADST      |                |                |                | X              | X              |                |
| FLIPADST_FLIPADST |                |                |                | X              | X              |                |
| ADST_FLIPADST     |                |                |                | X              | X              |                |
| FLIPADST_ADST     |                |                |                | X              | X              |                |
| IDTX              |                | X              | X              | X              | X              | X              |
| V_DCT             |                | X              |                | X              | X              |                |
| H_DCT             |                | X              |                | X              | X              |                |
| V_ADST            |                |                |                | X              |                |                |
| H_ADST            |                |                |                | X              |                |                |
| V_FLIPADST        |                |                |                | X              |                |                |
| H_FLIPADST        |                |                |                | X              |                |                |
{:.table .table-sm .table-bordered }


**inter_tx_type** specifies the transform type for inter blocks.

**intra_tx_type** specifies the transform type for intra blocks.


#### Is Inter Semantics

**is_inter** equal to 0 specifies that the block is an intra block; is_inter
equal to 1 specifies that the block is an inter block.


#### Intra Block Mode Info Semantics

This syntax is used when coding an intra block within an inter frame.

**y_mode** and **uv_mode** specify the direction of intra
prediction using values with the same interpretation as for intra_frame_y_mode.


#### Inter Block Mode Info Semantics

This syntax is used when coding an inter block.

**compound_mode** specifies how the motion vector used by inter prediction is
obtained when using compound prediction. An offset is added to compound_mode to
compute YMode as follows:

| YMode | Name of YMode
|:------:|:-------------
| 14     | NEARESTMV
| 15     | NEARMV
| 16     | GLOBALMV
| 17     | NEWMV
| 18     | NEAREST_NEARESTMV
| 19     | NEAR_NEARMV
| 20     | NEAREST_NEWMV
| 21     | NEW_NEARESTMV
| 22     | NEAR_NEWMV
| 23     | NEW_NEARMV
| 24     | GLOBAL_GLOBALMV
| 25     | NEW_NEWMV
{:.table .table-sm .table-bordered }

**Note:** The intra modes take values 0..13 so these YMode values start at 14.
{:.alert .alert-info }

**new_mv** equal to 0 means that a motion vector difference should be read.

**zero_mv** equal to 0 means that the motion vector should be set equal to
default motion for the frame.

**ref_mv** equal to 0 means that the most likely motion vector should be used
(called NEAREST), ref_mv equal to 1 means that the second most likely motion
vector should be used (called NEAR).

**interp_filter** specifies the type of filter used in inter prediction.
Values 0..3 are allowed with the same interpretation as for
interpolation_filter. One filter type is specified for the vertical filter
direction and one for the horizontal filter direction.

**Note:** The syntax element interpolation_filter from the uncompressed header
can specify the type of filter to be used for the whole frame. If it is set to
SWITCHABLE then the interp_filter syntax element is read from the bitstream
for every inter block.
{:.alert .alert-info }

**RefMvIdx** specifies which candidate in the RefStackMv should be used. If
there are not enough entries in the stack, a candidate from the RefListMv will
be used instead.

**drl_mode** is a bit sent for candidates in the motion vector stack to indicate
if they should be used. drl_mode equal to 0 means to use the current value of
idx.  drl_mode equal to 1 says to continue searching. DRL stands for "Dynamic
Reference List".


#### Ref Frames Semantics

**comp_mode** specifies whether single or compound prediction is used. Values
0 and 1 are used with the same interpretation as for ReferenceMode.

**comp_ref_type** is used for compound prediction to specify whether both
reference frames come from the same direction or not:

| comp_ref_type | Name of comp_ref_type| Description
|:-------------:|:---------------------: -----------
| 0             | UNIDIR_COMP_REFERENCE| Both reference frames from the same direction
| 1             | BIDIR_COMP_REFERENCE | One forward and one backward reference frame
{:.table .table-sm .table-bordered }

**uni_comp_ref**, **uni_comp_ref_p1**, and **uni_comp_ref_p2** specify which
reference frames are in use when both come from the same direction.

**comp_ref**, **comp_ref_p1**, and **comp_ref_p2** specify the first reference
frame when the two reference frames come from different directions.

**comp_bwdref** and **comp_bwdref_p1** specify the second reference frame when
the two reference frames come from different directions.

**single_ref_p1**, **single_ref_p2**, **single_ref_p3**, **single_ref_p4**,
**single_ref_p5**, and **single_ref_p6** specify the reference frame when only a
single reference frame is in use.

**RefFrame[ 0 ]** specifies which frame is used to compute the predicted
samples for this block:


| RefFrame[ 0 ] | Name of ref_frame
|:-------------:|:-----------------:
| 0             | INTRA_FRAME
| 1             | LAST_FRAME
| 2             | LAST2_FRAME
| 3             | LAST3_FRAME
| 4             | GOLDEN_FRAME
| 5             | BWDREF_FRAME
| 6             | ALTREF2_FRAME
| 7             | ALTREF_FRAME
{:.table .table-sm .table-bordered }


**RefFrame[ 1 ]** specifies which additional frame is used in compound
prediction:


| RefFrame[ 1 ] | Name of ref_frame
|:-------------:|:-----------------:
| -1            | NONE (this block uses single prediction)
| 0             | INTRA_FRAME (this block uses interintra prediction)
| 1             | LAST_FRAME
| 2             | LAST2_FRAME
| 3             | LAST3_FRAME
| 4             | GOLDEN_FRAME
| 5             | BWDREF_FRAME
| 6             | ALTREF2_FRAME
| 7             | ALTREF_FRAME
{:.table .table-sm .table-bordered }

**Note:** Not all combinations of RefFrame[0] and RefFrame[1] can be coded.
{:.alert .alert-info }


#### Read Motion Mode Semantics

**use_obmc** equal to 1 means that OBMC should be used.  use_obmc equal to 0
means that simple translation should be used.

**motion_mode** specifies the type of motion compensation to perform:

| motion_mode   | Name of motion_mode
|:-------------:|:-----------------:
| 0             | SIMPLE
| 1             | OBMC
| 2             | LOCALWARP
{:.table }

**Note:** A motion_mode equal to SIMPLE is used for blocks requiring global motion.
{:.alert .alert-info }

#### Read Inter Intra Semantics

**interintra** equal to 1 specifies that an inter prediction should be blended
with an intra prediction.

**interintra_mode** specifies the type of intra prediction to be used:

| interintra_mode   | Name of interintra_mode
|:-----------------:|:-----------------:
| 0                 | II_DC_PRED
| 1                 | II_V_PRED
| 2                 | II_H_PRED
| 3                 | II_SMOOTH_PRED
{:.table .table-sm .table-bordered }

**wedge_interintra** equal to 1 specifies that wedge blending should be used.
wedge_interintra equal to 0 specifies that intra blending should be used.

**wedge_index** specifies the angle to be used during wedge blending.


#### Read Compound Type Semantics

**compound_avg** equal to 1 means COMPOUND_AVERAGE blending should be used.
compound_avg equal to 0 means COMPOUND_SEG should be used.

**compound_type** specifies how the two predictions should be blended together:

| compound_type     | Name of compound_type
|:-----------------:|:-----------------:
| 0                 | COMPOUND_AVERAGE
| 1                 | COMPOUND_WEDGE
| 2                 | COMPOUND_SEG
| 3                 | COMPOUND_INTRA
{:.table .table-sm .table-bordered }

**Note:** COMPOUND_INTRA cannot be directly signalled in the compound_type
syntax element.  It is only used in interintra modes.
{:.alert .alert-info }

**wedge_index** specifies the angle to be used during wedge blending:

| wedge_index       | Name of wedge_index
|:-----------------:|:-----------------:
| 0                 | WEDGE_HORIZONTAL
| 1                 | WEDGE_VERTICAL
| 2                 | WEDGE_OBLIQUE27
| 3                 | WEDGE_OBLIQUE63
| 4                 | WEDGE_OBLIQUE117
| 5                 | WEDGE_OBLIQUE153
{:.table .table-sm .table-bordered }

**wedge_sign** specifies the sign of the wedge blend.

**mask_type** specifies the type of mask to be used during blending:

| mask_type         | Name of mask_type
|:-----------------:|:-----------------:
| 0                 | UNIFORM_45
| 1                 | UNIFORM_45_INV
{:.table .table-sm .table-bordered }


#### MV Semantics

**MvCtx** is used to determine which CDFs to use for the motion vector syntax
elements.

**mv_joint** specifies which components of the motion vector difference are
non-zero:


| mv_joint  | Name of mv_joint  | Changes row | Changes col
|:---------:|:-----------------:|:-----------:|:-----------:
| 0         | MV_JOINT_ZERO     | No          | No
| 1         | MV_JOINT_HNZVZ    | No          | Yes
| 2         | MV_JOINT_HZVNZ    | Yes         | No
| 3         | MV_JOINT_HNZVNZ   | Yes         | Yes
{:.table .table-sm .table-bordered }


The motion vector difference is added to the PredMv to compute the final
motion vector in Mv. It is a requirement of bitstream conformance that the
resulting motion vector satisfies -(1 \<\< 14) < Mv[ ref ][ comp ] <
(1 \<\< 14) - 1 for comp=0..1.


#### MV Component Semantics

**mv_sign** equal to 0 means that the motion vector difference is positive;
mv_sign equal to 1 means that the motion vector difference is negative.

**mv_class** specifies the class of the motion vector difference. A higher
class means that the motion vector difference represents a larger update:


| mv_class  | Name of mv_class
|:---------:|:----------------:
| 0         | MV_CLASS_0
| 1         | MV_CLASS_1
| 2         | MV_CLASS_2
| 3         | MV_CLASS_3
| 4         | MV_CLASS_4
| 5         | MV_CLASS_5
| 6         | MV_CLASS_6
| 7         | MV_CLASS_7
| 8         | MV_CLASS_8
| 9         | MV_CLASS_9
| 10        | MV_CLASS_10
{:.table .table-sm .table-bordered }


**mv_class0_bit** specifies the integer part of the motion vector difference.
This is only present in the bitstream for class 0 motion vector differences.

**mv_class0_fr** specifies the first 2 fractional bits of the motion vector
difference. This is only present in the bitstream for class 0 motion vector
differences.

**mv_class0_hp** specifies the third fraction bit of the motion vector
difference. This is only present in the bitstream for class 0 motion vector
differences.

**mv_bit** specifies bit i of the integer part of the motion vector difference.

**mv_fr** specifies the first 2 fractional bits of the motion vector
difference.

**mv_hp** specifies the third fractional bit of the motion vector difference.


#### Residual Semantics

**predict_intra** is a function call that indicates the conceptual point where
intra prediction happens. When this function is called, the intra prediction
process specified in [section 7.7.1][] is invoked.

**predict_inter** is a function call that indicates the conceptual point where
inter prediction happens. When this function is called, the inter prediction
process specified in [section 7.7.2][] is invoked.

**predW** and **predH** are variables containing the smallest size that can be used for
inter prediction.
(This size may be increased for chroma blocks if not all blocks use inter prediction.)

**someUseIntra** is a variable that indicates if some of the blocks corresponding to
this residual require intra prediction.

**Note:** The chroma residual block
size is always at least 4 in width and height.  This means that no transform width
or height
smaller than 4 is required.  As such, a chroma residual may actually cover
several luma blocks.
Normally, a single prediction is performed
for the entire chroma residual block based on the mode info of the bottom right luma block.
However, if all the constituent blocks are
inter blocks, a special case is triggered and inter prediction is done using
a smaller block size for each of the corresponding luma blocks.
{:.alert .alert-info }

**predict_palette** is a function call that indicates the conceptual point where
palette prediction happens. When this function is called, the palette prediction
process specified in [section 7.7.3][] is invoked.

**Note:** The predict_inter, predict_intra, predict_palette, and
predict_chroma_from_luma functions do not affect the syntax
decode process.
{:.alert .alert-info }

#### Coefficients Semantics

**TxTypes** is an array which stores at a 4x4 pixel granularity the transform type to be used.

**Note:** The transform type is only read for luma transform blocks, the chroma uses
the transform type for the corresponding luma block.
{:.alert .alert-info }

**Quant** is an array storing the quantised coefficients for the current transform block.

**all_zero** equal to 1 specifies that all coefficients are zero.

**is_eob** equal to 1 indicates that the last non-zero coefficient lies within a certain range.

**eob_extra** and **eob_extra_bit** specify the exact position of the last non-zero coefficient
within the range selected by is_eob.

**Note:** The value of eob indicates the index of the end of block.
This will be immediately following the last non-zero coefficient.
{:.alert .alert-info }

**coeff_base_eob** is used to compute the base level of the last non-zero coefficient.

**coeff_base** specifies the base level of a coefficient.

**dc_sign** specifies the sign of the DC coefficient.

**sign_bit** specifies the sign of a non-zero coefficient.

**coeff_br** specifies an increment to the coefficient.

**Note:** Each quantized coefficient can use coeff_br to provide up to 4 increments.
If an increment equal to less than 3 is coded, it signifies that this was the final increment.
{:.alert .alert-info }

**golomb_length_bit** is used to compute the number of extra bits required to code the coefficient.

**golomb_data_bit** specifies the value of one of the extra bits.

**AboveLevelContext** and **LeftLevelContext** are arrays that store at a
4 sample granularity the cumulative sum of coefficient levels.

**AboveDcContext** and **LeftDcContext** are arrays that store at a 4 sample
granularity 2 bits signalling the sign of the DC coefficient (zero being
counted as a separate sign).


#### Transform Tree Semantics

**isLumaSquare** is a variable that indicates if the luma samples used a square transform for this location.

**becomingRect** is a variable that indicates we are forced to subdivide the transform tree.

**Note:** When the luma uses a square transform, the chroma samples must also use a square transform.
For example, if we have subsampling_y=1, and subsampling_x=0, a 32x32 block in luma will become a 32x16 block in chroma.
If a 32x32 transform is used for luma, chroma is forbidden from using a 32x16 transform and will use a pair of 16x16 transforms instead.
{:.alert .alert-info }

#### Token Semantics

**moreCoefs** equal to 0 specifies that all the remaining coefficients in
this transform block are equal to 0 and that no more coefficients need to be
parsed for this transform block. moreCoefs equal to 1 indicates that
more coefficients should be read.

**dc_head_token** is used to compute combToken for the DC coefficient in a
transform block.

**ac_head_token** is used to compute combToken for the AC coefficients in a
transform block.

**last_head_token** is used to compute combToken for the last AC coefficient in
a transform block.

**Note:** dc_head_token can specify any combination of token and moreCoefs.
ac_head_token cannot specify the case when both token and moreCoefs are equal
to zero. last_head_token cannot specify a zero token, and always specifies
moreCoefs equal to zero. These restrictions ensure that there are no syntax
elements corresponding to trailing zero coefficients.
{:.alert .alert-info }

**combToken** specifies the size of the coefficient and whether this is the last
non-zero coefficient in the block.  The least significant bit contains
moreCoefs, and the remaining bits specify the base value for token.

**tail_token** specifies an increment to be applied to compute the final token
value.

**token** specifies the size range of the transform coefficient:


| token | Name of token
|:-----:|:-------------:
| 0     | ZERO_TOKEN
| 1     | ONE_TOKEN
| 2     | TWO_TOKEN
| 3     | THREE_TOKEN
| 4     | FOUR_TOKEN
| 5     | DCT_VAL_CATEGORY1
| 6     | DCT_VAL_CATEGORY2
| 7     | DCT_VAL_CATEGORY3
| 8     | DCT_VAL_CATEGORY4
| 9     | DCT_VAL_CATEGORY5
| 10    | DCT_VAL_CATEGORY6
{:.table .table-sm .table-bordered }


**sign_bit** equal to 0 indicates that the transform coefficient is given by
coef; sign_bit equal to 1 indicates that the transform coefficient is given by
-coef.


#### Coef Semantics

**coef_extra_bits** represents a section of the transform coefficient bitstring.


#### Intra Angle Info Semantics

**angle_delta_y** specifies the offset to be applied to the intra prediction
angle specified by the prediction mode in the luma plane, biased by
MAX_ANGLE_DELTA so as to encode a positive value.

**angle_delta_uv** specifies the offset to be applied to the intra prediction
angle specified by the prediction mode in the chroma plane biased by
MAX_ANGLE_DELTA so as to encode a positive value.

**AngleDeltaY** is computed from angle_delta_y by removing the MAX_ANGLE_DELTA
offset to produce the final luma angle offset value, which may be positive or
negative.

**AngleDeltaUV** is computed from angle_delta_uv by removing the MAX_ANGLE_DELTA
offset to produce the final chroma angle offset value, which may be positive or
negative.


#### Read CFL Alphas Semantics

**cfl_alpha_signs** contains the sign of the alpha values for U and V packed
together into a single syntax element with 8 possible values.  (The combination
of two zero signs is unnecessary.)

**signU** contains the sign of the alpha value for the U component:

| signU | Name of signU
|:-----:|:-------------:
| 0     | CFL_SIGN_ZERO
| 1     | CFL_SIGN_NEG
| 2     | CFL_SIGN_POS
{:.table .table-sm .table-bordered }

**signV** contains the sign of the alpha value for the V component with the same
interpretation as for signU.

**cfl_alpha_u** contains the absolute value of alpha minus one for the U
component.

**cfl_alpha_v** contains the absolute value of alpha minus one for the V
component.

**CflAlphaU** contains the signed value of the alpha component for the U
component.

**CflAlphaV** contains the signed value of the alpha component for the V
component.


#### Palette Mode Info Semantics

**has_palette_y** is a boolean value specifying whether a palette is encoded for
the Y plane.

**has_palette_uv** is a boolean value specifying whether a palette is encoded
for the UV plane.

**palette_size_y_minus_2** is used to compute PaletteSizeY.

**PaletteSizeY** is a variable holding the Y plane palette size.

**palette_size_uv_minus_2** is used to compute PaletteSizeUV.

**PaletteSizeUV** is a variable holding the UV plane palette size.

**use_palette_color_cache_y**, if equal to 1, indicates that for a particular palette
entry in the luma palette, the cached entry should be used.

**use_palette_color_cache_u**, if equal to 1, indicates that for a particular palette
entry in the U chroma palette, the cached entry should be used.

**palette_colors_y** is an array holding the Y plane palette colors.

**palette_colors_u** is an array holding the U plane palette colors.

**palette_colors_v** is an array holding the V plane palette colors.

**delta_encode_palette_colors_v**, if equal to 1, indicates that the V chroma palette
is encoded using delta encoding.

**palette_num_extra_bits_y** is used to calculate the number of bits used to store each
palette delta value for the luma palette.

**palette_num_extra_bits_u** is used to calculate the number of bits used to store each
palette delta value for the U chroma palette.

**palette_num_extra_bits_v** is used to calculate the number of bits used to store each
palette delta value for the V chroma palette.

**palette_delta_y** is a delta value for the luma palette.

**palette_delta_u** is a delta value for the U chroma palette.

**palette_delta_v** is a delta value for the V chroma palette.

**Note:** Luma and U delta values give a positive offset relative
to the previous palette entry in the same plane. V delta values give
a signed offset relative to the U palette entries.
{:.alert .alert-info }

**palette_delta_sign_bit_v**, if equal to 1, indicates that the decoded V chroma palette
delta value should be negated.


#### Palette Tokens Semantics

**color_index_map_y** holds the index in palette_colors_y for the block's
Y plane top left pixel.

**color_index_map_uv** holds the index in palette_colors_u and palette_colors_v
for the block's UV plane top left pixel.

**palette_color_idx_y** holds the index in ColorOrder for a pixel in the block's
Y plane.

**palette_color_idx_uv** holds the index in ColorOrder for a pixel in the
block's UV plane.


#### Palette Color Context Semantics

**ColorOrder** is an array holding the mapping from an encoded index to the
palette. ColorOrder is ranked in order of frequency of occurrence of each color
in the neighbourhood of the current block, weighted by closeness to the current
block.

**ColorContextHash** is a variable derived from the distribution of colors in
the neighbourhood of the current block, which is used to determine the
probability context used to decode palette_color_idx_y and palette_color_idx_uv.


#### Read CDEF Semantics

**cdef_idx** specifies which CDEF filtering parameters should be used for a
particular 64 by 64 pixel block.  A value of -1 means that CDEF is disabled for
that block.

#### Decode Loop Restoration Unit Semantics

**use_wiener** specifies if the Wiener filter should be used.

**use_sgrproj** specifies if the self guided filter should be used.

**restoration_type** specifies the restoration filter that should be used with the same interpretation as FrameRestorationType.

**lr_sgr_set** specifies which set of parameters to use for the self guided filter.

**subexp_more_bools** equal to 0 specifies that the parameter is in the range mk
to mk+a-1.  subexp_more_bools equal to 0 specifies that the parameter is greater
than mk+a-1.

**subexp_unif_bools** specifies the value of the parameter minus mk.

**subexp_bools** specifies the value of the parameter minus mk.
