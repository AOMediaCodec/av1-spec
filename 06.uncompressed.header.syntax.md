### Uncompressed Header Syntax

<div class="syntax">
uncompressed_header( ) {
    @@frame_marker                                                      f(2)
    @@profile_low_bit                                                   f(1)
    @@profile_high_bit                                                  f(1)
    Profile = (profile_high_bit << 1) + profile_low_bit
    if ( Profile == 3 )
        @@reserved_zero                                                 f(1)
    @@show_existing_frame                                               f(1)
    if ( show_existing_frame == 1 ) {
        @@frame_to_show_map_idx                                         f(3)
        header_size_in_bytes = 0
        refresh_frame_flags = 0
        loop_filter_level = 0
        return
    }
    LastFrameType = frame_type
    @@frame_type                                                        f(1)
    @@show_frame                                                        f(1)
    if ( frame_type == KEY_FRAME || show_frame ) {
        intra_only = 0
    } else {
        @@intra_only                                                    f(1)
    }
    @@error_resilient_mode                                              f(1)
    if ( frame_type == KEY_FRAME ) {
        color_config( )
        frame_size( )
        render_size( )
        @@allow_screen_content_tools                                    f(1)
        refresh_frame_flags = 0xFF
        FrameIsIntra = 1
    } else {
        if ( intra_only ) {
            @@allow_screen_content_tools                                f(1)
        }
        FrameIsIntra = intra_only
        if ( error_resilient_mode ) {
            reset_frame_context = 0
        } else {
            if ( intra_only ) {
                @@intra_reset_all                                       f(1)
                reset_frame_context = 1 + intra_reset_all
            } else {
                @@reset_frame_context                                   f(1)
                if ( reset_frame_context == 1 ) {
                    @@intra_reset_all                                   f(1)
                    reset_frame_context = 1 + intra_reset_all
                }
            }
        }
        if ( intra_only == 1 ) {
            color_config( )
            @@refresh_frame_flags                                       f(8)
            frame_size( )
            render_size( )
        } else {
            @@refresh_frame_flags                                       f(8)
            for( i = 0; i < REFS_PER_FRAME; i++ ) {
                @@ref_frame_idx[ i ]                                    f(3)
                @@ref_frame_sign_bias[ LAST_FRAME + i ]                 f(1)
            }
            if ( error_resilient_mode ) {
                frame_size( )
                render_size( )
            } else {
                frame_size_with_refs( )
            }
            @@allow_high_precision_mv                                   f(1)
            read_interpolation_filter( )
        }
    }
    if ( error_resilient_mode ) {
        frame_parallel_decoding_mode = 1
    } else {
        @@frame_parallel_decoding_mode                                  f(1)
    }
    @@frame_context_idx                                                 f(3)
    if ( FrameIsIntra || error_resilient_mode ) {
        setup_past_independence ( )
        if ( frame_type == KEY_FRAME || error_resilient_mode == 1 || reset_frame_context == 3 ) {
            for ( i = 0; i < 4; i ++ ) {
                save_probs( i )
            }
        } else if ( reset_frame_context == 2 ) {
            save_probs( frame_context_idx )
        }
        frame_context_idx = 0
    }
    loop_filter_params( )
    quantization_params( )
    segmentation_params( )
    delta_q_params( )
    AllLossless = 1
    for ( segmentId = 0; segmentId < MAX_SEGMENTS; segmentId++ ) {
        qindex = get_qindex( 1, segmentId )
        LosslessArray[ segmentId ] = qindex == 0 && deltaQYDc == 0 && deltaQUVAc == 0 && deltaQUVDc == 0
        if ( !LosslessArray[ segmentId ] )
            AllLossless = 0
        if ( using_qmatrix ) {
            if ( LosslessArray[ segmentId ] ) {
                qmLevel = 15
            } else {
                qmLevel = min_qmlevel + ( base_q_idx * ( max_qmlevel - min_qmlevel + 1 ) ) / 256
            }
            SegQMLevel[ segmentId ] = qmLevel
        }
    }
    delta_lf_params( )
    read_tx_mode( )
    frame_reference_mode( )
    @@reduced_tx_set                                                    L(1)
    tile_info( )
    @@header_size_in_bytes                                              f(16)
}
</div>
