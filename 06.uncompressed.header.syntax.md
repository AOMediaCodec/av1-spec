### Uncompressed Header Syntax

~~~~~
uncompressed_header( ) {
    @@show_existing_frame                                                      f(1)
    if ( show_existing_frame == 1 ) {
        @@frame_to_show_map_idx                                                f(3)
        header_size_in_bytes = 0
        refresh_frame_flags = 0
        loop_filter_level = 0
        return
    }
    @@frame_type                                                               f(2)
    @@show_frame                                                               f(1)
    @@error_resilient_mode                                                     f(1)
    FrameIsIntra = (frame_type == INTRA_ONLY_FRAME || 
                    frame_type == KEY_FRAME)
    if ( frame_type == KEY_FRAME ) {
        frame_size( )
        render_size( )
        @@allow_screen_content_tools                                           f(1)
        refresh_frame_flags = 0xFF
    } else {
        if ( frame_type == INTRA_ONLY_FRAME ) {
            @@allow_screen_content_tools                                       f(1)
        }
        if ( error_resilient_mode ) {
            reset_frame_context = 0
        } else {
            if ( frame_type == INTRA_ONLY_FRAME ) {
                @@intra_reset_all                                              f(1)
                reset_frame_context = 1 + intra_reset_all
            } else {
                @@reset_frame_context                                          f(1)
                if ( reset_frame_context == 1 ) {
                    @@intra_reset_all                                          f(1)
                    reset_frame_context = 1 + intra_reset_all
                }
            }
        }
        if ( frame_type == INTRA_ONLY_FRAME ) {
            @@refresh_frame_flags                                              f(8)
            frame_size( )
            render_size( )
        } else {
            if (frame_type == SWITCH_FRAME ) {
                refresh_frame_flags = 0xFF
            } else {
                @@refresh_frame_flags                                          f(8)
            }
            for( i = 0; i < REFS_PER_FRAME; i++ ) {
                @@ref_frame_idx[ i ]                                           f(3)
                if (frame_type == SWITCH_FRAME ) {
                    ref_frame_sign_bias[ LAST_FRAME + i ] = 0
                } else {
                    @@ref_frame_sign_bias[ LAST_FRAME + i ]                    f(1)
                }
            }
            if ( error_resilient_mode ) {
                frame_size( )
                render_size( )
            } else {
                frame_size_with_refs( )
            }
            @@allow_high_precision_mv                                          f(1)
            read_interpolation_filter( )
        }
    }
    if ( error_resilient_mode ) {
        frame_parallel_decoding_mode = 1
    } else {
        @@frame_parallel_decoding_mode                                         f(1)
    }
    @@frame_context_idx                                                        f(3)
    if ( FrameIsIntra || error_resilient_mode ) {
        setup_past_independence ( )
        if ( frame_type == KEY_FRAME || error_resilient_mode == 1 || reset_frame_context == 3 ) {
            for ( i = 0; i < 4; i ++ ) {
                save_probs( i )
            }
        } else if ( reset_frame_context == 2 ) {
            save_probs( frame_context_idx )
        }
        frame_context_idx = 0
    }
    loop_filter_params( )
    quantization_params( )
    segmentation_params( )
    delta_q_params( )
    AllLossless = 1
    for ( segmentId = 0; segmentId < MAX_SEGMENTS; segmentId++ ) {
        qindex = get_qindex( 1, segmentId )
        LosslessArray[ segmentId ] = qindex == 0 && deltaQYDc == 0 && deltaQUVAc == 0 && deltaQUVDc == 0
        if ( !LosslessArray[ segmentId ] )
            AllLossless = 0
        if ( using_qmatrix ) {
            if ( LosslessArray[ segmentId ] ) {
                qmLevel = 15
            } else {
                qmLevel = min_qmlevel + ( base_q_idx * ( max_qmlevel - min_qmlevel + 1 ) ) / 256
            }
            SegQMLevel[ segmentId ] = qmLevel
        }
    }
    delta_lf_params( )
    cdef_params( )
    read_tx_mode( )
    global_motion_params( )
    frame_reference_mode( )
    @@reduced_tx_set                                                           f(1)
    tile_info( )
    @@header_size_in_bytes                                                     f(16)
}
~~~~~
{:.syntax }
