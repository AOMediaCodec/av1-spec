#### Residual Syntax

~~~~~
residual( ) {
    palette_tokens( )

    sbMask = ( MAX_SB_SIZE >> MI_SIZE_LOG2 ) - 1
    subBlockMiRow = r & sbMask
    subBlockMiCol = c & sbMask

    for ( plane = 0; plane < 1 + HasChroma * 2; plane++ ) {
        txSz = (plane > 0) ? get_uv_tx_size( ) : tx_size
        stepX = tx_size_wide[ txSz ] >> 2
        stepY = tx_size_high[ txSz ] >> 2
        planeSz = get_plane_block_size( MiSize, plane )
        num4x4W = num_4x4_blocks_wide_lookup[ planeSz ]
        num4x4H = num_4x4_blocks_high_lookup[ planeSz ]
        log2W = MI_SIZE_LOG2 + b_width_log2_lookup[ planeSz ]
        log2H = MI_SIZE_LOG2 + b_height_log2_lookup[ planeSz ]
        subX = (plane > 0) ? subsampling_x : 0
        subY = (plane > 0) ? subsampling_y : 0
        baseX = (MiCol >> subX) * MI_SIZE
        baseY = (MiRow >> subY) * MI_SIZE

        isInterIntra = ( is_inter && RefFrame[ 1 ] == INTRA_FRAME )
        isCFL = (plane > 0 && !is_inter && UVMode == UV_CFL_PRED)

        if ( isInterIntra ) {
            if ( interintra_mode == II_DC_PRED ) mode = DC_PRED
            else if ( interintra_mode == II_V_PRED ) mode = V_PRED
            else if ( interintra_mode == II_H_PRED ) mode = H_PRED
            else mode = SMOOTH_PRED
        } else {
            mode = DC_PRED
        }

        if ( isInterIntra || isCFL ) {
            predict_intra( plane, baseX, baseY,
                           AvailL,
                           AvailU,
                           BlockDecoded[ plane ]
                                       [ ( subBlockMiRow >> subY ) - 1 ]
                                       [ ( subBlockMiCol >> subX ) + num4x4W ],
                           BlockDecoded[ plane ]
                                       [ ( subBlockMiRow >> subY ) + num4x4H ]
                                       [ ( subBlockMiCol >> subX ) - 1 ],
                           mode,
                           log2W, log2H )
        }

        if ( is_inter ) {
            predict_inter( plane, baseX, baseY,
                           num4x4W * 4, num4x4H * 4 )
        }

        maxX = (MiCols * MI_SIZE) >> subX
        maxY = (MiRows * MI_SIZE) >> subY
        for( y = 0; y < num4x4H; y += stepY ) {
            for( x = 0; x < num4x4W; x += stepX ) {
                startX = baseX + 4 * x
                startY = baseY + 4 * y
                nonzero = 0
                if ( startX < maxX && startY < maxY ) {
                    if ( !is_inter ) {
                        if ( ( ( plane == 0 ) && PaletteSizeY ) ||
                             ( ( plane != 0 ) && PaletteSizeUV ) ) {
                            predict_palette( plane, startX, startY, x, y, txSz )
                        } else if ( isCFL ) {
                            predict_chroma_from_luma( plane, startX, startY, txSz )
                        } else {
                            mode = ( plane == 0 ) ? YMode : UVMode
                            log2W = tx_size_wide_log2[ txSz ]
                            log2H = tx_size_high_log2[ txSz ]
                            predict_intra( plane, startX, startY,
                                           AvailL || x > 0,
                                           AvailU || y > 0,
                                           BlockDecoded[ plane ]
                                                       [ ( subBlockMiRow >> subY ) + y - 1 ]
                                                       [ ( subBlockMiCol >> subX ) + x + stepX ],
                                           BlockDecoded[ plane ]
                                                       [ ( subBlockMiRow >> subY ) + y + stepY ]
                                                       [ ( subBlockMiCol >> subX ) + x - 1 ],
                                           mode,
                                           log2W, log2H )
                        }
                        if (plane == 0) {
                            MaxLumaW = startX + stepX * 4
                            MaxLumaH = startY + stepY * 4
                        }
                    }
                    if ( !skip ) {
                        nonzero = tokens( plane, startX, startY,
                                          txSz )
                        reconstruct( plane, startX, startY, txSz )
                    }
                }
                for ( i = 0; i < stepX; i++ )
                    for ( j = 0; j < stepY; j++ )
                        BlockDecoded[ plane ]
                                    [ ( subBlockMiRow >> subY ) + y + j ]
                                    [ ( subBlockMiCol >> subX ) + x + i ] = 1

                for ( i = 0; i < stepX; i++ )
                    AboveNonzeroContext[ plane ][ ( startX >> 2 ) + i ] = nonzero
                for ( i = 0; i < stepY; i++ )
                    LeftNonzeroContext[ plane ][ ( startY >> 2 ) + i ] = nonzero
            }
        }
    }
}
~~~~~
{:.syntax }

