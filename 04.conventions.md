## Conventions

The mathematical operators and their precedence rules used to describe this
Specification are similar to those used in the C programming language.
However, the operation of integer division with truncation is specifically
defined.

In addition, an array with 2 elements used to hold a motion vector (indicated
by the variable name ending with the letters `Mv` or `Mvs`) can be accessed
using either normal array notation (e.g. `Mv[ 0 ]` and `Mv[ 1 ]`), or by just
the name (e.g., `Mv`). The only operations defined when using the name are
assignment and equality/inequality testing. Assignment of an array is
represented using the normal notation `A = B` and is specified to mean the same
as doing both the individual assignments `A[ 0 ] = B[ 0 ]` and
`A[ 1 ] = B[ 1 ].` Equality testing of 2 motion vectors is represented using the
notation `A == B` and is specified to mean the same as
`(A[ 0 ] == B[ 0 ] && A[ 1 ] == B[ 1 ])`. Inequality testing is defined as
`A != B` and is specified to mean the same as
`(A[ 0 ] != B[ 0 ] || A[ 1 ] != B[ 1 ])`.

When a variable is said to be representable by a signed integer with `x` bits,
it means that the variable is greater than or equal to `-(1 << (x-1))`, and that
the variable is less than or equal to `(1 << (x-1))-1`.


### Arithmetic operators

|          |         |
|:--------:| ------- |
| `+`      | Addition
| `â€“`      | Subtraction (as a binary operator) or negation (as a unary prefix operator)
| `*`      | Multiplication
| `/`      | Integer division with truncation of the result toward zero. For example, `7/4` and `-7/-4` are truncated to `1` and `-7/4` and `7/-4` are truncated to `-1`.
| `a % b`  |  Remainder from division of `a` by `b`. Both `a` and `b` are positive integers.
{:.table .table-sm .table-bordered .table-nohead }


### Logical operators

|          |         |
|:--------:| ------- |
| `a && b` | Logical AND operation between `a` and `b`
| `a || b` | Logical OR operation between `a` and `b`
| `!`      | Logical NOT operation.
{:.table .table-sm .table-bordered .table-nohead }


### Relational operators

|          |         |
|:--------:| ------- |
| `>`      | Greater than
| `>=`     | Greater than or equal to
| `<`      | Less than
| `<=`     | Less than or equal to
| `==`     | Equal to
| `!=`     | Not equal to
{:.table .table-sm .table-bordered .table-nohead }


### Bitwise operators

|          |         |
|:--------:| ------- |
| `&`      | AND operation
| `|`      | OR operation
| `^`      | XOR operation
| `~`      | Negation operation
| `a >> b` | Shift `a` in 2's complement binary integer representation format to the right by `b` bit positions. This operator is only used with `b` being a non-negative integer. Bits shifted into the MSBs as a result of the right shift have a value equal to the MSB of `a` prior to the shift operation.
| `a << b` | Shift `a` in 2's complement binary integer representation format to the left by `b` bit positions. This operator is only used with `b` being a non-negative integer. Bits shifted into the LSBs as a result of the left shift have a value equal to `0`.
{:.table .table-sm .table-bordered .table-nohead }


### Assignment

|          |         |
|:--------:| ------- |
| `=`      | Assignment operator
| `++`     | Increment, `x++` is equivalent to `x = x + 1`. When this operator is used for an array index, the variable value is obtained before the auto increment operation
| `--`     | Decrement, i.e. `x--` is equivalent to `x = x - 1`. When this operator is used for an array index, the variable value is obtained before the auto decrement operation
| `+=`     | Addition assignment operator, for example `x += 3` corresponds to `x = x + 3`
| `-=`     | Subtraction assignment operator, for example `x -= 3` corresponds to `x = x - 3`
{:.table .table-sm .table-bordered .table-nohead }


### Mathematical functions

The following mathematical functions (Abs, Clip3, Clip1, Min, Max, Round2
and Round2Signed) are defined as follows:

<img src="assets/images/formula-abs.svg.png" class=".img-fluid" alt="">

<img src="assets/images/formula-clip1.svg.png" class=".img-fluid" alt="">

<img src="assets/images/formula-clip3.svg.png" class=".img-fluid" alt="">

<img src="assets/images/formula-min.svg.png" class=".img-fluid" alt="">

<img src="assets/images/formula-max.svg.png" class=".img-fluid" alt="">

<img src="assets/images/formula-round2.svg.png" class=".img-fluid" alt="">

<img src="assets/images/formula-round2signed.svg.png" class=".img-fluid" alt="">

{% comment %}
# ASCIIMath formula depictions

"abs"(x)={[x;,x >= 0],[-x;,x<0]}
"Clip3"(x,y,z)={[x;,z < x],[y;,z>y],[z;,otherwise]}
"Clip1(x)"="Clip3"(0,2^("BitDepth")-1,x)
"Min"(x,y)={[x;,x<=y],[y;,x>y]}
"Max"(x,y)={[x;,x>=y],[y;,x<y]}
"Round2"(x,n)=|__(x+(2^(n-1)))/(2^n)__|
"Round2Signed"(x,n)={["Round2"(x,n);, x >= 0], [-"Round2"(-x,n);, x < 0]}

{% endcomment %}

### Method of describing bitstream syntax

The description style of the syntax is similar to the C programming language.
Syntax elements in the bitstream are represented in bold type. Each syntax
element is described by its name (using only lower case letters with
underscore characters) and a descriptor for its method of coded
representation. The decoding process behaves according to the value of the
syntax element and to the values of previously decoded syntax elements. When a
value of a syntax element is used in the syntax tables or the text, it appears
in regular (i.e. not bold) type. If the value of a syntax element is being
computed (e.g. being written with a default value instead of being coded in
the bitstream), it also appears in regular type (e.g. tile_size).

In some cases the syntax tables may use the values of other variables derived
from syntax elements values. Such variables appear in the syntax tables, or
text, named by a mixture of lower case and upper case letter and without any
underscore characters. Variables starting with an upper case letter are
derived for the decoding of the current syntax structure and all depending
syntax structures. These variables may be used in the decoding process for
later syntax structures. Variables starting with a lower case letter are only
used within the process from which they are derived.

Constant values appear in all upper case letters with underscore characters (e.g. MI_SIZE).

Constant lookup tables appear as words (with the first letter of each word in upper case,
and remaining letters in lower case) separated with underscore
characters (e.g. Block_Width[...]).

Hexadecimal notation, indicated by prefixing the hexadecimal number by `0x`,
may be used when the number of bits is an integer multiple of 4. For example,
`0x1a` represents a bit string `0001 1010`.

Binary notation is indicated by prefixing the binary number by `0b`. For
example, `0b00011010` represents a bit string `0001 1010`. Binary numbers may
include underscore characters to enhance readability. If present, the
underscore characters appear every 4 binary digits starting from the LSB. For
example, `0b11010` may also be written as `0b1_1010`.

A value equal to 0 represents a FALSE condition in a test statement. The
value TRUE is represented by any value not equal to 0.

The following table lists examples of the syntax specification format. When
`syntax_element` appears (with bold face font), it specifies that this syntax
element is parsed from the bitstream.


~~~~~
/* A statement can be a syntax element with associated
descriptor or can be an expression used to specify its
existence, type, and value, as in the following examples */

@@syntax_element                                                               f(1)

/* A group of statements enclosed in brackets is a
compound statement and is treated functionally as a single
statement. */

{
    statement
    ...
}

/* A "while" structure specifies that the statement is
to be evaluated repeatedly while the condition remains
true. */

while ( condition )
    statement

/* A "do .. while" structure executes the statement once,
and then tests the condition. It repeatedly evaluates the
statement while the condition remains true. */

do
    statement
while ( condition )

/* An "if .. else" structure tests the condition first. If
it is true, the primary statement is evaluated. Otherwise,
the alternative statement is evaluated. If the alternative
statement is unnecessary to be evaluated, the "else" and
corresponding alternative statement can be omitted. */

if ( condition )
    primary statement
else
    alternative statement

/* A "for" structure evaluates the initial statement at the
beginning then tests the condition. If it is true, the primary
and subsequent statements are evaluated until the condition
becomes false. */

for ( initial statement; condition; subsequent statement )
    primary statement
~~~~~
{:.syntax }


### Functions

Bitstream functions used for syntax description are specified in this section.

Other functions are included in the syntax tables.
The convention is that a section is called syntax if it causes syntax elements to be read from the bitstream, either directly or indirectly through subprocesses.
The remaining sections are called functions.

The specification of these functions makes use of a bitstream position
indicator. This bitstream position indicator locates the position of the bit
that is going to be read next.

**get_position( ):** Return the value of the bitstream position indicator.

**init_bool( sz ):** Initialize the arithmetic decode process for the boolean
decoder with a size of sz bytes as specified in [section 8.2.1][].

**exit_bool( ):** Exit the arithmetic decode process as described in [section 8.2.3][].


### Descriptors

The following descriptors specify the parsing of syntax elements. Lower case
descriptors specify syntax elements that are represented by a fixed integer
number of bits in the bitstream; upper case descriptors specify syntax elements
that are represented by arithmetic coding.


#### f(n)

Unsigned n-bit number appearing directly in the bitstream. The bits are read
from high to low order.  The parsing process specified in [section 8.1][] is
invoked and the syntax element is set equal to the return value.

#### le(n)

Unsigned little-endian n-byte number appearing directly in the bitstream.
The parsing process for this descriptor is specified below:

~~~~~
le(n) {
    t = 0
    for( i = 0; i < n; i++) {
        @@byte                                                                 f(8)
        t += ( byte << ( i * 8 ) )
    }
    return t
}
~~~~~
{:.syntax }

**Note:** This syntax element will only be present when the bitstream position
is byte aligned.
{:.alert .alert-info }

#### su(n)

Signed integer converted from an n+1 unsigned integer in the bitstream.
(The unsigned integer corresponds to the bottom n+1 bits of the signed integer.)
The parsing process for this descriptor is specified below:

~~~~~
su(n) {
    @@value                                                                    f(n+1)
    signBit = 1 << n
    if (value & signBit)
        value = value - 2 * signBit
    return value
}
~~~~~
{:.syntax }


#### L(n)

Unsigned arithmetic encoded n-bit number encoded as n flags (a "literal"). The
flags are read from high to low order.  The syntax element is set equal to the
return value of read_literal( n ) (see [section 8.2.4][] for a specification of
this process).


#### S

An arithmetic encoded symbol coded from a small alphabet of at most 16 entries.

The symbol is decoded based on a context sensitive CDF (see [section 8.3][] for the specification of this process).

#### U(n)

Unsigned arithmetic encoded number with maximum number of values n (i.e. output in range 0..n-1).

This descriptor is similar to L(ceil(log2(n))), but reduces wastage incurred when encoding non-power of two
value ranges by encoding 1 fewer bits for the lower part of the value range. For example, when
n is equal to 5, the encodings are as follows (full binary encodings are also presented for
comparison):

| Value | Full binary encoding | U(n) encoding |
|:-----:|:--------------------:|:-------------:|
|     0 |                  000 |            00 |
|     1 |                  001 |            01 |
|     2 |                  010 |            10 |
|     3 |                  011 |           110 |
|     4 |                  100 |           111 |
{:.table .table-sm .table-bordered .table-striped }

The parsing process for this descriptor is specified below:

~~~~~
U( n ) {
    w = floor(log2(n)) + 1
    m = (1 << w) - n
    @@v                                                                        L( w - 1 )
    if (v < m)
        return v
    @@extra_bit                                                                L( 1 )
    return (v << 1) - m + extra_bit
}
~~~~~
{:.syntax }
